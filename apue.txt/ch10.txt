第10章
 
10.1引言
信号是软件中断。很多比较重要的应用程序都需处理信号。信号提供了一种处理异步事件 的方法，例如，终端用户键入中断键，则会通过信号机制停止一个程序，或及早终止管道中的 下一个程序。
UNIX的早期版本就已经提供了信号机制，但是这些系统(例如V7)所提供的信号模型并 不可靠。信号可能丢失，而且在执行临界区代码时，进程很难关闭所选择的信号。4.3BSD和 SVR3对信号模型都做了更改，增加了可靠信号机制。但是Berkeley和AT&T所做的更改之间并 不兼容。幸运的是POSIX.1对可靠信号例程进行了标准化，这正是本章所要说明的。
本章先对信号机制进行综述，并说明每种信号的一般用法。然后分析早期实现的问题。在 分析存在的问题之后再说明解决这些问题的方法，这种安排有助于加深对改进机制的理解。本 章也包含了很多并非完全正确的实例，这样做的目的是为了对其不足之处进行讨论。
10.2信号概念
首先，每个信号都有一个名字。这些名字都以三个字符SIG开头。例如，SIGABRT是夭折 信号，当进程调用abort函数时产生这种信号。SIGALRM是闹钟信号，当由alarm函数设置的 计时器超时后产生此信号。V7有15种不同的信号，SVR4和4.4BSD均有31种不同的信号。 FreeBSD 5.2.1、Mac OS X 10.3以及Linux 2.4.22支持31种不同的信号，而Solaris 9则支持38种不 同的信号。另外，Linux和Solaris都支持应用程序额外定义的信号，将其作为实时扩展(本书不 包括POSIX实时扩展，有关信息请参阅GallmeiSter[1995])。
在头文件<3；^1^1.11>中，这些信号都被定义为正整数(信号编号)。
实际上，实现将各信号定义在另一个头文件中，但是该头文件又包括S<signal.h>*。内核包 括对用户级应用程序有意义的头文件，这被认为是一种糟糕的形式，所以如若应用程序和内核两者都 需使用同一定义，那么就将有关信息放5在内核头文件中，然后用卢级头文件再包括该内核头文件。 于是，FreeBSD 5.2,1 和Mac OS X 10 3将信号定义在<sys/signal.h>*, Linux 2.4.22将信号定义在
<bits/signum.h>中，Solaris 9则将信号定义S<sys/iso/signal_iso.h> ':
不存在编号为0的信号。在10.9节中将会看到，kill函数对信号编号0有特殊的应用。 POSIX.1将此种信号编号值称为空信号。
很多条件可以产生信号：
•当用户按某些终端键时，引发终端产生的信号。在终端上按DELETE键(或者很多系统

 
234 第10章信 号
中的Ctrl+C键)通常产生中断信号(SIGINT)。这是停止一个已失去控制的程序的方法。 (第18章将说明此信号可被映射为终端上的任一字符。)
•硬件异常产生信号：除数为0、无效的内存引用等等。这些条件通常由硬件检测到，并将 其通知内核。然后内核为该条件发生时正在运行的进程产生适当的信号。例如，对执行 一个无效内存引用的进程产生SIGSEGV信号。
•进程调用kill(2)函数可将信号发送给另一个进程或进程组。自然，对此有所限制：接收信 号进程和发送信号进程的所有者必须相同，或者发送信号进程的所有者必须是超级用户。
•用户可用kill(l)命令将信号发送给其他进程。此命令只是kill函数的接口。常用此命 令终止一个失控的后台进程。
•当检测到某种软件条件已经发生，并应将其通知有关进程时也产生信号。这里指的不是 硬件产生的条件(如除以0),而是软件条件。例如SIGURG (在网络连接上传来带外数据 时产生〉、SIGPIPE (在管道的读进程已终止后，一个进程写此管道时产生〉，以及 SIGALRM (进程所设置的闹钟时钟超时时产生)。
信号是异步事件的经典实例。产生信号的事件对进程而言是随机出现的。进程不能简单地 测试一个变量(例如errno〉来判别是否出现了一个信号，而是必须告诉内核“在此信号出现 [2W]时，请执行下列操作”。
可以要求内核在某个信号出现时按照下列三种方式之一进行处理，我们称之为信号的处理 或者与信号相关的动作。
(1)	忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。 它们是SIGKILL和SIGST0P。这两种信号不能被忽略的原因是：它们向超级用户提供了使进 程终止或停止的可靠方法。另外，如果忽略某些由硬件异常产生的信号(例如非法内存引用或 除以0),则进程的运行行为是未定义的。
(2)	捕捉信号。为了做到这一点，要通知内核在某种信号发生时调用一个用户函数。在用 户函数中，可执行用户希望对这种事件进行的处理。例如，若正在运行一个命令解释器，它将 用户的输入解释为命令并执行之，当用户用键盘产生中断信号时，很可能希望该命令解释器返 回到主循环，终止正在为该用户执行的命令。如果捕捉到SIGCHLD信号，则表示一个子进程已 经终止,所以此信号的捕捉函数可以调用waitpid以取得该子进程的进程ID以及它的终止状态。 又例如，如果进程创建了临时文件，那么可能要为SIGTERM信号编写一个信号捕捉函数以清除 临时文件(SIGTERM是终止信号，kill命令传送的系统默认信号是终止信号)。注意，不能捕 IESIGKILL 和 SIGST0P 信号。
(3)	执行系统默认动作。表10-1给出了针对每一种信号的系统默认动作。注意，针对大多数 信号的系统默认动作是终止进程。
表10-1列出了所有信号的名字，说明了哪些系统支持此信号以及针对这些信号的系统默认 动作。在SUS列中，•表示此种信号被定义为基本POSIX.1规范部分，“XSI”表示该信号定义为 该基本规范的XSI扩展。
在“默认动作”列中，“终止+core”表示在进程当前工作目录的core文件中复制该进程的 存储映像(该文件名为core,由此可以看出这种功能很久以前就是UNIX的一部分〉。大多数 UNIX调试程序都使用core文件以检查进程终止时的状态。

 
10.2信号概念 235
表10-1 UNIX系统信号
名字	说明	ISOC	SUS	FreeBSD
5.2.1	Linux
2.4.22	Mac OS X 10.3	Solaris
9	默认动作
SIGABRT	异常终止(abort)	•	•	•	•			终止+core
SIGALRM	超时(alarm)		•	•	•			终止
SIGBUS	硬件故障		•	•	•			终止+core
SIGCANCEL	线程库内部使用							忽略
SIGCHLD	子进程状态改变		•	•	•			忽略
SIGCONT	使暂停进程继续		•	•	•			继续/忽略
SIGEMT	硬件故障			•	•			终止+core
SIGFPE	算术异常	•	•	•	•			终止+core
SIGFREEZE	检查点冻结							忽略
SIGHUP	连接断开		•	•	•			终止
SIGILL	非法硬件指令	•	•	•	•			终止+core
SIGINFO	键盘状态请求			•				忽略
SIGINT	终端中断符	•	•	•	•			终止
SIGIO	异步I/O			•	•			终止/忽略
SIGIOT	硬件故障			•	•			终止+core
SIGKILL	终止		•	•	•			终止
SIGLWP	线程库内部使用							忽略
SIGPIPE	写至无读进程的管道		•	•	•			终止
SIGPOLL	可轮询事件(poll)		XSI		•			终止
SIGPROF	梗概时间超时		XSI	•	•			终止
	(setitimer)							
SIGPWR	电源失效/重启动				•			终止/忽略
SIGQUIT	终端退出符		•		•			终止+core
SIGSEGV	无效内存引用	•	•		•			终止+core
SIGSTKFLT	协处理器栈故障				鲁			终止
SIGSTOP	停止		•		•			暂停进程
SIGSYS	无效系统调用		XSI		•			终止+core
SIGTERM	终止	•	•		•			终止
SIGTHAW	检查点解冻							忽略
SIGTRAP	硬件故障		XSI		•			终止+core
SIGTSTP	终端停止符		•					暂停进程
SIGTTIN	后台读控制tty		•		•			暂停进程
SIGTTOU	后台写至控制tty		•		•			暂停进程
SIGURG	紧急情况(套接字)		參		鲁			忽略
SIGUSR1	用户定义的信号		•					终止
SIGUSR2	用户定义的信号		•					终止
SIGVTALRM	虚拟时间闹钟		XSI					终止
	(setitimer)							
sigwaiting	线程库内部使用							忽略
SIGWINCH	终端窗口大小改变			•	•	•		忽略
SIGXCPU	超过CPU限制		XSI	•	•	•		终止+core/
	(setrlimi t)							忽略
SIGXFSZ	超过文件长度限制		XSI	•	•	•	•	终止+core/
	(setrlimit)							忽略
SIGXRES	超过资源控制						參	忽略

 
236 第10章信 号
291	 i
292
core文件是大多数UNIX系统的实现特征。虽然该特征不是POSIX.I的组成部分，但曾经提及这可 能作为实现特定动作成为Single UNIX Specification的XSI扩展。
在不同的实现中，core文件的名字可能不同。例如，在FreeBSD 5.2.1中，core文件名为 cmdname.core,甚中是接收到信号的进程所执行的命令名。在Mac OS X 10.3中，core文件名 是core.p/V/，其中，ptW是接收到信号的进程的ID。(这些系统允许经sysctl参数配置core文件名。)
大多数实现在相应进程的当前工-作目录中存放core文件；但Mac OS X将所有core文件都放置在 /cores目录中。
在下列条件下不产生core文件：(a)进程是设置用户ID的，而且当前用户并非程序文件的所 有者，(b)进程是设置组ID的，而且当前用户并非该程序文件的组所有者，(c)用户没有写当前 工作目录的权限，(d)文件已存在，而且用户对该文件设有写权限，(e)文件太大(回忆7.11节 中的RLIMIT_CORE限制)。core文件的权限(假定该文件在此之前并不存在)通常是用户读/ 写，但Mac OS X只设置为用户读。
在表10-1说明中的“硬件故障”对应干实现定义的硬件故障。这些名字中有很多取自UNIX 早先在PDP-11上的实现。请查看你所使用的系统手册，以确切地弄清楚这些信号对应干哪些错 误类型。
下面较详细地逐一说明这些信号。
SIGABRT 调用abort函数时(见10.17节)产生此信号。进程异常终止。
SIGALRM 在用alarm函数设置的计时器超时时，产生此信号(详细情况见10.10节) 若由setitimer⑵函数设置的间隔时间超时时，也会产生此信号。
SIGBUS 指本一个实现定义的硬件故障。当出现某些类型的内存故障时(如14.9节中 说明的)，•常常产生此种信号。
SIGCANCEL这是Solaris线程库内部使用的信号。它不供一般应用。
SIGCHLD 在一个进程终止或停止时，将SIGCHLD信号发送给其父进程。按系统默认， 将忽略此信号。如果父进程希望被告知其子进程的这种状态改变，则应捕 捉此信号。信号捕捉函数中通常要调用一种wait函数以取得子进程ID和其 终止状态。
系统V的早期版本有一个名为SIGCLD (无H)的类似信号。这一信号 具有与其他信号不同的语义，SVR2的手册页警告在新的程序中尽量不要使 用这种信号。令人惊讶的是在SVR3和SVR4版本的手册页中，该警告消失了。 应用程序应当使用标准的SIGCHLD信号，但应了解，为了向后兼容，很多 系统定义了与SIGCHLD等同的SIGCLD。(如果有使用SIGCLD的软件，需 要查阅系统手册，了解它的具体语义。)10.7节将讨论这两个信号。
SIGC0NT 此作业控制信号被发送给需要继续运行，但当前处干停止状态的进程。如 果接收到此信号的进程处于停止状态，则系统默认动作是使该进程继续运 行，否则默认动作是忽略此信号。例如，全屏幕编辑器在捕捉到此信号后， 使用信号处理程序发出電新绘制终端屏幕的通知。关干进一步的情况见 10.20 节。
SIGEMT 指示一个实现定义的硬件故障。

 
10.2信号概念 237
EMT这一名字来自PDP-11的“仿真器陷人”(emulator trap )指令。并非所有平台都支持此信号。
例如，Linux只对SPARC、MIPS和PA_RISC等体系结构支持SIGEMT。
SIGFPE 此信号表示一个算术运算异常，例如除以0，浮点溢出等。
SIGFREEZE此信号仅由Solaris定义。它用干通知进程在冻结系统状态之前需要采取特定 动作，例如当系统进入冬眠或挂起模式时可能需要执行这种处理。
SIGHUP 如果终端接口检测到一个连接断开，则将此信号发送给与该终端相关的控 制进程(会话首进程)。见图9-11，此信号被送给session结构中的5_ leader字段所指向的进程。仅当终端的CL0CAL标志没有设置时，在上述 条件下才产生此信号。(如果所连接的终端是本地的，则设置该终端的 CL0CAL标志。它告诉终端驱动程序忽略所有调制解调器的状态行。第18章 将说明如何设置此标志。)
注意，接到此信号的会话首进程可能在后台，例如，参见图9-7。这有 别于由终端正常产生的几个信号(中断、退出和挂起)，这些信号总是传递 给前台进程组。
如果会话首进程终止，则也产生此信号。在这种情况下，此信号将被发 送给前台进程组中的每一个进程。
通常用此信号通知守护进程(见第13章)，以重新读取它们的配置文件。 为此目的选用SIGHUP的理由是，守护进程不会有控制终端，而且通常决不 会接收到这种信号。
SIGILL 此信号指示进程已执行一条非法硬件指令。
原先，4.3BSD的abort函数产生此信号。现在该函数产生SIGABRT信号。
SIGINF0 这是一种BSD信号，当用户按状态键(一般采用Ctrl+T)时，终端驱动程序 产生此信号并送至前台进程组中的每一个进程(见图9-8)。此信号通常导致 在终端上显示前台进程组中各进程的状态信息。
除了在Alpha平台上将SIGINFO定义为与SIGPWR具有相同的值之外，Linux不支持这种信号。
SIGINT 当用户按中断键(一般采用DELETE或Ctrl+C)时，终端驱动程序产生此信 号并送至前台进程组中的每一个进程(见图9-8)。当一个进程在运行时失控, 特别是它正在屏幕上产生大量不需要的输出时，常用此信号终止它。
SIGI0	此信号指示一个异步I/O事件。在14.6.2节中将对此进行讨论。
在表10-1中，针对SIGI0的系统默认动作是终止或忽略。不幸的是.这依赖于系统。在系统V中'
SIGI0与SIGP0LL相同，因此其默认动作是终止此进程。在BSD中，其默认动作是忽略此信号。
Linux 2.4.22和Solaris 9将SIGIO定义为与SIGP0LL具有相同的值，所以默认行为是终止该进程。
在FreeBSD 5.2.1和Mac OS X 10.3中，默认行为是忽略该信号。
SIGI0T 这指示一个实现定义的硬件故障。
10T这个名字来自于PDP-11，它是PDP-11计算机“输入/输出TRAP” (input/output TRAP)指令的
缩写。在系统V的早期版本中，由abort函数产生此信号。该函数现在产生SIGABRT信号

 
238 第10章信 号
在FreeBSD 5.2.1、Linux 2.4.22、Mac OS X 10.3和Solaris 9 中将SIGIOT定义为与 SIGABRT具有相同 的值。
SIGKILL 这是两个不能被捕捉或忽略的信号之一。它向系统管理员提供了一种可以 杀死任一进程的可靠方法。
SIGLWP 此信号由Solaris线程库内部使用，并不作一般使用。
SIGPIPE 如果在写到管道时读进程已终止，则产生此信号。15.2节将说明管道。当类 型为SOCK_STREAM的套接字已不再连接时，进程写到该套接字也产生此信 号。我们将在第16章说明套接字。
SIGP0LL 当在一个可轮询设备上发生一特定事件时产生此信号。14.5.2节将说明poll 函数和此信号。它起源干SVR3，并松散对应干BSD的SIGI0和SIGURG信号。
在Linux和Solaris中，SIGP0LL被定义为与SIGI0具有相同的值。
SIGPR0F 当setitimer⑵函数设置的梗概统计间隔计时器(profiling interval timer) 已到期时产生此信号。
SIGPWR 这是一种依赖干系统的信号。它主要用干具有不间断电源(UPS)的系统。
如果电源失效，则UPS起作用，而且通常软件会接到通知。在这种情况下， 系统依靠蓄电池电源继续运行，所以无须任何处理。但是如果蓄电池也将 不能支持工作，则软件通常会再次接到通知，此时，系统必项在15~30秒 内使其各部分都停止运行。此时应当发送SIGPWR信号。在大多数系统中， 接到蓄电池电压过低信息的进程将信号SIGPWR发送给init进程，然后由 init处理停机操作。
Linux 2.4.22和Solaris 9在inittab文件中有两个项用于此种目的，它们是powerfail以及powerwait (或 powerokwait) 0
在表10-1中，我们将SIGPWR的默认动作标记为：“终止”或者“忽略”。不幸的是，这种默认依赖 [^1] 于系统。Linux的默认动作是终止相关进程，Solans的默认动作是忽略该信号。
SIGQUIT 当用户在终端上按退出键(一般采用Ctrl+\)时，产生此信号，并送至前台 进程组中的所有进程(见图9-8)。此信号不仅会终止前台进程组(如 SIGINT所做的那样)，同时还会产生一个core文件。
SIGSEGV 该信号指示进程进行了一次无效内存引用。
名字SEGV表示“段违例(segmentation violation)”。
SIGSTKFLT此信号仅由Linux定义。它出现在Linux的早期版本，旨在用干数学协处理器 的栈故障。该信号并非由内核产生，但仍保留以向后兼容。
SIGST0P 这是一个作业控制信号，用于停止一个进程。它类似于交互停止信号 (SIGTSTP),但是SIGST0P不能被捕捉或忽略。
SIGSYS 该信号指示一个无效的系统调用。由于某种未知的原因，进程执行了一条 机器指令，内核认为这是一个系统调用，但该指令指示系统调用类型的参 数却是无效的。这种情况是可能发生的，例如，若用户编写了一道使用新

 
10.2信号概念 239
系统调用的程序，然后尝试运行该程序的二进制可执行代码，而所用的操 作系统却是不支持该系统调用的较早版本，干是就会出现上述情况。
SIGTERM 这是由kill(l)命令发送的系统默认终止信号。
SIGTHAW 此信号仅由Solaris定义。当系统恢复运行被挂起的操作时，该信号用干通知 相关进程，它们需要采取特殊的动作。
SIGTRAP 指示一个实现定义的硬件故障。
此信兮名来自于PDP-11的TRAP指令。当执行断点推令时，实现常用此信号将控制转移至调试程序。
SIGTSTP 交互式停止信号，当用户在终端上按挂起键(一般采用Ctrl+Z)时，终端驱 动程序产生此信号。该信号送至前台进程组中的所有进程(参见图9-8)。
不幸的是，停止(stop)这个术语具有不同的含义。当讨论作业控制和信号时，我们谈及停止和 继续执行作业。但是，终端驱动程序一直使用术语“停止"表示用Ctrl+S字符停止终端输出，为了继 续启动该终端输出，则用Ctrl+Q字符。为此，终端驱动程序称产生交互式停止信号的字符为挂起字符， 而非停止字符。
SIGTTIN 当一个后台进程组中的进程试图读其控制终端时，终端驱动程序产生此信 号(见9.8节中对此问题的讨论)。在下列特殊情形下不产生此信号：(3)读 进程忽略或阻塞此信号，(b)读进程所属的进程组是孤儿进程组，此时读操 作返回出错，并将errno设置为EI0。
SIGTT0U 当一个后台进程组中的进程试图写到其控制终端时产生此信号(见9.8节对 此主题的讨论)。与上面所述的SIGTTIN信号不同，一个进程可以选择允许 后台进程写到控制终端。第18章将讨论如何更改此选项。
如果不允许后台进程写，则与SIGTTIN相似，也有两种特殊情况：(a) 写进程忽略或阻塞此信号，(b)写进程所属进程组是孤儿进程组。在这两种 情况下不产生此信号，写操作返回出错，并将errno设置为EI0。
不论是否允许后台进程写，某些除写以外的下列终端操作也能产生此信 号：tcsetattr、tcsendbreak、tcdrain、tcflush, tcf]ow以及 tcsetpgrp。第IS章将说明这些终端操作。
SIGURG 此信号通知进程已经发生一个紧急情况。在网络连接上接收到带外的数据 时，可选择产生此信号。
SIGUSR1 这是一个用户定义的信号，可用干应用程序。
SIGUSR2 这是另一个用户定义的信号，与SIGUSR1相似，可用干应用程序。
SIGVTALRM当一个由setitimer⑵函数设置的虚拟间隔时间到期时产生此信号。
SIGWAITING此信号由Solaris线程库内部使用，不作它用。
SIGWINCH 内核维持与每个终端或伪终端相关联的窗口大小。进程可以用ioctl函数 (见18.12节的说明)得到或设置窗口的大小。如果进程用ioctl的设置窗口大 小命令更改了窗口大小’则内核产生SIGWINCH信号并将其送至前台进程组。
SIGXCPU Single UNIX Specification的XSI扩展支持资源限制的概念(见7.11节)。如果 进程超过了其软CPU时间限制，则产生SIGXCPU信号。

 
240 第10章信 号
在表10-1中，针对SIGXCPU的默认动作被标记为“终止并创建core文件”或“忽略' 不幸的是， [297] 该默认动作依赖于操作系统。Linux 2.4.22和Solaris 9支持的默认动作是“终止并创建core文件”； FreeBSD 5.2.1和Mac OS X 10.3支持的默认动作是“忽略”。Single UNIX Specification要求该默认劝作 是异常终止该进程，是否创建core文件则留给实现决定。
SIGXFSZ 如果进程超过了其软文件长度限制(见7.11节)，则产生此信号。
如同SIGXCPU—样，针对SIGXFSZ的默认动作依赖于操作系统。Linux 2.4.22和Solaris 9对此信号 的默认动作是“终止进程并创建core文件”。FreeBSD 5.2.1和Mac OS X 10.3支持的默认动作是“忽略”。 Single UNIX Specification要求该默认动作是异常终止该进程，是否创建core文件则留给实现决定。
SIGXRES 此信号仅由Solaris定义。可选择使用此信号以通知进程超过了预配置的资源 值。Solaris资源限制机制是一种通用设施，用于控制在独立应用程序集之间 使用共享资源。
10.3 signal 函数
UNIX系统的信号机制最简单的接口是signal函数。
#include <signal.h>
void (*signal (int signo, void [*func) (int))) (int)；
返回值：若成功则返S信号以前的处理配置(见下)，若出错则返回SIG_ERR
signal函数由ISO C定义。因为ISO C不涉及多进程、进程组以及终端I/O等，所以它对信号的定 义非常含糊，以至于对UNIX系统而言几乎毫无用处。
从UNIX系统V派生的实现支持signal函数，但该函数提供旧的不可靠信号语义(10.4节将说明 这些旧语义)。提供此函数主要是为了向后兼容那些需要此旧语义的应用程序，新应用程序不应使用这 些不可靠信号。
4.4BSD也提供signal函数，但它是按照sigaction函数定义的(10.14节将说明3193(；1^011函数)， 所以在4.4BSD之下使用它提供新的可靠信号语义。FreeBSD和Mac OS X遵循此种策略。
Solaris 9植根于系统V和BSD，但在signal函数方面，它依从系统V语义。
Linux 2.4.22的signal语义依从BSD或者系统V，这取决于C函数库的版本，以及编译应用程序的 方法。
因为signal的语义与实现有关，所以最好使用sigaction函数代替signal函数。在10.4节讨论 sigaction函数时，提供了使用该函数的一个signal实现。本书中的所有实例均使用程序清单10-12 丨298丨 中给出的signal函数。
数是表10-1中的信号名。/m/ic的值是常量SIG_IGN、常量SIG_DFL或当接到此信号 后要调用的函数的地址。如果指定SIG_IGN,则向内核表示忽略此信号(记住有两个信号 SIGKILL和SIGST0P不能忽略)。如果指定SIG_DFL，则表示接到此信号后的动作是系统默认 动作(见表10-1中的最后1列)。当指定函数地址时，则在信号发生时，调用该函数，我们称这 种处理捕捉”该信号。称此函数为信号处理程序(signal handler)或信号捕捉函数 (signal-catching function)。 signal函数原型说明此函数需要两个参数，返回一个函数指针，而该指针所指向的函数

 
10.3 signal 函数 241
无返回值(void)。第一个参数是一个整数，第二个参数是函数指针，它所指向的函数需 要一个整型参数，无返回值。signal的返回值是一个函数地址，该函数有一个整型参数(即 最后的(int))。用自然语言来描述也就是要向信号处理程序传送一个整型参数，而它却无返 回值。当调用signal设置信号处理程序时，第二个参数是指向该函数(也就是信号处理程序) 的指针。signal的返回值则是指向之前的信号处理程序的指针。
很多系统用附加的依赖于实现的参数来调用信号处理程序。10 14节将对此作进一步说明，
本节开头所示的signal函数原型太复杂了，如果使用下面的typedef[Plauger 1992],则 可使其简单一些。
typedef void Sigfunc(int);
然后，可将signal函数原型写成
Sigfunc *signal(int, Sigfunc *)；
我们已将此typedef包括在apue.h文件中(见附录B)，并随本章中的函数一起使用。
如果査看系统的头文件<5191^1 .h>，则很可能会找到下列形式的声明：
#define SIG—ERR (void (*)())-1 #define SIG_DFL (void (*)())0 #define SIG—IGN (void (*)())1
这些常量可用于代替“指向函数的指针，该函数需要一个整型参数，而且无返回值”。signal 的第二个参数及其返回值就可用它们表示。这些常量所使用的三个值不一定是-1，0和1。它们 必须是三个值而决不能是任一可声明函数的地址。大多数UNIX系统使用上面所示的值。
实例
程序清单10-1显示了一个简单的信号处理程序，它捕捉两个用户定义的信号并打印信号编 号。10.10节将说明pause函数，它使调用进程在接到一个信号前挂起。
程序清单10-1捕捉SIGUSR1和SIGUSR2的简单程序
#include "apue.h"
static void sig一 usr(int)? /* one handler for both signals */ int
main (void)
{
if (signal(SIGUSR1, sig一usr) == SIG_ERR) err_sys (11 can# t catch SIGUSR1")； if (signal(SIGUSR2, sigusr) == SIGERR) err_sys("can/t catch SIGUSR2")； for (;;) pause()；
}
static void
sig_usr(int signo)	/* argument is signal number */
{'
if (signo == SIGUSR1)
printf("received SIGUSRl\n"); else if (signo == SIGUSR2)
printf("received SIGUSR2\n")；
else

 
242 第10幸佶 号
err一dump(ureceived signal %d\nH, signo)；
我们在后台调用该程序，并且用ki 11(1)命令将信号传送给它。注意，在UNIX中，杀死 (kill)这个术语是不恰当的。kill(l)命令和kill(2)函数只是将一个信号送给一个进程或进程 组。信号是否终止进程则取决于信号的类型，以及进程是否安排了捕捉该信号。
$ ./a.out &	在后台启动进程
[1] 7216	作业控制shell打印作业号和进程
$ kill -USR1 7216	向该进程发送SIGUSR1
received SIGUSR1	
$ kill -USR2 7216	向该进程发送SIGUSR2
received SIGUSR2	
$ kill 7216	向该进程发送SIGTERM
[1]+ Terminated	./a.out
因为执行程序清单10-1的进程不捕捉SIGTERM信号，而针对该信号的系统默认动作是终止， 所以当向该进程发送SIGTERM信号后，该进程就会终止。	口
1.	程序启动
当执行一个程序时，所有信号的状态都是系统默认或忽略。通常所有信号都被设置为它们 的默认动作，除非调用exec的进程忽略该信号。确切地讲，exec函数将原先设置为要捕捉的 信号都更改为它们的默认动作，其他信号的状态则不变(对于一个进程原先要捕捉的信号，当 其执行一个新程序后，就自然不能再捕捉它了，因为信号捕捉函数的地址很可能在所执行的新 程序文件中已无意义)。
一个具体例子是一个交互式shell如何处理针对后台进程的中断和退出信号。对于一个非作 业控制shell,当在后台执行一个进程时，例如：
cc main.c &
shell自动将后台进程对中断和退出信号的处理方式设置为忽略。于是，当按中断键时就不会影 响到后台进程。如果没有执行这样的处理，那么当按中断键时，它不但会终止前台进程，还会 终止所有后台进程。
很多捕捉这两个信号的交互式程序具有下列形式的代码：
void sig一int(int), sig一quit(int)；
if (signal(SIGINT, SIG_IGN) != SIG—IGN) signal{SIGINT, sig—int); if (signal(SIGQUIT, SIG_IGN) != SIG_IGN) signal(SIGQUIT, sig一quit);
这样处理后，仅当信号当前未被忽略时，进程才会捕捉它们。
从signal的这两个调用中也可以看到这种函数的限制：不改变信号的处理方式就不能确 定信号的当前处理方式。我们将在本章的稍后部分说明使用sigaction函数可以确定一个信 号的处理方式，而无需改变它。
2.	进程创建
当一个进程调用fork时，其子进程继承父进程的信号处理方式。因为子进程在开始时复 制了父进程的存储映像，所以信号捕捉函数的地址在子进程中是有意义的。
10.4不可靠的信号
在早期的UNIX版本(例如V7)中，信号是不可靠的。不可靠在这里指的是，信号可能会

 
10.4不可靠的信号 243
丢失：一个信号发生了，但进程却可能一直不知道这一点。同时，进程对信号的控制能力也很 差，它能捕捉信号或忽略它。有时用户希望通知内核阻塞一个信号：不要忽略该信号，在其发 生时记住它，然后在进程做好准备时再通知它。这种阻塞信号的能力当时并不具备。
4.2BSD对信号机制进杆了更改，提供了祓称为可靠信号的机制。然后，SVR3也修改了信号机制， 提供了另一套系统V可靠信号机制。POSIX.1选择了 BSD模型作为其标准化的基础。
早期版本中的一个问题是在进程每次接到信号对其进行处理时，随即将该信号动作复位为 默认值(在前面运行程序清单10-1时，我们只捕捉每种信号一次，从而回避了这一点)。在描 述这些早期系统的编程书籍中，有-个经典实例，它与如何处理中断信号相关，其代码与下面 所示的相似：
int sig_int () ；	/* tny signal handling function */
signal(SIGINT, sig_int)； /* establish handler */ sig 一int()
{ _
signal(SIGINT, sig_int)； /* reestablish handler for next time */
...	/* process the signal . . */
}
(由于早期的c语言版本不支持ISO C的void数据类型，所以将信号处理程序声明为int类型。) 这段代码的一个问题是：从信号发生之后到在信号处理程序中调用signal函数之前这段 时间中有一个时间窗口。在此段时间中，可能发生另一次中断信号。第二个信号会导致执行默 认动作，而针对中断信号的默认动作是终止该进程。这种类型的程序段在大多数情况下会正常 工作，使得我们认为它们是正确无误的，而实际上并非如此。
这些早期系统的另一个问题是：在进程$希望某种信号发生时，它不能关闭该信号。进程 能做的一切就是忽略该信号。有时希望通知系统“阻止下列信号发生，如果它们确实产生了， 请记住它们。”能够显现这种缺陷的一个经典实例是下列程序段，它捕捉一个信号，然后设置 一个表示该信号已发生的标志：
int sig_int—flag;	/* set nonzero when signal occurs */
main()
(
int sig_int()；	/*
signal(SIGINT, sig_int)； /*
my signal handling function */ establish handler */
while (sig_int_flag =- 0)
pause(>；	/* go to sleep, waiting for signal */
}
sig_int()
{
signal(SIGINT, sig_int)； /*
sig_int_flag =1;	/*
} " ~
reestablish handler for next time */ set flag for main loop to examine */
其中，进程调用pause函数使自己休眠，直至捕捉到一个信号。当捕捉到信号时，信号处理程

 
244 第10章信 号
序将标志sig一int一flag设置为非0值。从信号处理程序返回后，内核自动将该进程唤醒，它 检测到该标志为非0，然后执行它所需做的工作。但是这里也有一个时间窗口，在此窗口中操 作可能失误。如果在测试sig一int_flag之后和调用pause之前发生信号，则此进程在调用 pause时人睡，并且长眠不醒(假定此信号不会再次产生)。于是，这次发生的信号也就丢失 了。这是另一个例子，某段代码并不正确，但是大多数时间却能正常工作。要查找并排除这种 类型的问题很困难。
10.5中断的系统调用
早期UNIX系统的一个特性是：如果进程在执行一个低速系统调用而阻塞期间捕捉到一个 信号，则该系统调用就被中断不再继续执行。该系统调用返回出错，其errno被设置为EINTR。 这样处理的理由是：因为一个信号发生了，进程捕捉到了它，这意味着已经发生了某种事情， 所以是个应当唤醒阻塞的系统调用的好机会。
在这里，我们必须区分系统调用和函数。当捕极到某个信号时，被中断的是内核中执行的系统调用。
为了支持这种特性，将系统调用分成两类：低速系统调用和其他系统调用。低速系统调用 是可能会使进程永远阻塞的一类系统调用，它们包括：
•在读某些类型的文件(管道.终端设备以及网络设备)时，如果数据并不存在则可能会 使调用者永远阻塞。
•在写这些类型的文件时，如果不能立即接受这些数据，则也可能会使调用者永远阻塞。
•打开某些类型文件，在某种条件发生之前也可能会使调用者阻塞(例如，打开终端设备， 它要等待直到所连接的调制解调器应答了电话)。
•Pause (按照定义，它使调用进程休眠直至捕捉到一个信号)和wait函数。
•某些ioctl操作。
•某些进程间通信函数(见第15章)。
在这些低速系统调用中，一个值得注意的例外是与磁盘I/O有关的系统调用。虽然读、写一个磁 盘文件可能暂时阻塞调用者(在磁盘驱动器将请求排入队列，然后在适当时间执行请求期间)， 但是除非发生硬件错误，I/O操作总会很快返回，并使调用者不再处于阻塞状态。
可以用中断系统调用这种方法来处理的一个例子是：一个进程启动了读终端操作，而使用 该终端设备的用户却离开该终端很长时间。在这种情况下进程可能处于阻塞状态几个小时甚至 数天，除非系统停机，否则一直如此。
对于中断的read、write系统调用，POSIX.1的语义在该标准的2001版有所改变。对于如何处理 已read、write部分数据f的相应系统调用，早期版本允许实现进行选择。如若read系统调用已接收 并传送数据至应用程序缓冲区’但尚未接收到应用程序请求的全部数据，此时祓中断' 操作系统可以 认为该系统调用失败’并将errno设置为EINTR;另一种处理方式是允许该系统调用成功返回，返回已 接收到的部分教掘f。与此类似’如若write已传输了应用程序緩冲区中的部分数搞，然后被中断’ 操作系统可以认为该系统调用失败，并将errno设置为EINTR;另一种处理方式是允许该系统调用成功 返回’返回已写的部分数掘量。历史上’从系统V派生的实现，将这种系统调用视为失败，而BSD派生 的实现则处理为部分成功返回。P0SIX.1标准的2001版采用BSD风格的语义。
与被中断的系统调用相关的问题是必须显式地处理出错返回。典型的代码序列(假定进行

 
10.5中断的系统调用 245
一个读操作，它被中断，我们希望重新启动它)可能如下所示：
again：
if ((n = read(fd, buf, BUFFSIZE)) < 0) { if (errno -= EINTR)
goto again；	/* just an interrupted system call */
/* handle other errors */
}
为了帮助应用程序使其不必处理被中断的系统调用，4.2BSD引人了某些被中断系统调用的 自动重启动。自动重启动的系统调用包括ioctl、read、readv、write、writev、wait和 waitpid。正如前述，其中前5个函数只有对低速设备进行操作时才会被信号中断。而wait和 waitpid在捕捉到信号时总是被中断。因为这种自动重启动的处理方式也会带来问题，所以某 些应用程序并不希望这些函数被中断后重启动。为此4.3BSD允许进程基于每个信号禁用此功能。
POSIX.1允许实现重启动系统调用，但.这并不是必需的。Single UNIX Specification将SA_RESTART 定义为对sigaction的XS丨扩展，以允许应用程序要求重启动被中断的系统调用。
系统V的默认工作方式是从不重启动系统调用，而BSD则重启动被信号中断的系统调用。FreeBSD 5.2.1、Linux 2.4.22和Mac OS X 10.3的默认方式是重启动由信号中断的系统调用Solaris 9的默认方式 是出错返回，并将errno设置为EINTR。
4.2BSD引入自动重启动功能的一个理由萆：有时用户并不知道所使用的输人、输出设备是 否是低速设备。如果我们编写的程序可以用交互方式运行，则它可能读、写低速终端设备。如 果在程序中捕捉信号，而且系统并不提供重启动功能，则对每次读、写系统调用都要进行是否 出错返回的测试，如果是被中断的，则再调用读、写系统调用。
表10-2列出了几种实现所提供的与信号有关的函数及其语义。
表10-2几种信号实现所提供的功能
函 数	系统	保持安装信号	阻塞信号	被中断的系统调
		处理程序	的能力	用自动重启动？
	ISOC, POSIX.I	未说明	未说明	未说明
signal	V7、SVR2、SVR3、SVR4、Solaris			决不
	4.2BSD			总是
	4.3BSD、4.4BSD, FreeBSD、Linux、Mac OS X			默认
sigset	XSI			未说明
	SVR3、SVR4、Linux、Solaris			决不
sigvec	4.2BSD			总是
	4.3BSD、4.4BSD、FreeBSD, Mac OS X			默认
	POSIX.1			未说明
sigaction	XSI、4 4BSD、SVR4. FreeBSD% Mac OS X、 Linux、Solans			可选
我们没有讨论旧的sigset和sigvec函数。它们已由sigaction函数替代；仅仅为了完整性我们 才将这两个函数包含在表10-2中。与之对照，某些实现将signal函数提升为sigaction的简化接口

 
246 第10章信 号
应当了解，其他厂商提供的UNIX系统可能不同于表10-2中所示的情况。例如，SunOS 4.1.2 中的sigaction的默认方式是重启动被中断的系统调用，这与表10-2中所列的各平台不同。
在程序清单10-12中，提供了我们自己的signal函数版本，它自动地试图重启动被中断的 系统调用(除SIGALRM信号外)。在程序清单10-13中则提供了另一个函数signal_intr,它 从不尝试进行重肩动。
14.5节说明select和poll函数时还将涉及被中断的系统调用的更多知识。
10.6可重入函数
进程捕捉到信号并对其进行处理时，进程正在执行的指令序列就被信号处理程序临时中断， 它首先执行该信号处理程序中的指令。如果从信号处理程序返回(例如没有调用exit或 longjmp),则继续执行在捕捉到信号时进程正在执行的正常指令序列(这类似于发生硬件中 断时所做的)。但在信号处理程序中，不能判断捕捉到信号时进程在何处执行。如果进程正在 H2I]执行malloc,在其堆中分配另外的存储空间，而此时由于捕捉到信号而插入执行该信号处理 程序，其中又调用malloc,这时会发生什么？又例如若进程正在执行getpvmam (见6.2节) 这种将其结果存放在静态存储单元中的函数，其间插入执行信号处理程序，它又调用这样的函 数，这时又会发生什么呢？在malloc例子中，可能会对进程造成破坏，因为malloc通常为它 所分配的存储区维护一个链接表，而插入执行信号处理程序时，进程可能正在更改此链接表。 在getpwnam的例子中，返回给正常调用者的信息可能被返回给信号处理程序的信息覆盖。 Single UNIX Specification说明了保证可重入的函数。表10-3列出了这些可重入函数。
表10-3倍号处理程序可以调用的可重入函数
accept	fchmod ^	lseek	sendto	stat
access	fchown	lstat	setgid	symlink
aio—error	fcntl	mkdir	setpgid	sysconf
aio_return	fdatasync	mkfifo	setsid	tcdrain
aio—suspend	fork	open	setsockopt	tcflow
alarm	fpathconf	pathconf	setuid	tcflush
bind	fstat	pause	shutdown	tcgetattr
cfgetispeed	f sync	pipe	sigaction	tcgetpgrp
cfgetospeed	ftruncate	poll	sigaddset	tcsendbreak
cfsetispeed	getegid	posix一trace—event	sigdelset	tcsetattr
cfsetospeed	geteuid	pselect	sigemptyset	tcsetpgrp
chdir	getgid	raise	sigfillset	time
chmod	getgroups	read	sigismember	timer_getoverrun
chown	getpeername	readlink	signal	timer_gettime
clock_gettime	getpgrp	recv	sigpause	timer__settime
close	getpid	recvfrom	sigpending	times
connect	getppid	recvmsg	sigprocmask	umask
creat	getsockname	rename	siggueue	uname
dup	getsockopt	rmdir	sigset	unlink
dup2	getuid	select	sigsuspend	utime
execle	kill	sem一post	sleep	wait
execve	link	send	socket	waitpid
_Exit&_exit	listen	sendmsg	socketpair	write

 
10.6可重入函数 247
没有列入表10-3中的大多数函数是不可重入的，其原因为：(a)已知它们使用静态数据结 构，(b)它们调用malloc或free,或(c)它们是标准I/O函数。标准I/O库的很多实现都以不可 重入方式使用全局数据结构。注意，即使在本书的某些实例中，信号处理程序也调用了 printf函数，但这并不保证产生所期望的结果，信号处理程序可能中断主程序中的printf 函数调用。
应当了解即使信号处理程序调用的是列于表10-3中的函数，但是由于每个线程只有一个 errno变量(回忆1.7节对errno和线程的讨论)，所以信号处理程序可能会修改其原先值.考 虑一个信号处理程序，它恰好在main刚刚设置errno之后被调用。例如，如果该信号处理程 序调用read这类函数，则它可能更改errno的值，从而取代了刚刚由main设置的值。因此，
作为一个通用的规则，当在信号处理程序中调用表10-3中列出的函数时，应当在其前保存，在 其后恢复errno。(应当了解，经常被捕捉到的信号是SIGCHLD,其信号处理程序通常要调用_ 一种wait函数，而各种wait函数都能改变errno。)
注意，表10-3没有包括longjmp (7.10节)和siglongjmp (10.15节)。这是因为主例程 以非可重入方式正在更新数据结构时可能产生信号。如果不是从信号处理程序返回而是调用 siglongjmp,那么该数据结构可能是部分更新的。如果应用程序将要做更新全局数据结构这 样的事情，同时要捕捉某些信号，而这些信号的处理程序又会引起执行sigsetjmp,则在更 新这种数据结构时要阻塞此类信号。
 
在程序清单10-2中，信号处理程序my_alarm调用不可重人函数getpwnam,而 my_alarm每秒钟被调用一次。10.10节中将说明alarm函数。在该程序中调用alarm函数使得 每秒产生一次SIGALRM信号。
	程序清单10-2在倍号处理程序中调用不可重入函数	
#include "apue.h"
#include <pwd.h>
static void
my一alarm(int signo)
{ _
struct passwd *rootptr;
printf("in signal handler\nM)； if ((rootptr = getpwnam("root")) == NULL) err_sys("getpwnam(root) error")； alarm (1) ••
main(void)
{
struct passwd *ptr；
signal(SIGALRM, my 一alarm)； alarm(l)； for ( ; / ) {
if ( (ptr = getpwnam(11 sar11)) == NULL) err一sys (11 getpwnam error"); if (strcmp(ptr->pw_name, ”sar") != 0)
printf ( "return value corruptedi, pw一name = %s\n,t,

 
248 第10章信 号
ptr->pw_name)；
运行该程序时，其结果具有随意性。通常，在信号处理程序经多次迭代返回时，该程序将 由SIGSEGV信号终止。检査core文件，从中可以看到main函数已调用getpwnam,而且当信 _号处理程序调用此同一函数时，某些内部指针出了问题。偶然，此程序会运行若干秒，然后因 产生SIGSEGV信号而终止。在捕捉到信号后，若main函数仍正确运行，其返回值却有时错误， 有时正确。有一次在Mac OS X上运行该程序时曾经打印出来自maiioc库例程的警告信息，声 称正释放的指针是未经malloc分配的。
从此实例中可以看出，若在信号处理程序中调用一个不可重人函数，则其结果是不可预 见的。	□
10.7	SIGCLD 语义
SIGCLD和SIGCHLD这两个信号很窨易被混淆。SIGCLD (没有H)是系统V的一个信号名， 其语义与名为SIGCHLD的BSD信号不同。POSIX.1则采用BSD的SIGCHLD信号。
BSD的SIGCHLD信号语义与其他信号的语义相类似。子进程状态改变后产生此信号，父进 程需要调用一个wait函数以确定发生了什么。
由于历史原因，系统V处理SIGCLD信号的方式不同于其他信号。如果用signal或 sigset (早期设置信号配置的与SRV3兼容的函数)设置信号配置，则基于SVR4的系统继续 了这一具有问题色彩的传统(即兼容性限制)。对于SIGCLD的早期处理方式如下：
(1)	如果进程特地设置该信号的配置为SIG_IGN，则调用进程的子进程将不产生僵死进程。 注意’这与其默认动作(SIG一DFL) “忽略”(见图10-1)不同。代之以在子进程终止时，将其 状态丢弃。如果调用进程随后调用一个wait函数，那么它将阻塞到所有子进程都终止，然后 该wait会返回-1，并将其errn◦设置为ECHILD (此信号的默认配置是忽略，但这不会造成上 述语义起作用。代之以我们必须特地指定其配置为SIG_IGN)。
POSIX. 1并未说明在SIGCHLD被忽略时应产生的后果，所以这种运行行为是允许的。Single UNIX Specification包括了一个XSI扩展，它规定对于SIGCHLD支持这种运行行为。
如果SIGCHLD被忽略，4.4BSD总是产生僵死子进程。如果要避免僵死子进程，则必须等待子进程。 FreeBSD 5.2.丨对此的处理方式与4.4BSD相同，但是，Mac OS X 10.3在SIGCHLD被忽略时，并不创建僅 死子进程。
在SVR4中，如果调用signal或sigset将SIGCHLD的配置设置为忽略，则决不会产生僅死子进程。 Linux 2.4.22和Solaris 9在此方面追随SVR4。
使用sigaction可设置SA—NOCLDWAIT标志(见表10-5)以避免子进程僅死。本书讨论的四种平 don 台都支持这一动作。
(2)	如果将SIGCLD的配置设置为捕捉，则内核立即检査是否有子进程准备好被等待，如果 是这样，则调用SIGCLD处理程序。
第(2)项改变了为此信号编写处理程序的方法。这一点可在下面的实例中看到。
I实例
10.4节曾提到进人信号处理程序后，首先要调用signal函数以重新设置此信号处理程序

 
10.7 SIGCLD 语义 249
(在信号被复位回其默认值时，它可能被丢失，立即重新设置可以减少此窗口时间)。程序清单 10-3显示了这一点。但此程序不能在某些平台上正常工作。如果在传统的系统V平台(例如 OpenServer 5或UnixWare 7)上编译并运行此程序，则其输出是一行行地不断重复“SIGCLD received”。最后进程用完其栈空间并异常终止。
程序清单10-3不能正常工作的系统V SIGCLD处理程序
#include 社include
"apue.h11 <sys/wait.h>
static void sig_cld{int)‘
int main()
pid_t pid；
if (signal(SIGCLD, sig_cld) == SIG_ERR) perror("signal error")； if ((pid = fork()) < 0) { perror("fork error")；
} else if (pid == 0) {	/* child */
sleep(2)； exit(0)；
pause(); exit(0)；
/* parent */
static void
sig_cld(int signo) /* interrupts pause() */
pid_t
pid;
status；
printf("SIGCLD received\n")； if (signal(SIGCLD, sig_cld)== perror("signal error11); if ((pid = wait(&status)) < 0) perror("wait error")； printf("pid = %d\n", pid)；
SIG_ERR) /* reestablish handler */ /* fetch child status */
因为基于BSD的系统通常并不支持早期系统V SIGCLD的语义，所以FreeBSD 5.2.丨和Mac OS X 10.3并没有出现此问题D Linux 2.4.22也没有出现此问题，其原因是，虽然SIGCLD和SIGCHLD定义为同 一值，但当一进程安排捕捉SIGCHLD,并且已经有进程准备好由其父进程等待时，该系统并不调用 SIGCHLD信号的处理程序。另一方面，Solaris 9在此种情况确实调用该信号处理程序，但在内核中增加 了避免此问题的代码。
S然本书说明的所有四种平台都解决了这一问题，但是应当理解没有解决这一问题的平台(例如 UnixWare)依然存在6
此程序的问题是：在信号处理程序的开始处调用signal，按照上述第2项，内核检査是否 有需要等待的子进程(因为我们正在处理一个SIGCLD，所以确实有这种子进程)，所以它产生 另一个对信号处理程序的调用。信号处理程序调用signal，整个过程再次重复。
为了解决这一问题，应当在调用wait取到子进程的终止状态后再调用signal。此时仅当 其他子进程终止时，内核才会再次产生此种信号。

 
250 第10章信 号
如果为SIGCHLD建立了 一个信号处理程序.又存在一个已终止但父进程尚未等待它的进程，则是 否会产生信号？ POSIX.丨对此没有作说明。这样就允许前面所述的工作方式。但是，POSIX.1在信号发 生时并没有将信号配叉复位为其默认值(级定正调用POSIX.丨的sigaction函数设置其纪置)，于是在 SIGCHLD处理程序中也就不必再为该信号建立一个信号处理程序。	□
务必了解你所用的系统中SIGCHLD信号的语义。也应了解在某些系统*#de fine SIGCHLD为SIGCLD或反之。更改这种信号的名字使你可以编译为另一个系统编写的程序，但 是如果这一程序使用该信号的另一种语义，则这样的程序也不能工作。
在本书说明的四种平台上，SIGCLD等价于SIGCHLD。
10.8可靠信号术语和语义
我们需要先定义一些在讨论信号时会用到的术语。首先，当引发信号的事件发生时，为进 程产生一个信号(或向进程发送一个信号)。事件可以是硬件异常(例如，除以0)、软件条件 (例如，alarm计时器超时)、终端产生的信号或调用kill函数。在产生了信号时，内核通常 在进程表中设置一个某种形式的标志。
当对信号采取了这种动作时，我们说向进程递送了一个信号。在信号产生(generation)和 递送(delivery)之间的时间间隔内，称信号是未决的(pending)。
_ 进程可以选用信号递送阻塞。如果为进程产生了一个选择为阻塞的信号，而且对该信号的 动作是系统默认动作或捕捉该信号，则为该进程将此信号保持为未决状态，直到该进程(a)对 此信号解除了阻塞，或者(b)将对此信号的动作更改为忽略。内核在递送一个原来被阻塞的信 号给进程时(而不是在产生该信号时)，才决定对它的处理方式。于是进程在信号递送给它之 前仍可改变对该信号的动作。进程调用sigpending函数(见10.13节)来判定哪些信号是设置 为阻塞并处于未决状态的。
如果在进程解除对某个信号的阻塞之前，这种信号发生了多次，那么将如何呢？ P0SIX.1允 许系统递送该信号一次或多次。如果递送该信号多次，则称对这些信号进行了排队。但是除非支 持P0SDU实时扩展，否则大多数UNIX并不对信号排队。代之以UNIX内核只递送这种信号一次。
SVR2的手册页称，在进程执行S1GCLD信号处理程序期间，该信号是用排队方式处理的，虽然在 悛念层次上这可能是真的，但实际并非如此。代之以，内核按10.7节中所述方式产生此信号。SVR3的 手册页对此做了修改，它指明在进程执行SIGCLD信号处理程序期间，忽略SIGCLD信号，SVR4手册豇 删除了有关部分，也就是说，在进程执行SIGCLD信号处理程序期间，如若又产生了 SIGCLD信号，
S VR4手册页对此未作任何说明。
AT&T[1990e]中的SVR4 sigaction(2)手册页称SA_SIGINF0标志(见图10-16)使信号可靠地排 队，这也不正确。表面上内核部分地实现了此功能，但在SVR4中并不起作用。令人不可思议的是， SVID对这种可靠排队列并未作同样的声明。
如果有多个信号要递送给一个进程，那么将如何呢？ P0SIX.1并没有规定这些信号的递送 顺序。但是P0SIX.1的Rationale建议：在其他信号之前递送与进程当前状态有关的信号，例如 SIGSEGV。
每个进程都有一个信号屏蔽字(signal mask),它规定了当前要阻塞递送到该进程的信号集。 对于每种可能的信号，该屏蔽字中都有一位与之对应。对于某种信号，若其对应位已设置，则

 
10.9 kill和raise函数 251
它当前是被阻塞的。进程可以调用sigprocmask (在10.12节中说明)来检测和更改其当前信 号屏蔽字。
信号数量可能会超过整型所包含的二进制位数，因此POSIX.1定义了一个新数据类型 sigset_t,用于保存一个信号集。例如，信号屏蔽字就存放在这些信号集的一个中。10.11节 将说明对信号集进行操作的5个函数。
10.9	kill和raise函数
kill函数将信号发送给进程或进程组。raise函数则允许进程向自身发送信号。
raise原来是由丨SO C定义的。后来，为了与ISO C标准保持一致，POSIX. 1也包括了该函数。但 是P0SDU扩展Traise的规范，使其可处理线程(128节中讨论线程如何与信号交互)。因为ISO C并不 涉及多进程，所以它不能定义如kill这样要有一个进程ID作为其参数的函数。
#include <signal.h>
int kill (pid一t pid, int signo)；
int raise (int signo)；	两个函数返回值：若成功则返回0，若出错则返回-1
调用	
raise(signo)；	
等价于调用	
kill(getpid(), signo)；	
kill的pW参数有4种不同的情况：	
pid > 0 将该信号发送给进程ID为pid的进程。
pid==0 将该信号发送给与发送进程属于同一进程组的所有进程(这些进程的进程组ID 等于发送进程的进程组丨D)，而且发送进程具有向这些进程发送信号的权限。 注意，这里用的术语“所有进程”不包括实现定义的系统进程集。对于大多数 UNIX系统，系统进程集包括内核进程以及init (pid 1)。
Pid<0 将该信号发送给其进程组ID等于的绝对值，而且发送进程具有向其发送信号 的权限。如上所述，“所有进程集”并不包括某些系统进程。 pid=~\将该信号发送给发送进程有权限向它们发送信号的系统上的所有进程。如上所 述，“进程集”不包括某些系统进程。
上面曾提及，进程将信号发送给其他进程需要权限。超级用户可将信号发送给任一进程。 对于非超级用户，其基本规则是发送者的实际或有效用户ID必须等于接收者的实际或有效用户 ID。如果实现支持_POSIX_SAVED_IDS (如POSIX.1现在要求的那样)，则检査接收者的保存 的设置用户ID (而不是其有效用户ID)。在对权限进行测试时也有一个特例：如果被发送的信 号是SIGC0NT，则进程可将它发送给属于同一会话的任何其他进程。
P0SIX.1将编号为0的信号定义为空信号。如果处参数是0，则kill仍执行正常的错误检 査，但不发送信号。这常被用来确定一个特定进程是否仍旧存在。如果向一个并不存在的进程 发送空信号，则kill返回-1,并将errno设置为ESRCH。但是，应当了解，UNIX系统在经过 一段时间后会重新使用进程ID,所以一个现有的具有所给定进程ID的进程并不一定就是你想要

 
252 第10章信 号
的进程。
还应理解的是，对于进程是否存在的这种测试不是原子操作。在kill向调用者返回测试 _结果时，原来存在的被测试进程此时可能已经终止，所以这种测试并无多大价值。
如果调用kill为调用进程产生信号，而且此信号是不被阻塞的，那么在kill返回之前， 就会将《如0或者某个其他未决的非阻塞信号传送至该进程。(对于线程而言，还有一些附加条 件《详细情况见12.8节。)
10.10	alarm和pause函数
使用alarm函数可以设置一个计时器，在将来某个指定的时间该计时器会超时。当计时器 超时时，产生SIGALRM信号。如果不忽略或不捕捉此信号，则其默认动作是终止调用该alarm 函数的进程。
#include <unistd.h>	
unsigned int alarm (unsigned int seconds)；	
	返回值：o或以前设置的闹钟时间的余留秒数
其中，参数•yeco/wls的值是秒数，经过了指定的■secomfc秒后会产生信号SIGALRM。要了解 的是，经过了指定的秒数后，信号由内核产生，由于进程调度的延迟，所以进程得到控制从而 能够处理该信号还需一些时间。
早期的UNIX系统买现霄提出警告■这种信号可能比预定值提前1秒发送。POSIX.I则不允许这样做。
每个进程只能有一个闹钟时钟。如果在调用alarm时，以前已为该进程设置过闹钟时钟， 而且它还没有超时，则将该闹钟时钟的余留值作为本次alarm函数调用的值返回。以前登记的 闹钟时钟则被新值代替。
如果有以前为进程登记的尚未超过的闹钟时钟，而且本次调用的secom/s值是0,则取消以 前的闹钟时钟，其余留值仍作为alarm函数的返回值。
虽然SIGALRM的默认动作是终止进程，但是大多数使用闹钟的进程会捕捉此信号。如果此 时进程要终止，则在终止之前它可以执行所需的清理操作。如果我们想捕捉SIGALRM信号，则 必须在调用alarm之前设置该信号的处理程序。如果我们先调用alarm,然后在我们能够设置 SIGALRM处理程序之前已接收到该信号，那么进程将终止。
pause函数使调用进程挂起直至捕捉到一个信号。
#include <unistd.h>	
int pause(void)；	返回值：-1，并将errno设置为EINTR
只有执行了一个信号处理程序并从其返回时，pause才返回。在这种情况下，pause返 岡回—1，并将errno设置为EINTR。
实例
使用alarm和pause,进程可使自己休眠一段指定的时间。程序清单10-4中的sleepl函

 
10.10 alarm和pause函數 253
数提供这种功能(但是它有一些问题，我们很快就会看到)。
	程序清单10-4 sleep的简单而不完整的实现
#include <signal.h>
#include <unistd.h>
static void
sig_alrm(int signo)
{ _
/* nothing to do, just return to wake up the pause */
}
unsigned int
sleepl(unsigned int nsecs)
{
if (signal(SIGALRM
return(nsecs)；
alarm(nsecs)；
pause()?
return(alarm(0));
程序中的sleepl函数看起来与将在10.19节中说明的sleep函数类似，但这种简单实现有 下列三个问题：
(1)如果在调用sleepl之前，调用者已设置了闹钟，则它会被sleepl函数中的第一次 alarm调用擦除。可用下列方法更正这一点：检查第一次调用alarm的返回值，如其小于本次调 用alarm的参数值，则只应等到上次设置的闹钟超时。如果上次设置闹钟的超时时间晚于本次设 置值，则在sleepl函数返回之前，复位此闹钟，使其在上次闹钟的设定时间再次发生超时。
⑵该程序中修改了对SIGALRM的配置。如果编写了一个函数供其他函数调用，则在该函 数被调用时先要保存原配置，在该函数返回前再恢复原配置。更正这一点的方法是：保存 signal函数的返回值，在返回前复位原配置。
(3)	在第一次调用alarm和调用pause之间有一个竞争条件。在一个繁忙的系统中，可能 alarm在调用pause之前超时，并调用了信号处理程序。如果发生这种情况，则在调用pause 后，如果没有捕捉到其他信号，则调用者将永远被挂起。
sleep的早期实现与程序清单10-4类似，但更正了问题(1)和(2)。有两种方法可以更正问题
(3)。第一种方法是使用setjrup,下一个实例将说明这种方法。另一种方法是使用 sigprocmask 和 sigsuspend, 10.19 节将说明这种方法。	□
纖 <•'
SVR2中的sleep实现使用了setjmp和longjmp (见7.10节)，以避免前一个实例问题(3) 中所说明的竞争条件。此函数的一个简单版本称为sleeP2,示于程序清单10-5中(为了缩短 实例长度，程序中没有处理上面所说的问题(1)和(2))。
	程序清单10-5 sleep的另一个(不完善)实现	
#include <setjmp.h>
#include <signal.h>
#include <unistd.h>
static jmpbuf env_alrm；
,sig__alrm) == SIG一ERR)
/* start the timer */
/* next caught signal wakes us up */
/* turn off timer, return unslept time */

 
254 第10章信 号
static void sig_alrm(int signo)
{ 一
1ongj mp(env_a1rm, 1);
} _ unsigned int
sleep2(unsigned int nsecs)
{
if (signal(SIGALRM, sig_alrm) == SIG一ERR) return(nsecs)； if (setjmp(env_alrm) == 0) {
alarm(nsecs)；	/* start the timer */
I pause();	/* next caught signal wakes us up */
return(alarm(0));	/* turn off timer, return unslept time */
在此函数中，程序清单10-4具有的竞争条件已被避免。即使pquse从未执行，在发生 SIGALRM时，sleep2函数也会返回。 但是，sleep2函数中却有另一个难以察觉的问题，它涉及与其他信号的交互。如果 SIGALRM中断了某个其他信号处理程序，则调用longjmp会提早终止该信号处理程序。程序 清单10-6显示了这种情况。SIGINT处理程序中包含了for循环语句，它在作者所用系统上的执 行时间超过5秒钟，也就是大于sleep2的参数值，这正是我们想要的。将整型变量k声明为 volatile, 这样就阻止了优化编译器丢弃循环语句。执行程序清单10-6得到：
$ ./».out
"7	我们键入中断字符
sig 一int starting sleep2 returned： 0
从中可见sleep2函数所引起的longjmp使另一个信号处理程序sig_int提早终止，即使它未 完成也会如此。如果将SVR2的sleep函数与其他信号处理程序一起使用，就可能碰到这种情 况。见习题10.3。	口
	程序清单10-6在一个捕捉其他信号的程序中调用Sleep2	
#include "apue-h"
unsigned int sleep2(unsigned int)； static void sig_int(int)；
int
main (void)
{
unsigned int unslept；
if (signal(SIGINT, sig—int) := SIG一ERR) err__sys ( nsignal (SIGINT) error")； unslept = sleep2(5);
printf("sleep2 returned： %u\nH, unslept)； exit(0)；
}
static void sig_int(int s igno) { 一 int	i, j ；

 
10.10 alarm和pause函數 255
volatile int k；
/*
*	Tune these loops to run for more than 5 seconds
*	on whatever system this test program is run.
*/
printf(n\nsig_int starting\n")； for (i = 0； i_< 300000; i++) for (j - 0; j < 4000; j++) k += i * j; printf("sig一int finished\n");
有关sleepl和sleep2函数的这两个实例的目的是告诉我们在涉及信号时需要有精细而周 到的考虑。下面几节将说明解决这些问题的方法，使我们能够可靠地、在不影响其他代码段的 情况下处理信号。
 
除了用来实现sleep函数外，alarm还常用于对可能阻塞的操作设置时间上限值。例如，程 序中有一个读低速设备的可能阻塞的操作(见10.5节)，我们希望超过一定时间量后就停止执行 该操作。程序清单1化7实现了这一点，它从标准输入读一行，然后将其写到标准输出上。
	程序清单10-7具有超时限制的read调用	
#include "apue.h"
static void sig一alrm(int);
int
main (void)
{
int n；
char line[MAXLINE];
if (signal (SIGALRM, sig一alrtn) == SIG_ERR) err—sys("signal(SIGALRM) error")；
alarm(10)；
if ((n = read(STDIN一FILENO, line, MAXLINE)) < 0) err一sys("read error")? alarm(0);
write(STD0UT_FILEN0# line, n); exit(0)；
}
static void sig_alrm(int signo)
{ 一
/* nothing to do, just return to interrupt the read */
这种代码序列在很多UNIX应用程序中都能见到，但是这种程序有两个问题：
(1)程序清单10-7具有与程序清单10-4相同的问题：在第一次alarm调用和read调用之间 有一个竞争条件。如果内核在这两个函数调用之间使进程阻塞，而其时间长度又超过闹钟时间， 则read可能永远阻塞。大多数这种类型的操作使用较长的闹钟时间，例如1分钟或更长一点,
[3161

 
256 第10章信 号
使这种问题不会发生，但无论如何这是一个竞争条件。
(2)	如果系统调用是自动重启动的，则当从SIGALRM信号处理程序返回时，read并不被中 断。在这种情形下，设置时间限制不起作用。
在这里我们确实需要中断低速系统调用。POSIX.1并未提供一种可移植的方法来实现这一 点，但是，Single UNIX Specification的XSI扩展却做到了这一点。我们将在10.14节对此进行详 细讨论。	□
 
让我们用longjmp重新实现前面的实例(见程序清单10-8)。使用这种方法则无需担心一 个慢速的系统调用是否被中断。
	程序清单10-8使用longjnp,带超时限制调用read	
#	include 11 apue.h"
#include <setjmp.h>
static void sig_alrm(int)； static jmp_buf env_alrm；
int
main (void)
{
int n；
char line[MAXLINE]；
if (signal(SIGALRM, sig 一alrm) == SIG一ERR) err_sys("signal(SIGALRM) error")； if (setjmp(env_alrm) !« o)
err一quit("read timeout");
alarm(10)；
if ((n = re ad(STDIN_FILENO # line, MAXLINE)) < 0) err_sys("read error”)； alarm(0);
write(STDOUT—FILENO, line, n)； exit(0);
}
static void sig_alrm(int signo)
{ _
longjmp(env^alrm, 1)；
不管系统是否重新启动中断的系统调用，该程序都会如所预期的那样工作。但是要知道, 该程序仍旧有和程序清单10-5中相同的与其他信号处理程序交互的问题。	口
如果要对I/O操作设置时间限制，则如上所示可以使用longjmp,当然也要清楚它可能有 与其他信号处理程序交互的问题。另一种选择是使用select或poll函数，14.5.1节和14.5.2节 将对它们进行说明。
10.11信号集
我们需要有一个能表示多个信号——信号集(signal set)的数据类型。我们将在诸如

 
10.11信号集 257
sigprocmask (下一节中说明)之类的函数中使用这种数据类型，以便告诉内核不允许发生 该信号集中的信号。如前所述，信号种类数目可能超过一个整型量所包含的位数，所以一般而 言，不能用整型量中的一位代表一种信号，也就是不能用一个整型量表示信号集。P0SIX.1定 义了数据类型Sigset_t以包含一个信号集，并且定义了下列五个处理信号集的函数。
#include <signal.h>
int sigemptyset (sigset_t *set) ?
int sigfillset (sigset_t *set)；
int sigaddset (sigset_t *$et, int signo)；
int sigdelset (sigset_t *set, int signo);
四个函数的返回值：若成功则返回0，若出错则返回-1 int sigismember (const sigset_t *set, int signo);
返回值*.若真则返回1，若假则返回0，若出错则返回-1
函数sigemptyset初始化由如指向的信号集，清除其中所有信号。函数sigfillset初 始化由set指向的信号集，使其包括所有信号。所有应用程序在使用信号集前，要对该信号集调 用sigemptyset或sigfillset—次。这是因为C编译器将把未陚初值的外部和静态变量都 初始化为0,而这是否与给定系统上信号集的实现相对应却并不清楚。
一且已经初始化了一个信号集，以后就可在该信号集中增、删特定的信号。函数sigaddset 将一个信号添加到现有集中，sigdelset则从信号集中删除一个信号。对所有以信号集作为参数 的函数，我们总是以信号集地址作为向其传送的参数。
 
如果实现的信号数目少于一个整型量所包含的位数，则可用一位代表一个信号的方法实现 信号集。例如，在本书的后续部分，我们都假定一种实现有31种信号和32位整型量。 319611^匕丫86(:函数将整型量设置为0，sigfillset函数则将整型量中的各个位都设置为1。 这两个函数可以在<signal .h>头文件中实现为宏：
#define sigemptyset(ptr) (*(ptr) = 0)
#define sigfillset(ptr) (*(ptr) : ~(sigset一t)0, 0)
注意，除了设置信号集中各位为1外，sigfillset必须返回0,所以使用C语言的逗号运算符， 它将逗号运算符后的值作为表达式的值返回。
使用这种实现，sigaddset打开一位(将该位设置为1), sigdelset则关闭一位(将该 位设置为0), sigismember测试一指定位。因为没有编号为0的信号，所以从信号编号中减去 1以得到要处理位的位编号数。程序清单10-9实现了这些函数。
程序澝单 10-9 sigaddset、sigdelset和sigismember的实现
#include <signal,h>
#include <errno.h>
/* <signal.h> usually defines NSIG to include signal number 0 */
#define SIGBAD(signo) ((signo) <= 0 丨| (signo) >= NSIG)

 
258 第10章信 号
sigaddset(sigset_t *set# int signo)
{ 一
if (SIGBAD(signo)) { errno = EINVAL； return(-1)； }
*set |= 1 << (signo - 1);	/* turn bit on */
return(0);
int
sigdelset(sigset_t *set# int signo)
{ _
if (SIGBAD(signo)) { errno = EINVAL; return(-1)； }
★set &-〜(1 << (signo - 1)); /* turn bit off */ return(0)；
int
sigismember(const sigset一t *set, int signo)
{ _
if (SIGBAD(signo)) { errno = EINVAL； return(-1)； } return((*set & (1 << (signo - 1))) != 0);
也可将这三个函数在< Signal • h>中实现为单行宏，但是POSIX. 1要求检查信号编号参数 的有效性，如果无效则设置errno。在宏中实现这一点比在函数中要困难。
10.12	sigprocmask 函数
10.8	节曾提及一个进程的信号屏蔽字规定了当前阻塞而不能递送给该进程的信号集。调用 函数sigprocmask可以检测或更改其信号屏蔽字，或者在一个步骤中同时执行这两个操作。
#include <signal.h>
int sigprocmask (int how, const sigset_t *restrict set, sigset一t *restrict oset);
返回值：若成功则返回0，若出错则返回-1
首先，若wef是非空指针，那么进程的当前信号屏蔽字通过wef返回。 其次，若w是一个非空指针，则参数指示如何修改当前信号屏蔽字。表10-4说明了 可选用的值。SIG_BL0CK是“或”操作，而SIG_SETMASK则是賦值操作。注意，不能阻塞
SIGKILL 和 SIGST0P 信号。
表10-4用sigprocmask更改当前信号屏蔽字的方法
how	说 明
SIG_BL0CK SIG_UNBLOCK SIG一SETMASK	该进程新的信号屏蔽字是其当前信号屏蔽字和wr指向信号集的 并集。包含了我们希望阻塞的附加信号
该进程新的信号屏蔽字是其当前信号屏蔽字和wr所指向信号集 补集的交集。包含了我们希望解除阻塞的信号 该进程新的信号屏蔽字将被指向的信号集的值代替
如果是空指针，则不改变该进程的信号屏蔽字，/ww的值也无意义。

 
10.13 sigpending函数 259
(sigismember(&sigset#	SIGINT))
(s igi smember(&sigset,	SIGQUIT))
(sigismember(&sigset,	SIGUSR1))
(sigismember(&sigsetf	SIGALRM))
printf ("SIGINT ••}; printf ("SIGQUIT ") printf("SIGUSR1 ") printf ("SIGALRM '•)
在调用sigprocmask后如果有任何未决的、不再阻塞的信号，则在sigprocmask返回前, 至少会将其中一个信号递送给该进程。
sigprocmask是仅为单线程的进程定义的。为处理多线程的进程中信号的屏蔽，提供了另一个单 独的函数。我们将在12.8节中对此进行讨论。
实例
程序清单10-10显示了一个函数，它打印调用进程的信号屏蔽字中信号的名称。程序清单 10-14和程序清单10-15将调用此函数。
	程序清单10-10为进程打印信号屏蔽字	
#	inc lude M apue. h ■■
#include <errno.h>
void
pr一mask(const char *str)
{ _
sigset—t sigset； int	er mo_s ave ；
errn。一save = errno；	/* we can be called by signal handlers */
if (sigprocmask(0, NULL, &sigset) < 0) err_sys("sigprocmask error")；
printf("%sn, str)；
/* remaining signals can go here */
printf("Xn")； errno = errno 一save；
} "
为了节省空间，没有对表10-1中列出的每一种信号测试该屏蔽字(见习题10.9)。
10.13	sigpending 函数
sigpending函数返回信号集，其中的各个信号对于调用进程是阻塞的而不能递送，因而 也一定是当前未决的。该信号集通过参数返回。
#include <signal.h> int sigpending(sigset_t *srf)；
返回值：若成功则返回0,若出错则返回-1
实例
程序清单10-11使用了很多前面说明过的信号功能。
if
if
if
if

 
260 第10幸信 号
程序清单10-11倌号设置和sigprocmask实例
#include napue.h"
static void sig_quit(int);
int
main (void)
{
sigset一t newmask, oldmask, pendmask;
if (signal(SIGQUIT, sig_quit) == SIG_ERR) err_sys("can,t catch SIGQUIT"); 一
/*
*	Block SIGQUIT and save current signal mask.
*/
sigemptyset(&newmask)； sigaddset (Senewmask, SIGQUIT)；
if (sigprocmask(SIG_BL0CK, &newmask, &oldmask) < 0) err一sys("SIG—BLOCK error");
sleep (5); /* SIGQUIT here will remain pending */
if (sigpending(&pendmask) < 0) err一sys("sigpending error")； if (sigismember(&pendmask, SIGQUIT)) printf("\nSIGQUIT pending\n")；
/*
*	Reset signal mask which unblocks SIGQUIT */
if (sigprocmask(SIG_SETMASK, ioldmask, NULL) < 0) err_sys("SIG_SETMASK error")； printf ("SIGQUIT unblocked\n,»)；
sleep(5)； /* SIGQUIT here will terminate with core file */ exit(0)；
}
static void sig_quit(int signo)
{ _
printf("caught SIGQUIT\n")； if (signal(SIGQUIT, SIG_DFL) »= SIG—ERR) err 一 sys ("can, t reset SIGQUIT");""
进程阻塞SIGQUIT信号，保存了当前信号屏蔽字(以便以后恢复)，然后休眠5秒钟。在此 期间所产生的退出信号SIGQUIT都会被阻塞’而不递送至该进程’直到该信号不再被阻塞。在 5秒钟休眠结束后，检査该信号是否是未决的，然后将SIGQUIT设置为不再阻塞。
注意，在设置SIGQUIT为阻塞时，我们保存了旧屏蔽字。为了解除对该信号的阻塞，用旧 屏蔽字重新设置了进程信号屏蔽字(SIG_SETMASK)。另一种方法是用SIG_UNBLOCK使阻塞 的信号不再被阻塞。但是，应当了解如果编写一个可能由其他人使用的函数，而且需要在函数 中阻塞一个信号’则不能用SIG一UNBLOCK简单地解除对此信号的阻塞，这是因为此函数的调 用者在调用本函数之前可能也阻塞了此信号。在这种情况下必须使用SIG_SETMASK将信号屏 蔽字复位为原先值’这样也就能继续阻塞该信号。10.18节的sys tern函数部分有这样一个例子。

 
10.14 sigaction函数 261
addr of signal handler, */ or SIG 一IGN, or SlG_DFL */ additional signals to block */ signal options, Figure 10.16 */
struct sigaction {
void (*sa一handler)(int);
sigset_t sa_mask; int	sa flags;
/* alternate handler */
void (*sa_sigaction)(int, siginfo一t *, void *)；
}； _ _
当更改信号动作时，如果sa_handler字段包含一个信号捕捉函数的地址(与常量 SIG_IGN或SIG_DFL相对)，则sa_mask字段说明了一个信号集，在调用该信号捕捉函数之前， 这一信号集要加到进程的信号屏蔽字中。仅当从信号捕捉函数返回时再将进程的信号屏蔽字复
在休眠期间如果产生了退出信号，那么此时该信号是未决的，但是不再受阻塞，所以在 sigprocmask返回之前，它被递送到调用进程。从程序的输出中可以看出：SIGQUIT处理程 序(sig_quit)中的printf语句先执行，然后再执行si卯rocmask之后的printf语句。
然后该进程再休眠5秒钟。如果在此期间再产生退出信号，那么因为在上次捕捉到该信号 时，已将其处理方式设置为默认动作，所以这一次它就会使该进程终止。在下列输出中，当我 们在终端上键入退出字符Ctrl+\时，终端打印、(终端退出字符)：
$ ./a.out
SIGQUIT pending caught SIGQUIT SIGQUIT unblocked "AQult (coredump)
$ ./a.out
SIGQUIT pending caught SIGQUIT SIGQUIT unblocked AQuit (coredump)
产生信号一次(在5秒钟之内)
从sleep返回后
在信号处理程序中
从sigprocmask返回后
再次产生信号
[323]
产生信号10次(在5秒钟之内)
只产生信号一次
再次产生信号
在shell发现其子进程异常终止时，会输出“Quit (coredump)"消息。注意，第二次运
行该程序时，在进程休眠期间我们使SIGQUIT信号产生了 10次，但是解除了对该信号的阻塞后，
只会向进程传送一次SIGQUIT。从中可以看出在此系统上没有对信号进行排队。	口
10.14	sigaction函数
sigaction函数的功能是检査或修改与指定信号相关联的处理动作(或同时执行这两种
操作)。此函数取代了UNIX早期版本使用的signal函数。在本节末尾用sigaction函数实现
Tsignal。
#include <signal.h>
int sigaction (int signo, const struct sigaction * restrict act,
struct sigaction *restrict oact)；
返回值：若成功则返回0，若出错则返回-1
其中，参数是要检测或修改其具体动作的信号编号。若指针非空，则要修改其动 作。如果指针非空，则系统经由指针返回该信号的上一个动作。此函数使用下列结构：
/*
/*
/*
/*

 
262 第10幸信 号
位为原先值。这样，在调用信号处理程序时就能阻塞某些信号。在信号处理程序被调用时，操 作系统建立的新信号屏蔽字包括正被递送的信号。因此保证了在处理一个给定的信号时，如果 这种信号再次发生，那么它会被阻塞到对前一个信号的处理结束为止。回忆10.8节，若同一种 信号多次发生，通常并不将它们排队，所以如果在某种信号被阻塞时它发生了五次，那么对这 种信号解除阻塞后，其信号处理函数通常只会被调用一次。
一旦对给定的信号设置了一个动作，那么在调用sigaction显式地改变它之前，该设置 就一直有效。这种处理方式与早期的不可靠信号机制不同，而符合了P0SIX.1在这方面的要求。
acr结构的sa—flags字段指定对信号进行处理的各个选项。表10-5详细列出了这些选项的 意义。若该标志已定义在基本P0SIX.1标准中，那么SUS列包含•，若该标志定义在基本 P0SIX.1标准的XSI扩展中，那么该列包含XSI。
表10-5处理每个倍号的选项标志(Sa_flagS)
选 项	SUS	FreeBSD
5.2.1	Linux
2.4.22	Mac OS X 10.3	Solaris
9	说 明
SA 一INTERRUPT			•			由此信号中断的系统调用不会自动重启 动(针对sigaction的XSI默认处理方 式)。详见10.5节
SA_N0CLDST0P		•	•		•	若signo是SIGCHLD，当子进程停止时 (作业控制)，不产生此信号。当子进程终 止时，仍旧产生此信号(但请参阅下面说 明的SA_NOCLDWAIT选项)。若已设置此 标志，则当停止的进程继续运行时，作为 XSI扩展，不发送SIGCHLD信号
SA_NOCLDWAIT	XSI	•			•	若坤《0是SIGCHLD，则当调用进程的子 进程终止时，不创建僵死进程。若调用进 程在后面调用则调用进程阻塞，直 到其所有子进程都终止，此时返回-1，并 将errno设置为ECHILD (见10.7节)
SA_N0DEFER	XSI	•	•		•	当捕捉到此信号时，在执行其信号捕捉 函数时，系统不自动阻塞此信号(除非 sa_mask包括了此信号)。注意，此种类 型的操作对应于早期的不可靠信号
SA_0NSTACK	XSI	*	•	•	•	若用s i gal t s t ac k(2)声明了 一替换栈， 则将此信号递送给替换栈上的进程
SA_RESETHAND	XSI	•	•	•		在此信号捕捉函数的入口处，将此信号 的处理方式复位为SIG_DFL,并清除 SA_SIGINF0标志。注意，此种类型的信 号对应于早期的不可靠信号。但是，不能 自动复位SIGILL和SIGTRAP这两个信号 的配置。设置此标志使sigaction的行为如 同SA_NODEFER标志也设置了 一样
SA_RESTART	XSI	•	•	•	•	由此信号中断的系统调用会自动重启动 (参见10.5节)
SA 一SIGINFO	•	*	•	•	•	此选项对信号处理程序提供了附加信 息：一个指向siginfo结构的指针以及 一个指向进程上下文标识符的指针

 
10.14 sigaction函数 263
/* signal number */
/* if nonzero, errno value from <errno.h> */
/* additional info (depends on signal) */
/* sending process ID */
/* sending process real user ID */
/* address that caused the fault */
/* exit value or signal number */
/* band number for SIGPOLL */	[^25
fields also */	i
326
sa_sigaction字段是一个替代的信号处理程序，当在sigaction结构中使用了 SA_SIGINFO标志时，使用该信号处理程序。对于sa_sigaction字段和sa_handler字段 这两者，其实现可能使用同一存储区，所以应用程序只能一次使用这两个字段中的一个。
通常，按下列方式调用信号处理程序： void handler (int signo)；
但是，如果设置了SA_SIGINFO标志，那么按下列方式调用信号处理程序： void handler (int signo f siginfo一 t *info, void * context)；
siginfo_t结构包含了信号产生原因的有关信息。该结构的大致样式如下所示。POSIX.1 依从的所有实现必须至少包括si_signo和si_code成员。另外，XSI依从的实现至少应包含 下列字段：
表10-6示出了各种信号的si_code值，这些信号是由Single UNIX Specification定义的。注 意，实现可定义附加的代码值。
若信号是SIGCHLD，则将设置si_pid、si_status和si_uid字段。若信号是SIGILL 或SIGSEGV，则si_addr包含造成故障的根源地址，尽管该地址可能并不准确。若信号是 SIGPOLL,那么si_band字段将包含STREAMS消息的优先级段(priority band)，该消息产生 P0LL_IN、E>0LL_0UT或P0LL_MSG事件(关于优先级段的详细讨论，请参见Rago[1993])。 si_errno字段包含错误编号，它对应于引发信号产生的条件，并由实现定义。
信号处理程序的contert参数是无类型指针，它可被强制转换为ucntext_t结构类型，用于 标识信号传递时进程的上下文。
当实现支持实时信号扩展时.用SA_SIGINFO标志建立的信号处理程序将导致信号可靠地排队。
一些保留信号可由实时应用程序使用。如果信号由sigqueue产生，那么siginfo结构能包含应用特有
的数据。我们不再进一步讨论实时扩展。详细情况请参见Gallmeister[1995]。
实例:signal函数
现在用sigaction实现signal函数。很多平台都是这样做的(POSIX.1的Rationale也说 明这是POSIX所希望的)。另一方面，有些系统支持旧的不可靠信号语义signal函数。其目的 是实现二进制向后兼容，除非明确要求旧的不可靠语义(为了向后兼容)，否则应当使用下面 的signal实现，或者直接调用sigaction (可以在调用sigaction时指定SA_RESETHAND 和SA_NODEFER选项以实现旧语义的signal函数)。本书中所有调用signal的实例均调用程 序清单10-12中实现的该函数。
finfo { ii—signc ii_errnc ii—code; ii_pid； ii_uid； ii—addr; ii_statL ii—band; bly ott
t m-m- dIgPC ctttdd.lt ^ unnn i i pno *
ri -Xi p u V il /

 
264 第10章信 号
表 10-6 siginfo_t 代码值
信号	代码	原因
	ILL—ILLOPC	非法操作码
	ILL一ILLOPN	非法操作数
	ILL_ILLADR	非法地址模式
SIGILL	ILL_ILLTRP	非法陷入
	ILL_PRVOPC	特权操作码
	ILL一PRVREG	特权寄存器
	ILL_COPROC	协处理器出错
	ILL—BADSTK	内部栈出错
	FPE_INTDIV	整数除以0
	FPE一INTOVF	整数溢出
	FPE_FLTDIV	浮点除以0
SIGFPE	FPE_FLTOVF	浮点上溢
	FPE—FLTUND	浮点下溢
	FPE-FLTRES	浮点不精确结果
	FPE_FLTINV	无效的浮点运算
	FPE一FLTSUB	下标越界
SIGSEGV	SEGV_MAPERR	地址未映射到对象
	SEGV 一 ACCERR	对于映射对象的无效权限
	BUS一ADRALN	无效的地址对齐
SIGBUS	BUS-ADRERR	不存在的物理地址
	BUS一OBJERR	对象特有的硬件出错
SIGTRAP	TRAP—BRKPT	进程断点陷入
	TRAP-TRACE	进程跟踪陷入
	CLD-EXITED	子进程已终止
	CLD一KILLED	子进程已异常终止(无core)
SIGCHLD	CLD_DUMPED	子进程已异常终止(有core)
	CLD一TRAPPED	被跟踪的子进程已陷入
	CLD_STOPPED	子进程已停止
	CLD_CONTINUED	停止的子进程已继续
	POLL-IN	数据可读
	POLL_OUT	数据可写
SIGPOLL	POLL-MSG	输入消息可用
	POLL_ERR	i/o出错
	POLL一PRI	高优先级消息可用
	POLL—HUP	设备断开连接
	SI_USER	kill发送的信号
	SI_QUEUE	sigqueue发送的信号(实时扩展)
Any	SI_TIMER	timer_settime设置的计时器超时(实时扩展)
	SI_ASYNCIO	异步i/o请求完成(实时扩展)
	SI_MESGQ	一条消息到达消息队列(实时扩展)

 
10.14 sigaction函数 265
程序清单10-12用sigaction实现的signal函数
#include "apue.h"
/* Reliable version of signal(), using POSIX sigaction(). */ Sigfunc *
signal(int signo, Sigfunc *func)
{
struct sigaction act, oact;
act.sa—handler = func； sigemptyset(&act.sa_mask)； act.sa—flags = 0； if (signo == SIGALRM) {
#ifdef SA_INTERRUPT
act.sa flags I= SA INTERRUPT; ttendif	^
} else {
#ifdef SA 一RESTART
act.sa一flags |= SA—RESTART;
#endif
}
if (sigaction(signo, &act, &oact) < 0) return(SIG一ERR)； return(oact.sa_handler)；
注意，必须用sigemptyset函数初始化act结构的sa_mask成员。不能保证：
act.sa_mask =0;
会做同样的事情。
对除SIGALRM以外的所有信号，我们都有意尝试设置SA_RESTART标志，于是被这些信号 中断的系统调用都能重启动。不希望重启动由SIGALRM信号中断的系统调用的原因是：我们希 望对I/O操作可以设置时间限制(请回忆有关程序清单10-7的讨论)。
某些早期系统(如SunOS)定义了SA_INTERRUPT标志。这些系统的默认方式是重新启动被 中断的系统调用，而指定此标志则使系统调用被中断后不再重启动。Linux定义SA_INTERRUPT 标志，以便与使用该标志的应用程序兼容。但是，如若信号处理程序是用sigaction设置的， 那么其默认方式是不重新启动系统调用。Single UNIX Specification的XSI扩展规定，除非说明了 SA_RESTART标志，否则sigaction函数不再重启动被中断的系统调用。	口
实例：signal__intr函数
程序清单10-13是signal函数的另一种版本，它力图阻止任何被中断的系统调用重启动。
程序清单10-13 signal—intr函数
#include "apue.h"
Sigfunc *
signal_intr(int signo, Sigfunc *func)
<
struct sigaction act, oact；
act.sahandler = func； sigenptyset(&act.sa_mask)? act.sa_flags = 0；
#ifdef SA_INTERRUPT
act.sa_flags |= SA一INTERRUPT;
327
I

 
266 第10章信 号
#endif
if (sigaction(signo, &act# &oact) < 0) return(SIG_ERR)； return(oact.sa_handler)；
如果系统定义了SA_INTERRUPT标志，那么为了提高可移植性，我们在sa_flags中增加 该标志，这样也就阻止了被中断的系统调用重启动。	口
10.15	sigset jmp 和 siglongjmp 函数
7.10节说明了用于非局部转移的set jmp和longjmp函数。在信号处理程序中经常调用 (329| longjmp函数以返回到程序的主循环中，而不是从该处理程序返回。程序清单10-5和程序清单
10-8中已经出现了这种情况。
但是，调用longjmp有一个问题。当捕捉到一个信号时，进入信号捕捉函数，此时当前信 号被自动地加到进程的信号屏蔽字中。这阻止了后来产生的这种信号中断该信号处理程序。如 果用long jmp跳出信号处理程序，那么，对此进程的信号屏蔽字会发生什么呢？
在FreeBSD 5.2.1和Mac OS X 10.3中，setjmp和longjmp保存和恢复信号屏蔽字。但是，Linux 2.4.22和Solaris 9并不执行这种操作。FreeBSD 5.2.1 和Mac OS X 10.3提供函Isetjn^^Jongjmp, 它们也不保存和恢复信号屏蔽字。
为了允许两种形式的行为并存，POSIX.1并没有说明set jmp和longjmp对信号屏蔽字的 作用，而是定义了两个新函数sigset jmp和siglongjmp。在信号处理程序中进行非局部转 移时应当使用这两个函数。
# inc lude <setjinp.h>	
int sigsetjmp (sigjmp—buf env, i]	nt savemask)；
返回值：若直接调用则返回0，若从siglongjmp调用返冋则返回非0值
void siglongjmp (sigjmp一buf env,	int val)；
这两个函数与set jmp和long jmp之间的唯一区别是sigset jmp增加了一个参数。如果
■Kzvema■^非0,则sigsetjmp在env中保存进程的当前信号屏蔽字。调用siglongjmp时，如果
带非0 sflvemo从的sigsetjmp调用已经保存了⑶v,贝Ijsiglongjmp从其中恢复保存的信号屏
蔽字。
实例
程序清单10- M演示了在佶号处理程序被调用时，系统所设置的信号屏蔽字如何自动地包括
刚被捕捉到的信号。该程序也通过实例说明了如何使用sigsetjmp和siglongjmp函数。
程序清单10-14信号屏蔽字.sigsetjn®)和siglongjinp实例
#include "apue.h"
#include <setjnp.h>
#include <time.h>
static void
sig_usrl(int), sig_alrra(int)；

 
10.15 sigsetjmp和siglongjmp函数 267
static sigjmp_buf	jmpbuf；
static volatile sig_at.omic_t canjumpj
int
main (void)
if (signal(SIGUSRl, sig—usrl) == SIG一ERR) err^eye("signal(SIGUSR1) error");
if (signal (SIGALRM, sig_alrni) == SIG_ERR) err^eye("signal(SIGALRM) error"); pr_mask("starting main：");
if (8igsetjmp(jmpbuf# 1)) { pr_maek("ending main:"); exit(0);
can j ump =1; /* now eigsetjmpO is OK */
for ( ; ?) pause ();
}
static void
sig 一usrl(int signo)
{ 一
time—t starttime；
if (canjump == 0)
return；	/* unexpected signal, ignore */
pr_maek("starting sig—usrl:");
alarm(3);	/* SIGALRM in 3 seconds */
starttime = time(NULL)；
for ( . ； )	/* busy wait for 5 seconds */
if (time(NULL) > starttime + 5) break；
pr一mask("finishing Big_uerl：");
canj ump = 0；	.
siglongjmp(jmpbuf, 1); /* jump back to main, don't return */
}
static void sig_alrm(int signo)
{ 一
pr_mask("in sig一alrm:");
此程序演示了另一种技术，只要在信号处理程序中调用siglongjmP’就应使用这种技术。 仅在调用sigset jmp之后才将变量can jump设置为非0值。在信号处理程序中检测此变量，仅 当它为非0值时才调用siglongjmp。这提供了一种保护机制，使得在jmpbuf (跳转缓冲)尚 未由sigset jmp初始化时，防止调用信号处理程序(在本程序中，调用siglongjmp之后程序 很快就结束，但是在较大的程序中，在调用siglongjmp之后的一段较长时间内，信号处理程 序可能仍旧被设置)。在一般的C代码中(不是信号处理程序)，对于longjmp并不需要这种保 护措施。但是’因为信号可能在任何时候发生’所以在信号处理程序中’需要这种保护措施。
在程序中使用了数据类型sig_atomic_t，这是由ISO C标准定义的变量类型，在写这种 类型的变量时不会被中断。它意味着在具有虚拟存储器的系统上这种变量不会跨越页边界’可 以用一条机器指令对其进行访问。这种类型的变量总是包括ISO类型修饰符volatile,其原
[3301
[3311

 
268 第10幸信 号
因是：该变量将由两个不同的控制线程——main函数和异步执行的信号处理程序访问。 图10-1显示了此程序的执行时间顺序。
main
signal{) signal{) pr一mask{) sigsetjmp() pause{1
SIGUSR1 delivered : 	► »ig_u»rl
pr mask () alarm() time() time() time()
f SIGALRM delivered _	
	
pr一mask{)
	 return()
!从信号处理程序返回
pr mask() siglbngjmp ()
图10-1处理两个信号的实例程序的时间顺序
可将图10-1分成三部分：左面部分(对应于main)、中间部分(sig—usrl)和右面部分
(sig_alrm)0在进程执行左面部分时，信号屏蔽字是0 (没有信号是阻塞的)。而执行中间部
分时，其信号屏蔽字是SIGUSR1。执行右面部分时，信号屏蔽字是SIGUSR1 | SIGALRM。
执行程序清单10-14，得到下面的输出：
$ ./a.out &
starting main：
[1] 531
$ kill -USR1 531
starting sig一 usrl: SIGUSR1
$ in sig_alrm： SIGUSR1 SIGALRM
finishing sig_usrl： SIGUSR1
ending main：
[1] + Done	./a.out &
该输出与我们所期望的相同：当调用一个信号处理程序时，被捕捉到的信号加到进程的当前信 号屏蔽字中。当从信号处理程序返回时，恢复原来的屏蔽字。另外，siglongjmp恢复了由 sigset jmp保存的信号屏蔽字。.
如果在Linux 2.4.22中将程序清单IO-I4中的sigset jmp和siglongjmp分别替换成_set jmp 和—longjmp (在FreeBSD中，贝lj替换成^setjir^tLlongjmp)，则最后一行输出变成： ending main： SIGUSR1
这意味着在调之后执行main函数时，其SIGUSR1是阻塞的。这多半不是我们所希 望的。	□
10.16	sigsuspend 函数
上面已经说明，更改进程的信号屏蔽字可以阻塞所选择的信号，或解除对它们的阻塞。使
在后台启动进程
作业控制shell打印其进程ID
向该进程发送SIGUSR1
键入回车
sigsetjmp() pr mask () exitO

 
10.16 sigsuspend函数 269
用这种技术可以保护不希望由信号中断的代码临界区。如果希望对一个信号解除阻塞，然后 pause以等待以前被阻塞的信号发生，则又将如何呢？假定信号是SIGINT,实现这一点的一 种不正确的方法是：
sigset—t newmask, oldmask?
sigemptyset(&newmask)； sigaddset(&newmask, SIGINT)?
/* block SIGINT and save current signal mask */ if (sigprocmask(SIG_BL0CK/ &newmask, &oldmask) < 0) err—sys(HSIG一BLOCK error")；
/* critical region of code */
/* reset signal mask, which unblocks SIGINT */ if (sigprocmask(SIG_SETMASKI &oldmask, NULL) < 0) err_sys("SIG一SETMASK error")；
/* window is open */
pause(); /* wait for signal to occur */
/* continue processing */
如果在信号阻塞时将其发送给进程，那么该信号的传递就被推迟直到对它解除了阻塞。对 应用程序而言，该信号好像发生在解除对SIGINT的阻塞和pause之间(取决于内核如何实现 信号。)》如果发生了这种情况，或者如果在解除阻塞时刻和pause之间确实发生了信号，那么 就产生了问题。因为我们可能不会再见到该信号，所以从这种意义上而言，在此时间窗口中发 生的信号丢失了，这样就使得pause永远阻塞。这是早期的不可靠信号机制的另一个问题。
为了纠正此问题，需要在一个原子操作中先恢复信号屏蔽字，然后使进程休眠。这种功能 是由sigsuspend函数提供的。
#include <signal.h>	
int sigsuspend (const sigset_t *sigmask)；	
	返回值：-1，并将errno设置为EINTR
将进程的信号屏蔽字设置为由指向的值。在捕捉到一个信号或发生了一个会终止该 进程的信号之前，该进程被挂起。如果捕捉到一个信号而且从该信号处理程序返回，则 处M/wui返回，并且将该进程的信号屏蔽字设置为调用办皿之前的值。
注意，此函数没有成功返回值。如果它返回到调用者，则总是返回_1，并将errno设置为 EINTR (表示一个被中断的系统调用)。
 
程序清单10-15显示了保护临界区，使其不被特定信号中断的正确方法。
	程序清单10-15保护临界区不被信号中断
#include "apue.h"
static void sig一int(int);
int
main(void)

 
270 第10幸信 号
sigset_t newmask, oldmask, waitmask；
pr一mask ("program start: ，•)；
if (signal(SIGINT, sig_int) =* SIG一ERR) err一sys("signal(SIGINT) error")? sigemptyset(&waitmask)； sigaddset (Scwaitmaek, SIGUSR1)； sigemptyset (&newmask)； sigaddset(&newmask, SIGINT);
/*
*	Block SIGINT and save current signal mask.
*/
if (sigprocmask(SIG 一BLOCK, &newmask, &oldmask) < 0) err一sys("SIG 一BLOCK error")；
/*
*	Critical region of code.
*/
pr_mask("in critical region： "};
"
*	Pause, allowing all signals except SIGUSR1.
*/
if (eigeuepend(&waitmaek) != -1) err一sys("sigsuspend error")；
pr一mask("after return from sigsuspend:");
/*
*	Reset signal mask which unblocks SIGINT.
*/
if (sigprocmask(SIG 一SETMASK, &oldmask, NULL) < 0) err_eys("SIG_SETMASK error")；
*	And continue processing */
pr_maek("program exit: "); exit(0)；
static void sig_int(int signo)
{—
pr_mask(H\nin sig_int:")』
注意，当sigsuspend返回时，它将信号屏蔽字设置为调用它之前的值。在本例中， SIGINT信号将被阻塞。因此将信号屏蔽字复位为早先保存的值(oldmask)。 运行程序清单10-15得到下面的输出：
$ ./a.out
program start：
in critical region： SIGINT
a?	键入中断字符
in sig_int： SIGINT SIGUSR1
after return from sigsuspend： SIGINT
program exit:

 
10.16 sigsuspend函数 271
在调用sigsuspend时，将SIGUSR1信号加到了进程信号屏蔽字中，所以当运行该信号处 理程序时，我们得知信号屏蔽字已经改变了。从中可见，在sigsuspend返回时，它将信号屏 蔽字恢复为调用它之前的值。	口
 
sigsuspend的另一种应用是等待一个信号处理程序设置一个全局变量。程序清单10-16 用于捕捉中断信号和退出信号，但是希望仅当捕捉到退出信号时，才唤醒主例程。
程序清单10-16用BigBUBpend等待一个全周变量被设置
#include "apue.h"
volatile sig_atomic_t quitflag； /* set nonzero by signal handler */ static void
sig_int(int signo) /* one signal handler for SIGINT and SIGQUIT */
{ 一
if (signo *: SIGINT)
printf ("\ninterrupt\n11); else if (signo =* SIGQUIT)
quitflag =1; /* set flag for main loop */
}
int
main(void)
{
sigset一t newmask, oldmask, zeromask;
if (signal(SIGINT, sig_int) == SIG_ERR) err一sys(”signal(SIGINT) error")； if (signal(SIGQUIT, sigint) == SIG—ERR) err—sys (11 signal (SIGQUIT) error")；
sigemptyset(&zeromask)； sigemptyset(&newmaek); sigaddset(&newmask, SIGQUIT)；
/*
*	Block SIGQUIT and save current signal mask.
*/
if (sigprocmask(SIG一BLOCK, &newmask, &oldmask) < 0) err 一sys("SIG_BL0CK error")；
while (quitflag == 0)
sigsuspend(&zeromask);
/*
*	SIGQUIT has been caught and is now blocked; do whatever.
*/
quitflag - 0;
/*
*	Reset signal mask which unblocks SIGQUIT.
*/
if (sigprocmask(SIG_SETMASK# &oldmask, NULL) < 0) err—sys("SIG_SETMASK error");
exit(0)；

 
272 第10章信 号
此程序的示例输出是:
$ ./a.out	键入中断字符
interrupt	再次键人中断字符
interrupt	再一次
interrupt
一？	再-次
interrupt	再一次
interrupt	再-次
interrupt	再-次
interrupt 、$	用退出符终止
□
考虑到支持ISO C的非POSIX系统与POSIX系统两者之间的可移植性，在一个信号处理程序中我们
喷一应当做的是試一个值给类型为sig—atomic_t^变量。P0SIX.1规定得更多一些，它详细说明了在
一个信号处理程序中可以安全地调用的函数列表(见表10-3),但是如果这样鳊写代码，则它们可能不
会正确地在非P0SIX系统上运行。
实例
可以用信号实现父、子进程之间的同步，这是信号应用的另一个实例。程序清单10-17包含
了8.9节中提到的五个例程的实现，它们是：TELL_WAIT、TELL_PARENT、TELL_CHILD、
WAIT—PARENT 和 WAIT_CHILD0
程序清单10-17父子进程可用来实现同步的例程
#include "apue.h"
static volatile sig_atomic_t sigflag； /* set nonzero by sig handler */ static sigset一t newmask, oldmask, zeromask；
static void
sig_usr(int signo) /* one signal handler for SIGUSR1 and SIGUSR2 */ sigflag = 1；
void
TELL WAIT(void)
==SIG_ERR) error")；
==SIGERR) error")；
if (signal(SIGUSR1, sig_usr)
err一sys("signal(SIGUSR1)
if (signal(SIGUSR2, sigusr)
err—sys("signal(SIGUSR2)
sigemptyset(&zeromask)；
sigemptyset(&newmask)；
sigaddset(&newmask# SIGUSR1)；
sigaddset(&newmask, SIGUSR2)；
Block SIGUSR1 and SIGUSR2, and save current signal mask.

 
10.16 sigsuspend函数 273
if (sigprocmask(SIG—BLOCK, 6tnewmask, &oldmask) < 0) err_sys("SIG_BLOCK error");
} " ' void
TELL一PARENT (pid_t pid)
{ 一 '
kill(pid, SIGUSR2);	/* tell parent we're done */
}
void
WAIT_PARENT(void)
{ 一
while (sigflag == 0)
sigsuspend(&zeromask); /* and wait for parent */ sigflag = 0;
/*
*	Reset signal mask to original value.
*/
if (sigprocmask(SIG—SETMASK, &oldmask, NULL) < 0) err一sys(MSIG_SETMASK error");
} ~ ~ void
TELL_CHILD(pid_t pid)
{ ' *
kill(pid, SIGUSR1);	/* tell child we're done */
}
void
WAIT__CHILD(void)
{ 一
while (sigflag == 0)
sigsuspend{&zeromask); /* and wait for child */ sigflag = 0;
/*
*	Reset signal mask to original value.
*/
if (sigprocmask(SIG—SETMASK, &oldmask, NULL) < 0) err—sys("SIG-SETMASK error"}；
其中使用了两个用户定义的信号：SIGUSR1由父进程发送给子进程，SIGUSR2由子进程 发送给父进程。程序清单15-3示出了使用管道的这五个函数的另一种实现。	口
如果在等待信号发生时希望去休眠，则使用sigsuspend函数是非常适当的(正如前面两 个例子中所示)，但是如果在等待信号期间希望调用其他系统函数，那么将会怎样呢？不幸的 是，在单线程环境下对此问题没有妥善的解决方法。如果可以使用多线程，则可专门安排一个 线程处理信号(见12.8节中的讨论)。
如果不使用线程，那么我们能尽力做到最好的是，当信号发生时，在信号捕捉程序中对一 个全局变量置1。例如，若我们捕捉SIGINT和SIGALRM这两种信号，并用signal_intr函数 设置这两个信号的处理程序，使得它们中断任一被阻塞的低速系统调用。当进程阻塞在 select函数调用(见12.5.1节)等待低速设备输入时，很可能发生这两种信号(如果设置闹钟 以阻止永远等待输入，那么对于SIGALRM信号，这是特别真实的)。处理这种问题的代码类似

 
274 第10章信 号
于下面所示：
if (intr_flag)	/* flag set by our SIGINT handler */
handle_intr()；
if (alrm 一flag)	/* flag set by our SIGALRM handler */
handle_alrm()；
/* signals occurring in here are lost */
while (select(…)< 0) { if (errno == EINTR) { if (alrm_flag)
handle_alrm();、 else if (intr 一flag) handle_intr{)；
} else {
/* some other error */
}
}
在调用select之前测试各全局标志，如果select返回一个中断的系统调用错误，则再次 进行测试。如果在前两个if语句和后随的select调用之间捕捉到两个信号中的任意一个，则 问题就发生了。正如代码中的注释所指出的，在此处发生的信号丢失了。调用信号处理程序， 它们设置了相应的全局变量，但是select决不会返回(除非某些数据已准备好可读)。
我们希望按顺序执行下列操作步骤：
(1)阻塞SIGINT和SIGALRM。
_ (2)测试两个全局变量以判别是否发生了一个信号，如果已发生则对此进行处理。
(3)	调用select (或任何其他系统调用，例如read)并解除对这两个信号的阻塞，这两 个操作应当是一个原子操作。
仅当第(3)步是pause操作时，sigsuspend函数才能帮助我们。
10.17	abort函数
前面已提及abort函数的功能是使异常程序终止。
#include <stdlib.h>	
void abort(void)；	此函数不返回
此函数将SIGABRT信号发送给调用进程(进程不应忽略此信号)。ISO C规定，调用abort 将向主机环境递送一个未成功终止的通知，其方法是调用raise (SIGABRT)函数。
ISO C要求若捕捉到此信号而且相应信号处理程序返回，abort仍不会返回到其调用者。 如果捕捉到此信号，则信号处理程序不能返回的唯一方法是它调用exit、_exit、_Exit、 longjmp或siglongjmp。(10.15节讨论了longjmp和siglongjmp之间的区别。)POSIX. 1 也说明abort并不理会进程对此信号的阻塞和忽略。
让进程捕捉SIGABRT的意图是：在进程终止之前由其执行所需的清理操作。如果进程并不 在信号处理程序中终止自己，POSIX.1声明当信号处理程序返回时，abort终止该进程。
ISO C针对此函数的规范将下列问题留由实现决定：是否要冲洗输出流以及是否要删除临

 
10.17 abort函数 275
时文件(见5.13节)？ POSIX.1的要求则更进一步，它要求如果abort调用终止进程，则它对所 有打开标准I/O流的效果应当与进程终止前对每个流调用fclose相同。
在系统V的早期版本中，abort函数产生SIGIOT信号。更进一步讲，进程忽略此信号或者捕捉它 并从信号处理程序返回，这都是可能的，在返回情况下，abort返回到它的询用者。
4.3BSD产生SIGILL信号。在此之前，该函数ff除对此信号的阻塞，将其配置恢复为SIG_DFL (终止并构造core文件)。这阻止一个进程忽略或捕捉此信号，
历史上，abort的各种实现在如何处理标准I/O流方面并不相同..。对于保护性的程序设计以及为提 高可移植性，如果希望冲洗标准I/O流，則在调用abort之前要执行这种操作。在err_dump函数中实现 了这一点(见附录B)。
因为大多数UNIX tmpfile (临时文件)的实现在创建该文件之后会立即调用unlink,所以ISO C关于临时文件的警告通常与我们无关。
实埯
程序清单10-18中的abort函数是按POSIX.1说明实现的。
程序清单10-18 abort的POSIX.1实现
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
void
abort(void)	/* POSIX-style abort() function */
{
sigset_t	mask；
struct sigaction action；
*	Caller can,t ignore SIGABRT, if so reset to default.
*/
sigaction(SIGABRT, NULL, &action)； if (action.sa一handler == SIG一IGN) { action.sa—handler = SIG一DFL; sigaction(SIGABRT, &action, NULL)；
}
if (action•sa一 handler == SIG 一 DFL}
fflush(NULL)；	/★ flush all open stdio streams */
*	Caller can,t block SIGABRT； make sure it's unblocked.
*/
sigfillset(&mask)；
sigdelset(&maskf SIGABRT)； /* mask has only SIGABRT turned off */
sigprocmask(SIGSETMASK, ficmask, NULL);
kill(getpid(), SIGABRT)； /* send the signal */
*	If we,re here, process caught SIGABRT and returned.
*/
fflush(NULL);	/* flush all open stdio streams */
action.sa_handler = SIG_DFL；
sigaction(SIGABRT, ficaction, NULL); /* reset to default */

 
276 第10幸信 号
sigprocmask(SIG^SETMASK, Smask, NULL)； /* just in case …*/ kill(getpidO, SIGABRT)；	/★ and one more time */
exit(1)； /* this should never be executed ... */
首先查看是否将执行默认动作，若是则冲洗所有标准i/o流。这并不等价于对所有打开的流 调用fclose (因为只冲洗，并不关闭它们)，但是当进程终止时，系统会关闭所有打开的文件。 如果进程捕捉此信号并返回，那么因为进程可能产生了更多的输出，所以再一次冲洗所有的流。 不进行冲洗处理的唯一条件是如果进程捕捉此信号，然后调用_exit或_Exit。在这种情况下， 内存中任何未冲洗的标准I/O缓冲区都被丢弃。我们假定捕捉此信号，而且_exit或_Exit的 调用者并不想要冲洗缓冲区。
回忆10.9节，如果调用kill使其为调用者产生信号，并且如果该信号是不被阻塞的(程序 清单10-18保证做到这一点)，则在kill返回前该信号(或某个未决、未阻塞的信号)就被传送 给了该进程。我们阻塞除SIGABRT之外的所有信号，这样就可知如果对kill的调用返回了， 则该进程一定巳捕捉到该信号，并且也从该信号处理程序返回。	口
10.18 system 函数
8.13节中巳经有了一个system函数的实现，但是该版本并不执行任何信号处理。POSIX.1要
求system忽略SIGINT和SIGQUIT，阻塞SIGCHLD。在给出一个正确地处理这些信号的一个 版本之前，先说明为什么要考虑信号处理。
程序清单10-19使用8.13节中的system版本，用其调用ed(l)编辑器。(ed很久以来就是 UNIX的组成部分。在这里使用它的原因是：它是捕捉中断和退出信号的交互式程序。若从 shell调用ed，并键入中断字符，则它捕捉中断信号并打印问号。它还将对退出符的处理方式设 置为忽略。)
程序淸单10-19 用system调用ed编辑器
include "apue.h"
static void sig_int(int signo)
{ _
printf("caught SIGINT\n”)；
}
static void sig_chld(int signo)
{ 一
printf ("caught SIGCHLD\n");
main (void)
{
if (signal(SIGINT, sig一int) == SIG—ERR) err一sys("signal(SIGINT) error"); if (signal(SIGCHLD, sig—chid) == SIG—ERR)

 
10.18 system 函数 277
err一sys("signal(SIGCHLD) error"); if (system(11/bin/ed” < 0)
err一sys (system () error”); exit(0)；
程序清单10-19用于捕捉SIGINT和SIGCHLD信号。若调用它则可得:
$ ./a.out
a
Here is or
line of text
1/$P
Here is one line of text w temp.foo
25
q
caught SIGCHLD
将正文添加至编辑器缓冲区 行首的点停止添加方式
打印缓冲区中的第1行至最后1行，以便观察其内容
将缓冲区写至一文件 编辑器称写了 25个字节 离开编辑器
当编辑器终止时，系统向父进程(a. out进程)发送SIGCHLD信号。父进程捕捉它，然后 从信号处理程序返回。但是若父进程正在捕捉SIGCHLD信号(因为它创建了子进程，所以应当 这样做以便了解它的子进程在何时终止)，那么正在执行system函数时，应当阻塞对父进程递 送SIGCHLD信号。实际上，这就是POSIX.I所说明的。否则，当sys tem创建的子进程结束时, sys tern的调用者可能错误地认为，它自己的一个子进程结束了。于是，调用者将会调用一种 wait函数以获得子进程的终止状态，这样就阻止了 sys tem函数获得子进程的终止状态，并将 其作为它的返回值。
如果再次执行该程序，在这次运行时将一个中断信号传送给编辑器，则可得：
$ ./a.out a
hello, world l,$p
hello, world w temp.foo
13
caught SIGINT
q
caught SIGCHLD
将正文添加至编辑器缓冲区 行首的点停止添加方式
打印缓冲区中的第1行至最后1行，以便观察其内容
将缓冲区写至一文件 编辑器称写了 13个字节 键入中断符
编辑器捕捉信号，打印问号 父进程执行同一操作 离开编辑器
回忆9.6节可知，键入中断字符可使中断信号传送给前台进程组中的所有进程。图10-2显示 了编辑程序正在运行时的各个进程的关系。
342
I
343
 
后台进程组	前台进程组
图10-2程序清单10-19运行时的前台和后台进程组
在这一实例中，SIGINT被送给三个前台进程(shell进程忽略此信号)。从输出中可见， a .out进程和ed进程捕捉该信号。但是，当用sys tem运行另一个程序(例如ed)时，不应使 父、子进程两者都捕捉终端产生的两个信号：中断和退出。这两个信号只应送给正在运行的程

 
278	羊10幸信 号
序：子进程。因为由system执行的命令可能是交互式命令(如本例中的ed程序)，以及因为 system的调用者在程序执行时放弃了控制，等待该执行程序的结束，所以system的调用者就 不应接收这两个终端产生的信号。这就是为什么POSIX.1规定system的调用者应当忽略这两个 信号的原因。	n
程序清单10-20显示了system函数的另一个实现，它进行了所要求的信号处理。
	程序淸单10-20 system函数的POSIX.1正确实现
#include	<sys/wait.h>
#include	<errno.h>
#include	<signal.h>
#include	<unistd.h>
int
system(const char *cmdstring)
{
Pid一t	pid；
int	status；
struct sigaction ignore,
/* with appropriate signal handling */
saveintr, savequit；
sigset_t	chldmask, savemask；
if (cmdstring == NULL)
return(1)；	/* always a command processor with UNIX */
ignore•sa一handler = SIG 一IGN; /* ignore SIGINT and SIGQUIT */ sigemptyset(&ignore.sa—mask)； ignore.sa_flags 二 0；
if (sigaction(SIGINT, signore, &saveintr) < 0) return(-1)；
if (sigaction(SIGQUIT, signore, &savequit) < 0) return(-1);
sigemptyset(&chldmask);	/* now block SIGCHLD */
sigaddset(Schldmask, SIGCHLD)；
if (sigprocmask(SIG 一BLOCK, &chldmask# &savemask) < o) return(-1)；
if ((pid = fork()) < 0) {
status = -1; /* probably out of processes */
} else if (pid == 0) {	/* child */
/* restore previous signal actions & reset signal mask */ sigaction(SIGINT, &saveintr, NULL); sigaction(SIGQUIT, &savequit, NULL); sigprocmask(SIG_SETMASK, &savemask, NULL)；
execl("/bin/sh", "shnr ”-c", cmdstring, (char *)0)；
—exit(127); /* exec error */
} else {	/* parent */
while (waitpid(pid, &status, 0) < 0) if (errno !- EINTR) {
status = -1; /* error other than EINTR from waitpid() */ break；
}
}
/* restore previous signal actions & reset signal mask */ if (sigaction(SIGINT, Ssaveintr, NULL) < 0)

 
10.18 system 函敦 279
return (-1)；
if (eigaction(SIGQUIT, &eavequitf NULL) < 0) return(-1)；
if (sigprocmask(SIG—SETMASK, &savemask, NULL) < 0) return(-1)；
return(status);
}
如果链接程序清单10-19与3¥3161函数的这一实现，那么所产生的二进制代码与上一个有 缺陷的程序相比较，存在如下差别：
(1)	当我们键入中断或退出字符时，不向调用进程发送信号。
(2)	当ed命令终止时，不向调用进程发送SIGCHLD信号。作为替代，在程序末尾的 sigprocmask调用对SIGCHLD信号解除阻塞之前，SIGCHLD信号一直被阻塞。而对 sigprocmask函数的这一次调用是在system函数调用waitpid取到了子进程的终止状态之后。
POSIX.1指出，在SIGCHLD未决期间，如若wait或waitpid返回了子进程的状态，那么SIGCHLD 信号不应递送给该父进程，除非另一个子进程的状态也可用。本书讨论的四种实现都没有实现这种语 义。作为替代，在system雨数调用了waitpid后，SIGCHlJD保持为未决；当解除了对此信号的阻塞后， 它被递送至调用者。如果我们在程序清单10-19的sig_chld函数中调用wait,則它将返回-1,并将 errno设置为ECHILD，因为system雨数已取到子进程的终止状态。
很多较早的书籍中使用下列程序段，它忽略中断和退出信号：
if ((pid = fork()) < 0) { err一sys("fork error");
} else if (pid == 0) {
/* child */ execl(..•}; exit(127)；
/* parent */
old一intr = signal(SIGINT, SIG—IGN); old一quit = signal(SIGQUIT, SIG_IOJ); waitpid(pid, &status, 0) signal(SIGINT, old一intr); signal(SIGQUIT, old 一quit);
这段代码的问题是：在fork之后不能保证父进程还是子进程先运行。如果子进程先运行，父 进程在一段时间后再运行，那么在父进程将中断信号的配置更改为忽略之前，就可能产生这种 信号。由于这种原因，程序清单10-20在fork之前就改变对该信号的配置。
注意，子进程在调用execl之前要先恢复这两个信号的配置。如同8.10节中所说明的一样， 这就允许在调用者配置的基础上，execl可将它们的配置更改为默认值。	□
ByBtem的返回值
注意system的返回值，它是shell的终止状态，但shell的终止状态并不总是执行命令字符 串进程的终止状态。程序清单8-13中有一些例子，其结果正是我们所期望的。如果执行一条如 date那样的简单命令，其终止状态是0。执行shell命令exit 44,则得终止状态44。在信号方 面又如何呢？
运行程序清单8-14,并向正在执行的命令发送一些信号：

 
280 第10章信 号
$ tsys "sleep 30_
^?normal termination, exit status = 130 键入中断符
$ tsys _0l的p 30_
"Xsh: 946 Quit	键入退出符
normal termination, exit status = 131
当用中断信号终止sleep时，pr_exit函数(见程序清单8-3>认为它正常终止。当用退
出键杀死sleep进程时，会发生同样的事情。终止状态130、131又是怎样得到的呢？原来
Bourne shell有一个在其文档中没有说清楚的特性，其终止状态是128加上一个信号编号，该信
_号终止了正在执行的命令。用交互方式使用shell可以看到这一点。
确保运行Bourne shell
$ 0h $ 0h
"sleep 30"
$ echo $?
130
$ sh -c "sleep 30"
"\sh： 962 Quit - core dumped
$ echo $?
131
$ exit
键入中断符
打印最后一条命令的终止状态 键入退出符
打印最后一条命令的终止状态
离开Bourne shell
在所使用的系统中，SIGINT的值为2，SIGQUIT的值为3，于是给出shell终止状态130、131。 再试一个类似的例子，这一次将一个信号直接送给shell,然后观察system返回什么：
$ tsya _alaap 30" &	这一次在后台启动它
9257
$ ps -f	查看进程ID
UID	PID	PPID	TTY	TIME	CMD
sar	9260	94 9	pts/5	0:00	ps -f
sar	9258	9257	pts/5	0:00	sh -c sleep 60
sar	949	947	pts/5	0:01	/bin/sh
sar	9257	949	pts/5	0:00	tsys sleep 60
sar	9259	9258	pts/5	0:00	sleep 60
$ kill -KILL 9258			杀死shell自身
abnormal	termination,	signal	number	=9
从中可见仅当shell本身异常终止时，system的返回值才报告一个异常终止。
在编写使用system函数的程序时，一定要正确地解释返回值。如果直接调用fork、 exec和wait,则终止状态与调用system是不同的。
10.19 sleep函数
在本书的很多例子中都已使用了sheep函数，在程序清单10-4和程序清单10-5中有sleep的 两个有缺陷的实现。
#include <unistd.h>	
unsigned int sleep (unsigned int seconds)；	
	返回值：0或未休眠够的秒数
此函数使调用进程被挂起，直到满足以下条件之一：
(1)已经过了•secwufc所指定的墙上时钟时间。
[3D (2)调用进程捕捉到一个信号并从信号处理程序返回。
如同alarm信号一样，由于其他系统活动，实际返回时间比所要求的会迟一些。

 
10.19 sleep 函致 281
在第1种情形中，返回值是0。当由于捕捉到某个信号sleep提早返回时(第2种情形)，返 回值是未睡够的秒数(所要求的时间减去实际休眠时间)。
尽管sleep可以用alarm函数(见10.10节)实现，但这并不是必需的。如果使用alarm, 则这两个函数之间可能交互作用。POSIX.1标准对这些交互作用并未做任何说明。例如，若先 调用alarm(lO)，过了3秒后又调用SleeP(5)，那么将如何呢？ sleep将在5秒后返回(假定在 这段时间内没有捕捉到另一个信号)，但是否在2秒后又产生另一个SIGALRM信号呢？这些细节 依赖于实现。
Solaris 9用alarm实现sleep。Solaris 9 sleep(3>手册页中说明以前安排的闹钟仍被正常处理。 例如，在前面的例子中.在sleep返回之前，它安排在2秒后再次到达闹钟时间。在这种情况下， sleep返回0 (显然，sleep必须保存SIGALRM信号处理程序的地址，并在返回前复位它)。另外，如果 先做一次alarm(6>，3秒钟之后又做一次sleep(5),则在3秒后sleep返回(第一次闹钟时间已到)， 而不是5秒钟。此时，sleep的返回值是未睡够的时间2秒。
FreeBSD 5.2.1、Linux 2.4.22和Mac OS X 10.3则使用另一种技术：用nanosleep(2)提供时间延迟t 该函数由Single UNIX Specification的实时扩展说明，它提供的时间延迟是高分辨率的。该函数可以使 sleep的实现与信号无关。
考虑到可移植性，不应对sleep的实现作任何假定，但是如果混合调用sleep和其他与计时有关 的函数，则需了解它们之间可能产生的交互作用o
实例	
程序清单10-21是一个POSIX.1 sleep函数的实现。此函数是程序清单10-4的修改版，它可 靠地处理信号，避免了早期实现中的竞争条件，但是仍未处理与以前设置的闹钟的交互作用 (正如前面提到的，P0SIX. 1并未显式地定义这些交互作用)。
	程序清单10-21日leep的可靠实现	
#inc1ude "apue.h"
static void sig_alrm(int signo)
{ _
/* nothing to do, just returning wakes up sigsuspend() */
}
unsigned int
sleep{unsigned int nsecs)
{
struct sigaction newact, oldact；
sigset_t	newmask, oldmask, suspmask；
unsigned int	unslept;
/★ set our handlerf save previous information */ newact•sa一handler = sig—alrm; sigemptyset{&newact♦sa一mask)； newact•sa_flags = 0；
sigaction(SIGALRM, &newact f &oldact)；
/★ block SIGALRM and save current signal mask */ sigemptyset(&newmask)； sigaddset(&newmask, SIGALRM)；

 
282 第10幸信 号
sigprocmask (SIG_BLOCK, Scnewmask, &oldmask)； alarm(nsecs)； suspmask = oldmask;
sigdelset (Scsuspmask, SIGALRM) ； /* make sure SIGALRM isn't blocked ★/ 8igsuspend(Scsuspmask) ；	/* wait for any signal to be caught */
/* some signal has been caught, SIGALRM is now blocked */
unslept = alarm(0);
sigaction(SIGALRM, &oldact, NULL)； /★ reset previous action */
/* reset signal mask, which unblocks SIGALRM */ sigprocmask(SIG_SETMASK, &oldmask, NULL); return(unslept);
与程序清单10-4相比，为了可靠地实现sleep，程序清单10-21的代码比较长。程序中没有 使用任何形式的非局部转移(如程序清单10-5为了避免在alarm和pause之间的竞争条件所做 的那样)，所以对处理SIGALRM信号期间可能执行的其他信号处理程序没有任何影响。 口
10.20作业控制信号
在表10-1所示的信号中，POSIX.1认为有6个与作业控制有关：
SIGCHLD子进程已停止或终止。
SIGC0NT如果进程已停止，则使其继续运行。
SIGST0P停止信号(不能被捕捉或忽略)。
SIGTSTP交互式停止信号。
SIGTTIN后台进程组成员读控制终端。
SIGTT0U后台进程组成员写到控制终端。
除SIGCHLD以外，大多数应用程序并不处理这些信号：交互式Shell则通常做处理这些信号 的所有工作。当键入挂起字符(通常是Ctrl+Z)时，SIGTSTP被送至前台进程组的所有进程。 当我们通知shell在前台或后台恢复运行一个作业时，shell向该作业中的所有进程发送SIGC0NT 信号。与此类似，如果向一个进程递送了SIGTTIN或SIGTT0U信号，则根据系统默认的方式 停止此进程，作业控制shell了解到这一点后就通知我们。
一个例外是管理终端的进程——例如，vi(l)编辑器。当用户要挂起它时，它需要能了解 到这一点，这样就能将终端状态恢复到vi启动时的情况。另外，当在前台恢复它时，它需要将 终端状态设置回它所希望的状态，并需要重新绘制终端屏幕。可以在下面的例子中观察到与vi 类似的程序是如何处理这种情况的。
在作业控制信号间有某种交互作用。当对一个进程产生四种停止信号(SIGTSTP、 SIGSTOP、SIGTTIN或SIGTT0U)中的任意一种时，对该进程的任一未决SIGC0NT信号就会 被丢弃。与此类似，当对一个进程产生SIGC0NT信号时，对同一进程的任一未决停止信号将被 丢弃。
注意，如果进程是停止的，SIGC0NT的默认动作是继续运行该进程，否则忽略此信号。通 常，对该信号无需做任何事情。当对一个停止的进程产生一个SIGC0NT信号时，该进程就继续 运行，即使该信号是被阻塞或忽略的也是如此。

 
10.20作业控制信号 283
程序清单10-22例示了当一个程序处理作业控制时所使用的规范代码序列。该程序只是将其 标准输入复制到其标准输出，而在信号处理程序中以注释形式给出了管理屏幕的程序所执行的 典型操作。当程序清单10-22启动时，仅当SIGTSTP信号的配置是SIG_DFL,它才安排捕捉该 信号。其理由是：当此程序由不支持作业控制的shell (例如/bin/sh)启动时，此信号的配置 应当设置为SIG_IGN。实际上，shell并不显式地忽略此信号，而是由init将这三个作业控制 信号SIGTSTP、SIGTTIN和SIGTTOU设置为SIG_IGN。然后，这种配置由所有登录shell继承。 只有作业控制shell才应将这三个信号复位为SIG_DFL。
程序清单10-22 如何处理SIGTSTP
#include ”apue.h"
#define BUFFSIZE 1024 static void sig_tstp(int); int
main(void)
int
char
n;
buf[BUFFSIZE],
Only catch SIGTSTP if we're
running with a job-control shell.
if (signal(SIGTSTP, SIG 一IGN> == SIG 一DFL> signal(SIGTSTP, sig_tstp)；
while ((n = read(STDIN—FILENO, buf, BUFFSIZE)) > 0) if- (write (STDOUT一FILENO, buf, n) != n) err_sys (,'write error"};
if (n < 0)
err_sys("read error"}；
exit(0);
static void
sig_tstp(int signo) /* signal handler for SIGTSTP */
{ _
sigset_t mask；
/* …move cursor to lower left corner, reset tty mode …*/ /*
*	Unblock SIGTSTP, since itf s blocked while we're handling it.
sigemptyset(&mask)；
sigaddset(&mask, SIGTSTP)；
sigprocmask(SIG_UNBLOCK, &mask,
NULL)；
reset disposition to default */ and send the signal to ourself
signal(SIGTSTP, SIG_DFL)； /★
kill(getpid(), SIGTSTP)； /★
/* we won't return from the kill until we,re continued */
signal(SIGTSTP, sig_tstp); /★ reestablish signal handler ★/

 
284 第10章信 号
reset tty mode, redraw screen
350
A
当键入挂起字符时，进程接到SIGTSTP信号，然后调用该信号处理程序。此时，应当进行 与终端有关的处理：将光标移到左下角，恢复终端工作方式等等。在将SIGTSTP复位为默认值 (停止该进程)，并且解除了对此信号的阻塞之后，进程向自己发送同一信号SIGTSTP。因为正 在处理SIGTSTP信号，而在捕捉该信号期间系统会自动阻塞它，所以应当解除对此信号的阻塞。 到达这一点时，系统停止该进程。仅当某个进程(通常是正响应一个交互式fg命令的作业控制 shell)向该进程发送一个SIGC0NT信号时，该进程才继续。我们不捕捉SIGC0NT信号。该信 号的默认配置是继续运行停止的进程，当此发生时，此程序如同从ki丄丄函数返回一样继续运 行。当此程序继续运行时，将SIGTSTP信号复位为捕捉，并且做我们所希望做的终端处理(例 如重新绘制屏幕)。	□
10.21其他特征
本节介绍某些依赖于实现的信号的其他特征。
1.	信号名字 某些系统提供数组
extern char *sys一siglist[];
数组下标是信号编号，给出一个指向信号字符串名字的指针。
FreeBSD 5.2.1、Linux 2.4.22和Mac OS X 10.3都提供这种信号名数组。Solaris 9也提供信号名数组， 但该数组名是_sys—siglist。
这些系统通常也提供函数psignal£ ^include <signal.h>
void psignal (int signo, const char *msg)
固
字符串m找(通常是程序名)输出到标准出错文件，后接一个冒号和一个空格，再接着对该信 号的说明，最后是一个换行符。该函数类似于perror (1.7节)。
另一个常用函数是strsignal。它类似于strerror (也见1.7节)。
#include <string.h> char * strsignal (int signo)；
返回值：指向描述该信号的字符串的指针
给出一个信号编号，strsignal将返回说明该信号的字符串。应用程序可用该字符串打印关 于接收到信号的出错消息。
本书讨论的所有平台都提供psignal和strsignal函数，但相互之间有些差别。在Solaris 9中， 若信号编号无效，那么，strsignal将返回一个空指针，而FreeBSD 5.2.1、Linux 2.4.22和Mac OS X 10.3则返回一个字符串，它指出信号编号是不可识别的^另外，在Solaris中，为了得到psignal的函数 原型，需在程序中包括<8土9；11^o. h>。

 
10.22 小 结 285
2.信号映射
Solaris提供一对函数，一个函数将信号编号映射为信号名，另一个则反之。
#include <signal.h>
int sig2str (int signo, char *$tr)；
int str2sig(const char *$tr, int *signop)；
两个函数的返回值：若成功则返回0,若出错则返回-1
在编写交互式程序，其中需接收和打印信号名和编号时，这两个函数是有用的。
sig2str函数将给定信号编号翻译成字符串，并将结果存放在^•指向的存储区。调用者必 须保证该存储区足够大，可以保存最长的字符串，包括终止null字节。SolariS®<Signal.h>
中包含了常量SIG2STR_MAX，它定义了最大字符串长度。该字符串包括不带“SIG”前缀的信 号名。例如，SIGKILL被翻译为字符串“KILL”，并存放在sfr指向的存储缓冲区中。
str2s ig函数将给出的名字翻译成信号编号。该信号编号存放在印指向的整型中。名 字要么是不带“SIG”前缀的信号名，要么是表示十进制信号编号的字符串(例如“9”)。
注意，sig2str和str2sig偏离了一般实践，当它们失败时，并不设置errno。
10.22小结
信号用于大多数复杂的应用程序中。理解进行信号处理的原因和方式对于髙级UNIX编程 极其重要。本章对UNIX信号进行了详细而且比较深入的介绍。首先说明了早期信号实施的问 题以及它们是如何显现出来的。然后介绍了P0SIX.1的可靠信号概念以及所有相关的函数。在 此基础上接着提供了abort、system和sleep函数的P0SIX.1实现。最后以观察分析作业控 制信号以及信号名和信号编号之间的转换结束。
习题
10.1删除程序清单10-1中的for(;;)语句，结果会怎样？为什么？
10.2实现10-21节中说明的sig2str函数。	國
10.3画出运行程序清单10-6时的栈帧情况。
10.4程序清单10-8中利用setjmp和longjmp设置I/O操作的超时，下面的代码也常用于此种 目的：
signal(SIGALRM, sig_alrm)； alarm(60)；
if (setjmp(env_alrtn) ! = 0) {
/* handle timeout */
这段代码有什么错误？
10.5仅使用一个计时器(alarm或较髙精度的setitimer),构造一组函数，使得进程在该 单一计时器基础上可以设置任意数量的计时器。
10.6编写一段程序测试程序清单10-17中父进程和子进程的同步函数，要求进程创建一个文件 并向文件写一个整数0,然后进程调用fork,接着父进程和子进程交替增加文件中的计


 
286 第10幸信 号
数器值，毎次计数器值增1时，打印是哪一个进程(子进程或父进程)进行了该增1操作。
10.7在程序清单10-18所示的函数中，若调用者捕捉了SIGABRT并从该信号处理程序中返回， 为什么不是仅仅调用_exit,而要复位其默认设置并再次调用kill?
10.8	为什么在siginfo结构(见10.14节)的si_uid字段中包括实际用户ID而非有效用户ID?
10.9重写程序清单10-10中的函数，要求它处理表10-1中的所有信号量，毎次循环处理当前信 号屏蔽字中的一个信号量(并不是对毎一个可能的信号量都循环一次)。
10.10编写一段程序，要求在一个无限循环中调用Sleep(60)函数，毎5分钟(即5次循环)取 当前的日期和时间，并打印tm_SeC字段。将程序执行一晚上，请解释其结果。有些程 序(如BSD中的cron精灵进程)毎分钟运行一次，它是如何处理这类工作的？
10.11修改程序清单3-3，要求：(a)将BUFFSIZE改为100, (b)用signal_intr函数捕捉 SIGXFSZ信号量并打印消息，然后从信号量处理程序中返回；(C)如果没有写满请求的 字节数，则打印write的返回值。将软资源限制RLIMIT_FSIZE (见7.11节)变为1 024 字节(在shell中设置软资源限制，如果不行就直接在程序中调用setrlimit),然后复 制一个大于1024字节的文件，在各种不同的系统上运行新程序，其结果如何？为什么？ 10.12编写一段调用fv/rite的程序，它使用一个较大的缓冲区(几百兆)，在调用fwrite前 调用alarm使得一秒钟以后产生信号。在信号处理程序中打印捕捉到的信号，然后返回。
网	调用fwrite可以完成吗？结果如何？

 

