第9章
进程关系
9.1引言
在上一章我们已了解到进程之间具有关系。首先，每个进程都有一个父进程(初始的内核 进程并无父进程，也可以说其父进程就是它自己)。当子进程终止时，父进程得到通知并能取 得子进程的退出状态。在8.6节说明waitpid函数时，我们也提到了进程组，以及如何等待进 程组中的任意一个进程终止。
本章将更详细地说明进程组以及P0SIX.1引入的会话的概念。还将介绍登录shell (登录时 所调用的)和所有从登录shell启动的进程之间的关系。
在说明这些关系时不可能不谈及信号，而讨论信号时又需要很多本章介绍的概念。如果不 熟悉UNIX系统信号机制，则可能先要浏览一下第10章。
9.2终端登录
先说明当我们登录到UNIX系统时所执行的各个程序。在早期的UNIX系统(例如V7)中， 用户用哑终端(用硬连接连到主机)进行登录。终端要么是本地的(直接连接)要么是远程的 (通过调制解调器连接)。在这两种情况下，登录都经由内核中的终端设备驱动程序。例如，在 PDP-11上常用的设备是DH-11和DZ-11。因为连到主机上的终端设备数已经确定，所以同时的 登录数也就有了已知的上限。
随着位映射图形终端变成可用，开发出了窗口系统，它向用户提供了与主机系统进行交互 的新方式。创建“终端窗口”的应用程序也被开发出来，它仿真了基于字符的终端，使得用户 可以用熟悉的方式(即通过shell命令行)与主机交互。
现今，某些平台允许用户在登录后启动一个窗口系统，而另一些平台则自动为用户启动窗 口系统。在后一种情况中，用户可能仍然需要登录，这取决于窗口系统是如何配置的(某些窗 口系统可配置成自动登录用户)。
我们现在说明的过程用于经由终端登录至UNIX系统。该过程是类似的，而与所使用的终 端无关，终端可以是基于字符的终端、仿真简单的基于字符终端的图形终端，或者是运行窗口 系统的图形终端。
1.	BSD终端登录
在过去30年中，登录过程并没有多少改变。系统管理员创建通常名为/etc/ttys的文件，其中， 每个终端设备都有一行，每一行说明设备名和传递给getty程序的参数，例如，参数之一说明 了终端的波特率等。当系统自举时，内核创建进程ID为1的进程，也就是init进程。init进程 使系统进入多用户状态。init进程读文件/etc/ttys，对每一个允许登录的终端设备，init
[26T1

 
214 第9幸进程关系
调用一次fork,它所生成的子进程则执行(exec) getty程序。图9-1中显示了这些进程。
图9-1中各个进程的实际用户ID和有效用户ID都是0 (即它们都具有超级用户特权)。init H回以空环境执行getty程序。
getty为终端设备调用open函数，以读、写方式将终端打开。如果设备是调制解调器， 贝IJopen可能会在设备驱动程序中滞留，直到用户拨号调制解调器，并且呼叫被应答。一且设 备被打开，则文件描述符0、1、2就被设置到该设备。然后getty输出“login:”之类的信息， 并等待用户键入用户名。如果终端支持多种速度，则getty可以测试特殊字符以便适当地更改 终端速度(波特率)。关于getty程序以及有关数据文件(gettytab)的细节，请参阅UNIX 系统手册。
当用户键入了用户名后，getty的工作就完成了。然后它以类似于下面的方式调用login 程序：
execle (11/bin/login", "login", "-p", username, {char *) 0, envp)；
(在gettytab文件中可能会有一些选项使其调用其他程序，但系统默认的是login程序)。 init以一个空环境调用getty。getty以终端名(例如TERM=foo，其中终端foo的类型取自 gettytab文件)和在getty tab中说明的环境字符串为login创建一个环境(envp参数)。 -P标志通知login保留传给它的环境，也可将其他环境字符串加到该环境中，但是不要替换它。 图9-2显示了 login刚被调用后这些进程的状态。
进程ID1
进程
 
每个终端调
用一次fork
每个子进程执行
(exec) getty
 
图9-1 init为允许终端登录而调用的进程	图9-2调用login后的进程状态
因为最初的init进程具有超级用户特权，所以图9-2中的所有进程都有超级用户特权。图
9-	2中底部三个进程的进程ID相同，因为进程ID不会因执行exec而改变。并且，除了最初的 init进程，所有进程的父进程ID均为1。
login能执行多项工作。因为它得到了用户名，所以能调用getpwnam取得相应用户的口 令文件登录项。然后调用getpass(3)以显示提示“Password:”，接着读用户键入的口令 國(自然，禁止回送用户键入的口令)。它调用cryPt(3)将用户键入的口令加密，并与该用户在阴 影口令文件中登录项的pw_passwd字段相比较。如果用户几次键入的口令都无效，则login 以参数1调用exit表示登录过程失败。父进程(init) 了解到子进程的终止情况后，将再次 调用fork，其后接着执行getty，对此终端重复上述过程。
这是UNIX系统传统的用户身份验证过程。现代UNIX系统已发展到支持多个身份验证过程。 例如，FreeBSD、Linux、Mac OS X以及Solaris都支持被称为PAM (Pluggable Authentication

 
9.2终端登录 215
Module,可插入式身份验证模块)的更加灵活的方案。PAM允许管理员配置使用何种身份验证
方法来访问那些使用PAM库编写成的服务。
如果应用程序需验证一用户是否具有适当的权限去执行某个服务，那么我们可以将身份验
证机制编写到应用中，或者使用PAM库来得到等价的功能。使用PAM的优点是，管理员可以基
于本地策略、针对不同任务配置不同的验证用户身份的方法。
如果用户正确登录，login就将执行如下工作：
•将当前工作目录更改为该用户的起始目录(chdir)。
•调用chov/n改变该终端的所有权，使登录用户成为它的所有者。
•将对该终端设备的访问权限改变成用户读和写。
•调用setgid及initgroups设置进程的组ID。
•用login所得到的所有信息初始化环境：起始目录(HOME)、Shell (SHELL)、用户名
(USER和LOGNAME),以及一个系统默认路径(PATH)。
•	login进程改变为登录用户的用户ID (setuid)并调用该用户的登录shell,如下：
exec1("/bin/sh", "-sh", (char *)0)；
argv[0]的第一个字符是一个标志，表示该shell被调用为登录shelU shell可以查看此字符，
并相应地修改其启动过程。
login程序实际所做的比上面说的要多。它可选择打印日期消息(message-of-the-day)文件，
检査新邮件以及执行其他一些任务。但是考虑到本书的内容，我们主要关心上面所说的功能。
回忆8.11节中对setuid函数的讨论，因为setuid是由超级用户调用的，它更改所有三个
用户ID:实际用户ID、有效用户ID和保存的用户ID。login在较早时间调用的setgid对所有
三个组ID也有同样效果。
到此为止，登录用户的登录shell开始运行。其父进程ID是init进程ID (进程ID 1)，所以
当此登录shell终止时，init会得到通知(接到
SIGCHLD信号)，它会对该终端重复全部上述过程。
将登录shell的文件描述符0、1和2设置为终端设备。
图9-3显示了这种安排。	’
现在，登录shell读取其启动文件(Bourne shell
和Korn shell是：.profile; GNU Bourne-again
shell是.bash_prof i le、. bash_login或
.profile； C shell是.cshrc和-login)。这些启
动文件通常会改变某些环境变量，加上很多环境变
鼋。例如，很多用户设置他们自己的PATH,常常提
示实际终端类型(TERM)。当执行完启动文件后，
用户最后得到shell提示符，并能键入命令。
2.	Mac OS X终端登录
Mac OS X部分基于FreeBSD,所以其终端登录
进程与BSD登录进程的工作步骤相同。但是，Mac OS X—开始提供的就是图形终端。
3.	Linux终端登录
Linux的终端登录过程非常类似于BSD。确实，Linux login命令是从4.3BSD login命令
进程ID1
 
图9-3为终端登录完成各种设置后的进程安排

 
216 第9章进程关系
派生而来的。BSD登录过程与Lima登录过程的主要区别在于说明终端配置的方式。
在Linux中，/etc/inittab包含配置信息，它说明了init应当为之启动getty进程的各终端 设备，这类似于系统V的方式。依赖于所使用的getty的版本，终端的各种特性要么在命令行上说 國明(如同使用agetty—样)，要么在文件/etc/gettyefs中说明(如同使用mgetty—样)。
4.	Solaris终端登录
Solaris支持两种形式的终端登录：(a) getty方式，这与上面对BSD所说明的一样，(b) ttymon登录，这是SVR4引入的一种新特性。通常，getty用于控制台，ttymon则用于其他 终端登录。
ttymon命令是服务访问设施(Service Access Facility, SAF)的一部分。SAF的目的是用一 致的方式对提供系统访问的服务进行管理。(关于SAF的详细信息，参见Rago[1993]的第6章。) 按照本书的宗旨，我们只简单说明从init到登录shell之间不同的工作步骤，最后结果则与图9- 3中所示相似。init是sac (service access controller,服务访问控制器)的父进程，sac调用 fork,然后，当系统进入多用户状态时，其子进程执行ttymon程序。ttymon监控列于配置 文件中的所有终端端口，当用户键入登录名时，它调用一次fork。在此之后ttymon的子进程 执行login,它向用户发出提示，要求输入口令。一旦完成这一处理，login执行登录用户的 登录shell,于是到达了图9-3中所示的位置。一个区别是用户登录shell的父进程现在是ttymon, 而在getty登录中，登录shell的父进程则是init。
9.3网络登录
通过串行终端登录至系统和经由网络登录至系统两者之间的主要(物理上的)区别是：通 过网络登录时，终端和计算机之间的连接不是点对点连接。在这种情况下，login只是一种可 用的服务，这与其他网络服务(例如FTP或SMTP)的性质相同。
在上一节所述的终端登录中，init知道哪些终端设备可用来进行登录，并为每个设备生 成一个getty进程。但是，在网络登录情况下，所有登录都经由内核的网络接口驱动程序(如 以太网驱动程序)，事先并不知道将会有多少这样的登录。我们不是使一个进程等待每个可能 的登录，而是必须等待一个网络连接请求的到达。
为使同一个软件既能处理终端login,又能处理网络login，系统使用了一种称为伪终端 (pseudo terminal)的软件驱动程序，它仿真串行终端的运行行为，并将终端操作映射为网络操 作，反之亦然。(在第19章，我们将详细说明伪终端。)
1. BSD网络登录
在BSD中，有一个称为inetd的进程(有时称之为因特网超级服务器)，它等待大多数网 络连接。本节将说明BSD网络登录中所涉及的进程序列。关于这些进程的网络程序设计方面的 细节，请参阅Stevens、Fenner和Rudoff[2004]。我们在此不详细说明。
作为系统启动的一部分，init调用一个shell,使其执行shell脚本/etc/rc。由此shell脚 ®本启动一个守护进程inetd。一旦此shell脚本终止，inetd的父进程就变成init。inetd等 待TCP/IP连接请求到达主机，而当一个连接请求到达时，它执行一次fork,然后生成的子进 程执行适当的程序。
我们假定到达了一个针对TELNET服务进程的TCP连接请求。TELNET是使用TCP协议的远 程登录应用程序。在另一台主机(它通过某种形式的网络与服务进程的主机相连接)上的用户， 或在同一台主机上的用户启动TELNET客户进程，由此启动登录过程：

 
9.3网络登录 217
telnet hostname
该客户进程打开一个到主机的TCP连接，在AoWname主机上启动的程序被称为 TELNET服务进程。然后，客户进程和服务进程之间使用TELNET应用协议通过TCP连接交换 数据。所发生的是启动客户进程的用户现在登录到了服务进程所在的主机。(自然，用户需要 在服务进程主机上有一个有效的账号)。图9-4显示了在执行TELNET服务进程(称为telnetd) 时所涉及的进程序列。
然后’ telnetd进程打开一个伪终端设备，并用fork分成两个进程。父进程处理通过网络 连接的通信，子进程则执行login程序。父、子进程通过伪终端相连接。在调用exec之前，子 进程使其文件描述符0、1、2与伪终端相连。如果登录正确，login就执行9.2节中所述的同样步 骤：更改当前工作目录为起始目录，设置登录用户的组ID和用户ID,以及登录用户的初始环境。 然后login调用exec将其自身替换为登录用户的登录shell。图9-5显示了此时的进程安排。
进程ID1
 
通过inetd、telnetd 和login
telnetd 服务器和 telnet *客户的网络连接
图9-4执行TELNET服务进程时涉及的进程序列 图9-5为网络登录完成各种设置后的进程安排
很明显，在伪终端设备驱动程序和终端实际用户之间有很多事情正在发生。第19章详细说 明伪终端时，我们会介绍与这种安排相关的所有进程。
需要理解的重点是：当通过终端(见图9-3)或网络(见图9-5)登录时，我们得到一个登录 shell,其标准输入、输出和标准出错连接到一个终端设备或者伪终端设备上。在下一节中我们会 了解到这一登录shell是一个POSIX.1会话的开始，而此终端或伪终端则是会话的控制终端。
1.	Mac OS X网络登录
由于Mac OS X部分基于FreeBSD,因此经由网络登录至Mac OS X系统与BSD系统完全相同。
2.	Linux网络登录
除了使用扩展的因特网服务守护进程xinetd代替inetd进程外，Linux网络登录的其他方 面与BSD相同。xinetd进程对它所启动的各种服务的控制比inetd提供的更加精细。
3.	Solaris网络登录
Solaris中的网络登录方案与BSD和Lima中的步骤几乎完全一样。它同样使用了类似于BSD 版本的inetd服务进程，但是在Solaris中，inetd具有一种附加的能力，使其可以在服务访问 设施框架下运行，尽管它并没有配置成按此种方式运行。作为替代，inetd服务进程由init 启动。最后得到的结果与图9-5中一样。

[267|
[268]
 
218 第9章进程关系
[269]
9.4进程组
每个进程除了有一个进程ID之外，还属于一个进程组，第10章讨论信号时还会涉及进程组。 进程组是一个或多个进程的集合。通常，它们与同一作业相关联(9.8节详细讨论了作业控 制)，可以接收来自同一终端的各种信号。每个进程组有一个唯一的进程组ID。进程组ID类似 于进程ID——它是一个正整数，并可存放在pid_t数据类型中。函数getpgrp返回调用进程的 进程组ID。
#include <unistd.h>	
pid__t getpgrp (void);	返回值：调用进程的进程组0)
在早期BSD派生的系统中，该函数的参数是pW,返回该进程的进程组ID。Single UNIX Specification将getpgid函数定义为XSI扩展，它模仿了此种运行行为。
#include <unistd.h>	
pid__t getpgid {pid一t pid)；	
	返回值：若成功则返回进程组ID，若出错则返回-1
若为0,则返回调用进程的进程组ID,于是,
getpgid(O);
等价于
getpgrp{)；
每个进程组都可以有一个组长进程。组长进程的标识是，其进程组ID等于其进程ID。
组长进程可以创建一个进程组，创建该组中的进程，然后终止。只要在某个进程组中有一 个进程存在，则该进程组就存在，这与其组长进程是否终止无关。从进程组创建开始到其中最 后一个进程离开为止的时间区间称为进程组的生存期。进程组中的最后一个进程可以终止，或 者转移到另一个进程组。
进程可以通过调用setpgid来加入一个现有的组或者创建一个新进程组(下一节中将说明 用setsid也可以创建一个新的进程组)。•
^include <unistd.h>	
int setpgid {pid_t pid, pid_t pgid)；	
	返回值：若成功则返回0,若出错则返回-1
setpgid函数将pW进程的进程组ID设置为p柯。如果这两个参数相等，则由pW指定的进 程变成进程组组长。如果是0，则使用调用者的进程ID。另外，如果柯W是0,则由pW指定 的进程ID将用作进程组ID。
一个进程只能为它自己或它的子进程设置进程组ID。在它的子进程调用了exec函数之一 后，它就不再能改变该子进程的进程组ID。
在大多数作业控制shell中，在fork之后调用此函数，使父进程设置其子进程的进程组ID， 并且使子进程设置其自己的进程组ID。这两个调用中有一个是冗余的，但让泛予进程都这么做 可以保证，在父、子进程认为子进程已进入了该进程组时，这确实已经发生了。如果不这样做

 
9.5会 话 219
的话，那么fork之后，由于父、子进程运行先后次序的不确定，会造成在一段时间内(父、子 进程中只运行了其中一个)子进程组员身份的不确定(取决于哪个进程首先执行)，这就产生 了竞争条件。
在讨论信号时，将说明如何将一个信号发送给一个进程(由其进程ID标识)或一个进程组 (由进程组ID标识)。同样，8.6节的waitpid函数则可用来等待一个进程或者指定进程组中的 一个进程终止。
9.5会话
会话(session)是一个或多个进程组的集合。例如，可以具有图9-6中所示的安排。其中， 在一个会话中有三个进程组。
登录shell
procl
proc2
进程组
进程组
proc3
proc4
procB
L
进程组
会话
图9-6进程组和会话中的进程安排
通常是由shell的管道线将几个进程编成一组的。例如，图9-6中的安排可能是由下列形式的 shell命令形成的：
procl | proc2 &	-
proc3 | proc4 丨 proc5
进程调用setsid函数建立一个新会话。
#include <unistd.h>	
pid—t setsid(void)；	
	返回值：若成功则返回进程组ro，若出错则返回-1
如果调用此函数的进程不是一个进程组的组长，则此函数就会创建一个新会话，结果将发生下 面3件事：
(1)	该进程变成新会话首进程(session	leader)。(会话首进程是创建该会话的进程。)此时， 该进程是新会话中唯一的进程。
(2)	该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。
(3)	该进程没有控制终端(下一节将讨论控制终端)。如果在调用setsid之前该进程有一 个控制终端，那么这种联系也会被中断。
如果该调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不会发生这种情 况，通常先调用fork,然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的 进程组ID，而其进程ID则是新分配的，两者不可能相等，所以这就保证子进程不会是一个进程
[2701

 
220 第9章进程关系
组的组长。
Single UNIX Specification只包括“会话首进程”，而没有类似于进程ID和进程组ID的会话 ID。显然，会话首进程是具有唯一进程ID的单个进程，所以可以将会话首进程的进程ID视为会 话ID。会话ID这一概念是由SVR4引入的。历史上，基于BSD的系统并不支持这个概念，但后 来改弦易辙也包括了它。getsid函数返回会话首进程的进程组ID。此函数是Single UNIX Specification 的XSI 扩展。
某些实现(例如Solaris)与Single UNIX Specification保持一致，在实践中避免使用“会话ID”这 一短语，作为替代，将其称为“会话首进程的进程组ID”。会话首进程总是一个进程组的组长进程，所 以两者是等价的。
#include <unistd.h> pid一t getsid (pid_t pid)；
		返回值:若成功则返回会话首进程的进程组ID,若出错则返回-1
如若pW是0，getsid返回调用进程的会话首进程的进程组ID。出于安仝方面的考虑，某些实 现会有如下限制：如若pW并不属于调用者所在的会话，那么调用者就不能得到该会话首进程的 [2711进程组ID。
9.6控制终端
会话和进程组有一些其他特性：
•一个会话可以有一个控制终端(controlling terminal)。这通常是登录到其上的终端设备 (在终端登录情况下)或伪终端设备(在网络登录情况下)。
•建立与控制终端连接的会话首进程被称为控制进程(controlling process) „
•	一个会话中的几个进程组可被分成一个前台进程组(foreground process group)以及一个 或几个后台进程组(background process group)。
•如果一个会话有一个控制终端，则它有一个前台进程组，会话中的其他进程组则为后台 进程组。
•无论何时键入终端的中断键(常常是DELETE或Ctrl+C)，就会将中断信号发送给前台进 程组的所有进程。
•无论何时键入终端的退出键(常常是Ctrl+\)，就会将退出信号发送给前台进程组中的所 有进程。
•如果终端接口检测到调制解调器(或网络)已经断开连接，则将挂断信号发送给控制进 [IzD	程(会话首进程)。
这些特性示于图9-7中。
通常，我们不必关心控制终端，登录时，将自动建立控制终端。
P0SIX.1将如何分配一个控制终端的机制留由具体实现遶择。19.4节中将说明实际步蝶。
当会话首进程打开第一个尚未与一个会话相关联的终端设备时，UNIX系统V派生的系统将此作为 控制终端分配给此会话。这假定会话首进程在调用open时没有指定0一N0CTTY标志(见3.3节)。
当会话首进程用TIOCSCTTY作为叫财对参教(第三个参数是空指针)调用ioctl时，基于BSD的

 
9.7 tcgetpgrp, tcsetpgrp和tcgetsid函数 221
系统为会话分配控制终端。为仗此调用成功执行，此会话不能已经有一个控制终端(通常ioctl调用 紧跟在setsid调用之后，setsid保证此进程是一个没有控制终端的会话首进程)•除了以兼容模式支 持其他系统以外，基于BSD的系统不使flPOSIX.l中对c 3n函数所说明的0_NQCTTY标志。
会话
图+7显不控制终端的进程组和会话
有时不管标准输入、标准输出是否被重定向，程序都要与控制终端交互。保证程序能读写 控制终端的方法是打开文件/dev/tty,在内核中，此特殊文件是控制终端的同义语。自然， 如果程序没有控制终端，则打开此设备将失败。
经典的示例是用于读口令的getpaSS(3)函数(当然，终端回送被关闭)。这一函数由 crypt(l)程序调用，而此程序则可用于管道中。例如： crypt < salaries | lpr 将文件salaries解密，然后经由管道将输出送至打印假脱机程序。因为crypt从其标准输入读输 入文件，所以标准输入不能用于输入口令。但是，crypt的一个设计特征是每次运行此程序时, 都应输入加密口令，这样也就阻止了用户将口令存放在文件中(这可能是一个安全性漏洞)。
已经知道有一些方法可以破译crypt程序使用的密码。关于加密文件的详细情况请参见 Garfinkel 等[2_。
9.7 tcgetpgrp、tcsetpgrp和tcgetsid函数
需要有一种方法来通知内核哪一个进程组是前台进程组，这样，终端设备驱动程序就能了 解将终端输入和终端产生的信号送到何处(见图9-7)。
#include <umstd.h>		
pid一t tcgetpgrp (int filedes)；		
返回值：若成功则返回前台进程组的进程组丨D,	若出错则返回-1
int tcsetpgrp (int filedes, pid_t pgrpid)	;	
	返回值：若成功则返回0，	若出错则返回-1
 
procl
proc2
后台进程组
登录shell
后台进程组 会话首进程=控制进程
proc3
proc4
proc5
前台进程组

 
222 第9章进程关系
函数tcgetpgrp返回前台进程组的进程组ID，该前台进程组与在/Ffe办s上打开的终端相关联。
如果进程有一个控制终端，则该进程可以调用tcsetpgrp将前台进程组ID设置为pgrpW。 pgrpW的值应当是在同一会话中的一个进程组的ID。必须引用该会话的控制终端。
大多数应用程序并不直接调用这两个函数。它们通常由作业控制shell调用。
Single UNIX Specification定义了称为tcgetsid的XSI扩展，给出控制TTY的文件描述符， 应用程序就能获得会话首进程的进程组ID。
#include <termios.h> pid一t tcgetsid (int filedes)；
返回值：若成功则返回会话首进程的进程组ID,若出错则返回-I
需要管理控制终端的应用程序可以调用tcgetsid函数识别出控制终端的会话首进程的会 话ID (它等价于会话首进程的进程组ID)。
9.8作业控制
作业控制是BSD在1980年前后增加的一个特性。它允许在一个终端上启动多个作业(进程 组)，它控制哪一个作业可以访问该终端，以及哪些作业在后台运行。作业控制要求下面三种 形式的支持：
(1)	支持作业控制的shell。
(2)	内核中的终端驱动程序必须支持作业控制。
(3)	内核必须提供对某些作业控制信号的支持。
SVR3提供了一种不同形式的作业控制，称为shell层(shell layer)„但是POSIX.I选择了BSD形式 的作业控制，这也是我们在这里所说明的。在POSIX.丨的早期版本中，作业控制支持是可选的，现在则 要求所有平台都支持它。
从shell使用作业控制功能角度讲’用户可以在前台或后台启动一个作业。一个作业只是几 个进程的集合，通常是一个进程的管道线。例如：
vi main.c
在前台启动了只有一个进程组成的一个作业。命令
pr *.c | lpr & make all &
在后台启动了两个作业。这两个后台作业调用的所有进程都在后台运行。
正如前述’我们需要一个支持作业控制的shell以使用由作业控制提供的功能。对于早期的 回系统，shell是否支持作业控制比较易于说明。c shell支持作业控制，Bourne shell则不支持，而 Kom shell能否支持作业控制则取决于主机是否支持作业控制。但是现在c shell已被移植到并不 支持作业控制的系统上(例如系统V的早期版本)，而当用名字jsh而不是用sh调用SVR4 Bourne shell时，它支持作业控制。如果主机支持作业控制，则Korn Shell继续支持作业控制。Bourne- again shell也支持作业控制。当各种shell之间的差别并不显著时，我们将只是一般性地说明支持 作业控制的shell和不支持作业控制的shell。
当启动一个后台作业时，shell赋予它一个作业标识，并打印一个或几个进程ID。下面的脚 本显示了Kom shell是如何处理这一点的：

 
9.8作业控制 223
$ make all > Make.out &
[1]	1475
$ pr *.c | lpr &
[2]	1490
$	键入回车
[2] + Done	pr *.c | lpr &
[1] + Done	make all > Make.out &
make是作业号1，启动的进程ID是1475。下一个管道线是作业号2，其第一个进程的进程ID是
1490。当作业已完成而且我们键入回车时，shell通知我们作业已经完成。键入回车是为了让shell
打印其提示符。shell并不在任何随意时刻打印后台作业的状态改变一它只在打印其提示符让用
户输入新的命令行之前才这样做。如果不这样处理，则当我们正输入一行时，它也可能输出。
我们可以键入一个影响前台作业的特殊字符——挂起键(一般采用Ctrl+Z)与终端驱动程
序进行交互。键入此字符使终端驱动程序将信号SIGTSTP送至前台进程组中的所有进程，后台
进程组作业则不受影响。实际上有下面三个特殊字符可使终端驱动程序产生信号，并将它们送
至前台进程组：
•中断字符(一般采用DELETE或Ctrl+C)产生SIGINT。
•退出字符(一般采用Ctri+\)产生SIGQUIT。
•挂起字符(一般采用Ctrl+Z)产生SIGTSTP。
第18章中将说明可将这三个字符更改为用户选择的其他字符，以及如何使终端驱动程序不处理
这些特殊字符。
终端驱动程序必须处理与作业控制有关的另一种情况。我们可以有一个前台作业和若干个
后台作业，这些作业中哪一个接收我们在终端上键入的字符呢？只有前台作业接收终端输入。
如果后台作业试图读终端，那么这并不是一个错误，但是终端驱动程序将检测这种情况，并且
向后台作业发送一个特定信号SIGTTIN。该信号通常会暂时停止此后台作业，而shell则向有关
用户发出这种情况的通知，然后用户就可用shell命令将此作业转为前台作业运行，于是它就可
读终端。下列操作过程演示了这一点：
在后台启动，但将从标准输入读
$ cat > temp.foo &
[1] 1681
$
[1] + Stopped (SIGTTIN)
$ fg %1
cat > temp.foo
hello, world
"D
$ cat temp.foo
hello, world
键入回车
cat > temp.foo&
使i号作业成为前台作业
shell告诉我们现在哪一个作业在前台
输入1行
键入文件结束符
检査该行已送入文件
shell在后台启动cat进程，但是当cat试图读其标准输入(控制终端)时，终端驱动程序 知道它是个后台作业，于是将SIGTTIN信号送至该后台作业。shell检测到其子进程的状态改变 (回忆8.6节中对wait和waitpid的讨论)，并通知我们该作业已被停止。然后，我们用shel啲 fg命令将此停止的作业送入前台运行(关于作业控制命令，例如fg和bg的详细情况，以及标 识不同作业的各种方法，请参阅有关shell的手册页)。这样做可以使shell将此作业置入前台进程 组(tcsetpgrp),并将继续信号(SIGC0NT)送给该进程组。因为该作业现在位于前台进程 组中，所以它可以读控制终端。
如果后台作业输出到控制终端又将发生什么呢？这是一个我们可以允许或禁止的选项。通 常，可以用stty(l)命令改变这一选项(第18章将说明在程序中如何改变这一选项)。下面显示

 
224 第9幸进程关系
了这种工作方式:
$ cat temp.foo &
[1]	1719
$ hello, world
[1] + Done	cat
$ stty tostop $ cat tamp.foo &
[1]	1721
$
[1] + Stopped(SIGTTOU) $ fg %X cat temp.foo hello, world
在后台执行
提示符后出现后台作业的输出 键入回车 temp.foo &
禁止后台作业输出至控制终端 在后台再试一次
键入回车，发现作业已停止 cat temp.foo &
在前台恢复停止的作业
shell告诉我们现在哪一个作业在前台
这是该作业的输出
在用户禁止后台作业写到控制终端时，cat命令将阻止该作业试图写到其标准输出，因为 终端驱动程序将该写操作标识为来自于后台进程，于是向该作业发送SIGTTOU信号。与上面的 例子一样，当用户使用shell的fg命令将该作业带至前台时，该作业继续执行直至完成。
图9-8总结了前面已说明的作业控制的某些功能。穿过终端驱动程序框的实线表示：终端 I/O和终端产生的信号总是从前台进程组连接到实际终端。对应于SIGTTOU信号的虚线表示， 后台进程组进程的输出是否出现在终端是可选的。
前台进程组
终端驱
init 或 inetd
会话
图9-8具有前台、后台作业以及终端驱动程序的作业控制功能总结

 
9.9 shell执行程序 225
是否需要作业控制是一个有争议的话题。作业控制是在窗口终端广泛得到应用之前设计和 实现的。很多人认为设计得好的窗口系统已经免除了对作业控制的需要。某些人抱怨作业控制 的实现要求得到内核、终端驱动程序、shell以及某些应用程序的支持，是吃力不讨好的事情。 某些人在窗口系统中使用作业控制，他们认为两者都需要。不管你的意见如何，作业控制都是 POSIX.1要求的功能。
9.9	shell执行程序
让我们研究-下shell是如何执行程序的，以及这与进程组、控制终端和会话等概念的关系。 为此，再次使用ps命令。
首先使用不支持作业控制的、在Solaris上运行的经典Bourne shell。如果执行
ps -o pid,ppid,pgid,sid,comm
则其输出为
PID PPID PGID SID COMMAND 949 947 949 949 sh 1774 949 949 94 9 ps
ps命令的父进程是shell，这正是我们所期望的。shell和ps命令两者位于同一会话和前台进程组 (949)中。因为我们是用一个不支持作业控制的shell执行命令时得到该值的，所以称949为前 台进程组。
某些平台支持一个选项，它使ps(l)命令打印与会话控制终端相关联的进程组ID。该值显示在 TPGID列中。不幸的是，ps命令的输出在各个UNIX版本之间有所不同。例如，Solaris 9不支持该选项。
在FreeBSD 5.2.1 和Mac OS X 10.3中，命令
ps -o pid#ppid,pgid, sess,tpgid,command
在Linux 2.4.22中，命令
ps -o pid, ppid,pgrp, Bess ion, tpgid, comm
都会准确打印我们想要的信息。
注意，将进程与终端进程组ID (TPGID列)关联起来有占、用网不当。进程并没有终端进程控制组， 进程属于一个进程组，而进程组属于一个会话。会话可能有也可能没有控制终端。如果它确实有一个 控制终端，则此终端设备知道其前台进程的进程组ID。这个值可以用tcsetpgrpA数在终端驱动程序 中设置(见图9-8)。前台进程组ID是终端的一个属性，而不是进裎的属性。取自终端设备驱动程序的 该值是ps在TPGID列中打印的值。如果ps发现此会活没有控制终端，则它在该列打印一1。
如果在后台执行该命令：
ps -o pid,ppid,pgid# sid,comm &
则唯一改变的值是命令的进程ID。
PID PPID PGID SID COMMAND 949 947 949 949 sh 1812 949 949 949 ps
因为这种shell不知道作业控制，所以后台作业没有构成另一个进程组，也没有从后台作业处取 走控制终端。
现在看一看Bourne shell如何处理管道线。执行命令
ps -o pid,ppid,pgid,sid,comm | catl
时其输出是

 
226 第9章进程关系
PID	PPID	PGID	SID	COMMAND
949	947	949	949	sh
1823	949	949	949	catl
1824	1823	949	949	ps
(程序catl只是标准cat程序的一个副本，但名字不同。本节还将使用cat的另一个名为cat2
的副本。在一个管道线中使用两个cat副本时，不同的名字可使我们将它们区分开来。)注意，
管道线中的最后一个进程是shell的子进程，该管道线中的第一个进程则是最后一个进程的子进
程。从中可以看出，shell fork—个它自身的副本，然后此副本再为管道线中的每条命令各
fork—个进程。
如果在后台执行此管道线：
ps -o pid,ppid#pgid,sid,comm | catl &
则只有进程ID改变了。因为shell并不处理作业控制，后台进程的进程组ID仍是949，如同会话 的进程组ID—样。
如果一个后台进程试图读其控制终端，则会发生什么呢？例如，若执行：
cat > temp.foo &
在有作业控制时，后台作业被放在后台进程组中，如果后台作业试图读控制终端，则会产生信 号SIGTTIN。在没有作业控制时，其处理方法是：如果该进程自己没有重定向标准输入，则 shell自动将后台进程的标准输入重定向到/dev/null。读/dev/null则产生一个文件结束。 这就意味着后台cat进程立即读到文件尾，并正常结束。
上面说明了对后台进程通过其标准输入访问控制终端的适当的处理方法，但是，如果一个 后台进程打开/dev/tty并且读该控制终端，又将怎样呢？对此问题的回答是“看情况”。但 是这很可能不是我们所期望的。例如：
crypt < salaries | lpr &
就是这样一条管道线。我们在后台运行它，但是crypt程序打开/dev/tty,更改终端的特性 (禁止回送)，然后读该设备，最后重置该终端特性。当执行这条后台管道线时，crypt在终端 上打印提示符“Password:”，但是shell读取了我们所输人的加密口令，并试图执行以加密口令 为名称的命令。我们输送给shell的下一行则被crypt进程取为口令行，于是不能正确对文件加密， 结果将一堆无用信息送到了打印机。在这里，我们有了两个进程，它们试图同时读同一设备， 其结果则依赖于系统。前面说明的作业控制以较好的方式处理一个终端在多个进程间的复用。
返回到Bourne shell实例，如果在一条管道线中执行三个进程，我们就可以检验Bourne shell 使用的进程控制方式：
ps -o pid,ppid,pgid,sid,comm | catl | cat2
其输出为
PID	PPID	PGID	SID	COMMAND
949	947	949	949	sh
1988	949	949	949	cat2
1989	1988	949	949	ps
1990	1988	949	949	catl
如果在你的系统上，	输出的命令名不正确，
输出：
PID	PPID	PGID	SID COMMAND
949	947	949	949 s]	h
1831	949	949	949 si	h

 
9.9 shell执行程序 227
1832	1831 949 949 ps
1833	1831 949 949 eh
造成此种结果的原因是，ps进程与shell产生竞争条件，shell创建一个子进程并由它执行cat命令。在这 种情况下，当ps已经获得进程列表并打印时，shell尚未完成exec调用。
再重申一遍，该管道线中的最后一个进程是shell的子进程，而执行管道线中其他命令的进 程则是该最后一个进程的子进程。图9-9显示了所发生的情况。因为该管道线中的最后一个进程 是登录shell的子进程，当该进程(cat2)终止时，shell得到通知。
	sh	exec	PS
	(1989)		(1989)
sh	fork	sh	, i管道线
(949)		(1988)	、、尤 :
sh	exec	catl
(1990)		(1990)
cat2
(1988)
图9-9 Bourne shell调用管道线ps I catl I cat2时的进程
现在让我们用一个运行在Linux上的作业控制shell来检验同一个例子。这将显示这些shell处 理后台作业的方法。在本例中将使用Boume-again shell,用其他作业控制shell得到的结果几乎
完全一样。
ps -o pid, ppid, pgrp, session, tpgid, corrrm
其输出为
PID	PPID	PGRP	SESS TPGID COMMAND
2837	2818	2837	2837 5796 bash
5796	2837	5796	2837 5796 ps
(从本例开始，以粗体显示前台进程组。)我们立即看到了与Bourne shell例子的区别。Boume- again shell 将前台作业 (ps)放入它自己的进程组(5796)中。ps命令是组长进程，并是该进 程组中的唯一进程。
进一步讲，此进程组具有控制终端，所以它是前台进程组。我们的登录shell在执行ps命令 时是后台进程组。但需要注意的是，这两个进程组2837和5796都是同一会话的成员。事实上， 在本节的各实例中会话决不会改变。
在后台执行此进程：
ps -o pid,ppid,pgrp,session,tpgid,comm &
其输出为
PID	PPID	PGRP	SESS TPGID COMMAND
2837	2818	2837	2837 2837 bash
5797	2837	5797	2837 2837 ps
再一次，PS命令被放入它自己的进程组中，但是此时进程组(5797)不再是前台进程组，而是 一个后台进程组。TPGID 2837指示前台进程组是用户的登录shell。

 
228 第9章进程关系
SESS	TPGID COMMAND
2837	2837 bash
2837	2837 ps
2837	2837 cat!
PID
2837
5801
5802
注意，如果使用的Shell不同，那么它创建各个进程的顺序也可能不同。
9.10孤儿进程组
我们曾提及，一个其父进程已终止的进程称为孤儿进程(orphan process),这种进程由 init进程“收养”。现在我们要说明整个进程组也可成为“孤儿”，以及POSIX.1如何处理它。
考虑一个进
进程组2837
会话
考虑一个进程，它fork了一个子进程然后终止。这在系统中是经常发生的，并无异常之处,
但是在父进程终止时，如果该子进程停止(用作业控制)，
则会发生什么情况呢？子进程如何继续，以及子进程是
否知道它已经是孤儿进程？图9-10显示了这种情形：父进
H1]程已经fork了子进程，该子进程停止，父进程则将退出。
产生这种情形的程序示于程序清单9-1中。下面要说
明该程序的某些新特征。这里，假定使用了一个作业控
制shell。回忆前面所述，shell将前台进程放在它(指前
台进程)自已的进程组(本例中是6099)中，shell则留
在自己的进程组(2837)内。子进程继承其父进程
(6099)的进程组。在fork之后：
•父进程休眠5秒钟，这是一种让子进程在父进程终
止之前运行的一种权宜之计。
•子进程为挂断信号(SIGHUP)建立信号处理程序。图9_10将要成为孤儿的进程组实例 这样就能观察到SIGHUP信号是否已发送到子进程。(第10章将讨论信号处理程序。)
•子进程用kill函数向其自身发送停止信号(SIGTSTP)。这停止了子进程，类似于用终端 挂起字符(Ctrl+Z)停止一个前台作业。
 
进程组6099
按下列方式在一个管道线中执行两个进程：
ps -o pid,ppid,pgrp,session,tpgid,comm | catl
其输出为
PID	PPID	PGRP	SESS	TPGID	COMMAND
2837	2818	2837	2837	5799	bash
5799	2837	5799	2837	5799	ps
5800	2837	5799	2837	5799	catl
两个进程ps和catl都在一个新进程组(5799)中，这是一个前台进程组。在本例和类似的 Ml Bourne shell实例之间能看到另一个区别。Bourne shell首先创建将执行管道线中最后一条命令的 进程，而此进程是第一个进程的父进程。在这里，Bourae-again Shell是两个进程的父进程。但 是，如果在后台执行此管道线：
ps -o pid,ppid#pgrp,session,tpgid,comm | catl &
其结果是类似的，但是ps和catl现在都处于同一后台进程组中。
PGRP
2837
5801
5801
PPXD
2818
2837
2837

 
9.10孤儿进程组 229
•当父进程终止时，该子进程成为孤儿进程，所以其父进程ID成为1，也就是init进程ID。 •现在，子进程成为一个孤儿进程组的成员。POSIX.1将孤儿进程组(orphaned process group)定义为：该组中每个成员的父进程要么是该组的一个成员，要么不是该组所属会 话的成员。对孤儿进程组的另一种描述如下：一个进程组不是孤儿进程组的条件是，该 组中有一个进程，其父进程在属于同一会话的另一个组中。如果进程组不是孤儿进程组， 那么在属于同一会话的另一个组中的父进程就有机会重新启动该组中停止的进程。在这 里，进程组中每一个进程的父进程(例如，进程6100的父进程是进程1)都属于另一个会 话。所以此进程组是孤儿进程组。
•因为在父进程终止后，进程组成为孤儿进程组，P0SIX.1要求向新的孤儿进程组中处于停 止状态的每一个进程发送挂断信号(SIGHUP),接着又向其发送继续信号(SIGC0NT)。 •在处理了挂断信号后，子进程继续。对挂断信号的系统默认动作是终止该进程，为此必 须提供一个信号处理程序以捕捉该信号。因此，我们期望sig—hup函数中的printf会 在pr_ids函数中的printf之前执行。
	程序清单9-1创建一个孤儿进程组	
#include "apue.h"
#include <errno.h>
static void s ig_hup(int signo)
{ _
printf("SIGHUP received, pid = %d\n", getpid())?
}
static void
pr 一ids(char *name)
{ _
printf("%s： pid = %d, ppid = %d, pgrp = %d, tpgrp = %d\n",
name, getpidO , getppidO • getpgrp () , tcgetpgrp (STDIN_FXLENO))； fflush(stdout)/
int
main(void)
{
char c； pid一t pid;
pr—ids("parent")； if一((pid = fork() ) < 0) { err_sys("fork error")；
•} else if (pid > 0) { /* parent */
sleep(5)；	/* sleep to let child stop itself */
exit(0);	/* then parent exits */
} else {	/* child */
pr一ids("child");
signal(SIGHUP, sig—hup); /* establish signal handler ★/ kill(getpid(), SIGTSTP); /* stop ourself */ pr_ids("child"); /* prints only if we're continued ★/ if (read(STDIN-FILENO, &c# 1) != 1)
printf("read error from controlling TTY, errno = %d\n", errno)；
exit(0)；

 
230 第9章进程关系
283	 I
284
下面是程序清单9-1的输出：
$ ./a.out
parent： pid = 6099, ppid = 2837, pgrp = 6099, tpgrp = 6099 child： pid = 6100, ppid = 6099, pgrp - 6099, tpgrp = 6099 $ SIGHUP received, pid = 6100
child： pid = 6100, ppid - 1, pgrp = 6099, tpgrp = 2837 read error from controlling TTY, errno = 5
注意，因为两个进程即登录shell和子进程都写向终端，所以shell提示符和子进程的输出一起出 现。正如我们所期望的那样，子进程的父进程ID变成1。
在子进程中调用pr_ids后，程序试图读标准输入。正如前述，当后台进程组试图读控制 终端时，则对该后台进程组产生SIGTTIN。但在这里，这是一个孤儿进程组，如果内核用此信 号停止它，则此进程组中的进程就再也不会继续。POSIX.1规定，在这种情形下read返回出错， 并将其errno设置为EIO (在作者所用的系统中其值是5)。
最后，要注意的是父进程终止时，子进程被置入后台进程组中，因为父进程是由shell作为 前台作业执行的。	口
在19.5节的pty程序中将会看到孤儿进程组的另一个例子。
9.11	FreeBSD 实现
上面说明了进程、进程组、会话和控制终端的各种属性，值得观察一下所有这些是如何实 现的。下面简要说明FreeBSD的实现。SVR4实现的某些详细情况则请参阅WilliamS[1989]。图
9-	11显示了 FreeBSD使用的各种有关数据结构。
tty结构
session 结构
画
图9-11会话和进程组的FreeBSD实现

 
9.12 小 结 231
下面说明图9-11中标出的各个字段。从session结构开始。每个会话都分配一个session 结构(例如，每次调用setsid时)。
•	S_count是该会话中的进程组数。当此计数器减至0时，则可释放此结构。
•	s-leader是指向会话首进程proc结构的指针。
•	s_ttyvp是指向控制终端vnode结构的指针。
•	s_ttyp是指向控制终端tty结构的指针。
•	s_sid是会话ID。请记住会话ID这一概念并非Single UNIX Specification的组成部分。
在调用sets id时，在内核中分配一个新的会话结构。现在s_count设置为1, s_leader
设置为调用进程proc结构的指针，s_sid设置为进程ID,因为新会话没有控制终端，所以 s_t	s_t typ设置为空指针。
接着说明tty结构。每个终端设备和每个伪终端设备均在内核中分配这样一种结构(第19 章将对伪终端作更多说明)。
•	t_session指向将此终端作为控制终端的session结构(注意，tty结构指向session 结构，session结构也指向tty结构)。终端在失去载波信号时使用此指针将挂断信号送 给会话首进程(见图9-7)。
•	t_pgrp指向前台进程组的pgrp结构。终端驱动程序用此字段将信号送至前台进程组。
由输入特殊字符(中断、退出和挂起)而产生的三个信号被送至前台进程组。
•	t_termiOS是包含所有这些特殊字符以及与该终端有关信息(例如，波特率、回送打开 或关闭等)的结构。第18章将回过头来说明此结构。
•	t_winsize是包含终端窗口当前尺寸的winsize结构。当终端窗口尺寸改变时，信号 SIGWINCH被送至前台进程组。18.12节将说明如何设置和获取终端的当前窗口尺寸。
注意，为了找到特定会话的前台进程组，内核不得不从session结构开始，然后用 s_ttyp得到控制终端的tty结构，接着用t_pgrp得到前台进程组的pgrp结构。pgrp结构包 含一特定进程组的信息。其中各相关字段是：
•	pg_id是进程组ID。
•	pg_session指向此进程组所属会话的session结构。
•pg_members是指向作为此进程组成员的p roc结构列表的指针。proc结构中的口_ pglist结构是一个双向链表项，它同时指向此组中的下一个进程和前一个进程，依此类® 推，直到进程组中最后一个进程的proc结构中遇到一个空指针。 proc结构包含一个进程的所有信息。
•	p_pid包含进程ID。
•	P_PPtr是指向父进程proc结构的指针。
•	P_Pgrp指向本进程所属进程组的pgrp结构的指针。
•如前所述，p_pglist是一个结构，其中包含两个指针，分别指向进程组中的前一个进 程和下一个进程。
最后还有一个vnode结构。在打开控制终端设备时分配此结构。进程对/dev/tty的所有 引用都通过vnode结构。图9-11中显示实际i节点是V节点的一部分。
9.12	小结
本章说明了进程组之间的关系——会话，它由若干个进程组组成。作业控制是当今很多

 
232 第9章进程关系
UNIX系统所支持的功能，本章说明了它是如何由支持作业控制的shell实现的。在这些进程关 系中也涉及到了进程的控制终端/dev/tty。
所有这些进程的关系都使用了很多信号方面的功能。下一章将详细讨论UNIX中的信号 机制。
习题
9.1考虑6.8节中说明的utmp和wtmp文件，为什么注销记录是由init进程编写的？对于网络登 录的处理与此相同吗？
9.2编写一小段程序，要求调用fork并使子进程建立一个新的会话。验证子进程变成了进程 组组长且不再具有控制终端。

 

