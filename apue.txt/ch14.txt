第14章
高级I/O
14.1引言
本章内容包括非阻塞I/O、记录锁、系统V流机制、I/O多路转接(select和poll函数)、 readv和writev函数以及存储映射I/O (rmnap),这些都称为高级I/O。第15章、第17章中的进 程间通信，以及以后各章中的很多实例都要使用本章所描述的概念和函数。
14.2非阻塞I/O
10.5节中曾将系统调用分成“低速”系统调用和其他系统调用两类。低速系统调用是可能 会使进程永远阻塞的一类系统调用，它们包括下列调用：
•如果某些文件类型(例如管道、终端设备和网络设备)的数据并不存在，则读操作可能 会使调用者永远阻塞。
•如果数据不能立即被上述同样类型的文件接受(由于在管道中无空间、网络流控制等)， 则写操作也会使调用者永远阻塞。
•在某种条件发生之前，打开某些类型的文件会被阻塞(例如打开一个终端设备可能需等 到与之连接的调制解调器应答< 又例如在没有其他进程已用读模式打开该FIFO时若以只 写模式打开FIFO,那么也要等待)。
•对已经加上强制性记录锁的文件进行读、写。
•某些ioctl操作。
•某些进程间通信函数(见第15章)。
我们也曾说过，虽然读、写磁盘文件会使调用者在短暂时间内阻塞，但并不能将与磁盘i/o 有关的系统调用视为“低速”。
非阻塞I/O使我们可以调用open、reac^Pwrite这样的I/O操作，并使这些操作不会永远 阻塞。如果这种操作不能完成，则调用立即出错返回，表示该操作如继续执行将阻塞。
对于一个给定的描述符有两种方法对其指定非阻塞i/o:
⑴如果调用open获得描述符，则可指定0_N0NBL0CK标志(见3.3节)。
(2)对于已经打开的一个描述符，则可调用fcntl,由该函数打开0_N0NBL0CK文件状态 标志(见3.14节)。程序清单3-5中的函数可用来为一个描述符打开任一文件状态标志。
系gv的早期版本使用标志CLNDELAY指定非阻塞方式。在这些版本中，如果无数据可读，则read 返回值0。而UNIX系统又常将read的返回值0解释为文件结束，两者有所混淆。因此POSIX.1提供了一
[4411

 
356 第14章高级I/O
个名字和语义都与O一NDELAY不同的非阻塞标志。确实，在系统V的早期版本中，当从read得到返回值 0时，我们并不知道该调用是否阻塞了或已到文件结尾处。POSIX.1要求，对于一个非阻塞的描述符如 果无数据可读，则read返回-1,并且errno祓设置为EAGAIN。系统V派生的某些平台支持较老的 0_NDELAY和POSIX.1的O一NONBLOCK两者，但在本书的实例中只使用POSIX.1的规定。0_NDELAY只是 为了向后兼容，不应在新应用程序中使用。
4.3BSD为fcntl提供了 FNDELAY标志，其语义也稍有区别。它不只影响描述符的文件状态标志， 还将终端设备或套接字的标志更改成非阻塞的，因此不仅影响疟享同一文件表项的用户，而且对终端 或套接字的所有用户起作用(4.3BSD非阻塞I/O只对终端和套接字起作用)。另外’如果对一个非阻塞 描述符的操作不能无阻塞地完成，那么4.3BSD返回EWOULDBLOCK。现今，基于BSD的系统提供 POSIX. 1的O—NONBLOCK标志，并且将EWOULDBLOCK定义为与POSIX. 1的EAGAIN相同。这些系统提供与 其他依从POSIX系统相一致的非阻塞语义。文件状态标志的更改影响同一文件表项的所有用户，但与 通过其他文件表项对同一设备的访问无关(参见图3-1和图3-3)
实例
程序清单M-1是一个非阻塞I/O的实例’它从标准输入读500 000字节，并试图将它们写到 标准输出上。该程序先将标准输出设置为非阻塞的，然后用for循环进行输出，每次write调 用的结果都在标准出错上打印。函数clr-fl类似于程序清单3-5中的set_fl,但与set_fl的 功能相反，它清除1个或多个标志位。
程序清单14-1长的非阻塞write
^include "apue.h"
#include <ermo.h>
^include <fcntl.h>
char buf[500000]；
int
main (void)
{
int ntowrite, nwrite； char *ptr；
ntowrite = read(STDIN_FILENO, buf, sizeof(buf)}; fprintf(stderr, "read %d bytes\n", ntowrite)；
set_f1(STD0UT_FILEN0# 0_N0NBL0CK); /* set nonblocking */
ptr = buf;
while (ntowrite > 0) { errno - 0；
nwrite = write(STD0UT_FILEN0, ptr, ntowrite)； fprintf(stderr, "nwrite = %d, errno = %d\n", nwrite, errno)；
if (nwrite > 0) { ptr += nwrite； ntowrite -= nwrite；

 
14.3记录销 357
clr—fl(STDOUT 一FILENO, 0—NONBLOCK); /* clear nonblocking */ exit(0)7
若标准输出是普通文件，则可以期望write只执行一次:
$ 1b -1 /•tc/t«rmcap
-rw-r--r-- 1 root 702559 Feb 23
$ ./a.out < /atc/t«rmcap > ton^).£il«
read 500000 bytes
nwrite = 500000, errno = 0
500000 Jul
打印文件长度
2002 /etc/termcap
先试一普通文件
一次写
检验输出文件长度 04:19 temp.file
但是，若标准输出是终端，则期望write有时会返回小于500000的一个数字，有时则出错返回。
下面是在一个系统上运行上述程序的结果：	dU
$ ./a.out < /•tc/t«rmcap 2>std«rr.out
$ cat stderr.out
read 500000 bytes 、
输出至终端 大置输出至终端-
te = 216041, errno = te = -1, errno * 11
te = 16015, errno = te = -1, errno ^ 11
te = 32081, errno = te = -1, errno - 11
te = 48002, errno = te = -1, errno = 11
nwrite = 7949, errno
这种错1497次.■
这种错1 856次•_ 这种错1 654次 这种错1 460次•_
等等
在该系统上，errno值11对应的是EAGAIN。终端驱动程序一次接收的数据量随系统而变。根 据你登录系统时所使用的不同方式——是在系统控制台上登录，还是在硬接线的终端上登录， 或是用伪终端在网络连接上登录——该程序运行的结果也不同。如果你在终端上在运行一窗口 系统，那么也是经由伪终端设备与系统交互。	□
在此实例中，程序发出了数千个write调用，但是只有10-20个左右是真正输出数据的， 其余的则出错返回。这种形式的循环称为轮询，在多用户系统上它浪费了CPU时间。14.5节将 介绍非阻塞描述符的I/O多路转接，这是进行这种操作的一种比较有效的方法。
有时，我们可以将应用程序设计成使用多线程(见第11章)，从而避免使用非阻塞I/O。如 若我们能在其他线程中继续进展，则可以允许某个线程在I/O调用中阻塞。这种方法有时能简化 应用程序的设计(见第21章)，但是线程间同步的开销有时却可能增加复杂性，于是导致得不 偿失的后果。
14.3记录锁
若两个人同时编辑一个文件，其后果将如何呢？在很多UNIX系统中，该文件的最后状态

 
358 第14章高级I/O
取决于写该文件的最后一个进程。但是对于有些应用程序(例如数据库)，进程有时需要确保 它正在单独写一个文件。为了向进程提供这种功能，商用UNIX系统提供了记录锁机制。(第20 章我们开发了一个使用记录锁的数据库函数库。)
记录锁(record locking)的功能是：当一个进程正在读或修改文件的某个部分时，它可以 阻止其他进程修改同一文件区。对于UNIX系统而言，“记录”这个词是一种误用，因为UNIX 系统内核根本没有使用文件记录这种概念。更适合的术语可能是字节范围锁(byte-range locking),因为它锁定的只是文件中的一个区域(也可能是整个文件)。
1.历史
对早期UNIX系统的一种批评是它们不能用来运行数据库系统，其原因是这些系统不支持 部分地对文件加锁。在UNIX系统开始进入商用计算领域时，很多系统开发小组以各种不同方 式增加了对记录锁的支持。
早期的伯克利版本只支持flock函数。该函数锁整个文件，不能锁文件中的一部分。
SVR3通过fcntl函数增加了记录锁功能。在此基础上构造了lockf函数，它提供了一个 简化的接口〃这些函数允许调用者锁一个文件中任意字节数的区域，长至整个文件，短至文件 中的一个字节。
POSIX.1标准的基础是fcntl。表14-1列出了各种UNIX系统提供的不同形式的记录锁。注 意，Single UNIX Specification在其XSI扩展中包括了lockf。
表14-1各种UNIX系统支持的记录锁形式
系统	建议性	强制件	fcntl	lockf	flock
SUS				XSI	
FreeBSD 5.2.1				•	鲁
Linux 2.4.22		•		.	•
Mac OS X 丨 0.3				•	•
Solaris 9		•		•	•
本节最后部分将说明建议性锁和强制性锁之间的区别。本书只介绍POSIX.1的fcntl锁。
汜录销是1980年由John Bass最早加到V7上的。内核中相应的系统调用入口项是名为locking的函 数，此函数提供了强制性记录销功能，它被用在很多System III版本中。Xenix系统采用了此函数，某 些基于Intel的系统V派生版本(例如OpenServer5),在Xenix兼容库中仍旧支持该函数
2.	fcntl记录锁
3.	M节中已经给出了fcntl函数的原型，为了叙述方便，这里再重复一次。
^include <fcntl.h>	
int fcntl (int filedes, int cmd, •	• ■ /* struct flock *flockptr */ )；
返回值：若成功则依赖于ornf (见下)，若出错则返回-1
对于记录锁，cm^^F_GETLK、F_SETLK^F_SETLKW。第三个参数(称其为flockptr)是一个 指向flock结构的指针：
struct flock {
short 1一type; /* F一RDLCK, F—WRLCK, or F_UNLCK */
off t 1 start； /* offset in bytes, relative to 1一 whence */

 
14.3记录铺 359
short 1一 whence; /* SEEK—SET, SEEK_CUR# or SEEK_END */ off_t l_len； /* length, in bytes； 0 means lock to EOF */ pid:t Ijpid; /* returned with F一GETLK */
一 _
对flock结构说明如下：
•所希望的锁类型：F_RDLCK (共享读锁)、F_WRLCK (独占性写锁)*F_UNLCK (解锁 一个区域)。
•要加锁或解锁区域的起始字节偏移量，这由l_start和l_whenCe两者决定。
•区域的字节长度，由l_len表示。
•具有能阻塞当前进程的锁，其持有进程的ID存放在l_pid中(仅由F_GETLK返回)。
关于加锁和解锁区域的说明还要注意下列各点：
•	l_stat是相对偏移量(字节)，l_whence则决定了相对偏移量的起点。这与lseek函 数(见3.6节)中最后两个参数类似。确实，l_whence可选用的值是SEEK_SET、 SEEK_CUR 或 SEEK_END。
•该区域可以在当前文件尾端处开始或越过其尾端处开始，但是不能在文件起始位置之前 开始。
•如若l_len为0,则表示锁的区域从其起点(由l_start和l_whence决定)开始直至最 大可能偏移量为止，也就是不管添写到该文件中多少数据，它们都处于锁的范围内(不 必猜测会有多少字节被追加到文件之后)。
•为了锁整个文件，我们设置l_start和l_whenCe，使锁的起点在文件起始处，并且说 明长度(l_len)为0。(有多种方法可以指定文件起始处，但常用的方法是将1 _start 指定为0，l_whence指定为SEEK_SET。)
上面提到了两种类型的锁：共享读锁(l_typeSF_RDLCK)和独占写锁(F_WRLCK)。 基本规则是：多个进程在一个给定的字节上可以有一把共享的读锁，但是在一个给定字节上只 能有一个进程独用的一把写锁。进一步而言，如果在一个给定字节上已经有一把或多把读锁， 则不能在该字节上再加写锁，如果在一个字节上已经有一把独占性的写锁，则不能再对它加任 何读锁。在表14-2示出了这些规则。
表14-2不同类型锁之间的兼容性
请求
	读锁	写锁
无锁	允许	允许
一个或多个读锁	允许	拒绝
一个写锁	拒绝	拒绝
上面说明的兼容性规则适用于不同进程提出的锁请求，并不适用于单个进程提出的多个锁 请求。如果一个进程对一个文件区间已经有了一把锁，后来该进程又企图在同一文件区间再加 一把锁，那么新锁将替换老锁。例如，若一进程在某文件的16~32字节区间有一把写锁，然后 又试图在16~32字节区间加一把读锁，那么该请求将成功执行(假定其他进程此时并不试图向 该文件的同一区间加锁)，原来的写锁被替换为读锁。
加读锁时，该描述符必须是读打开，加写锁时，该描述符必须是写打开。
以下说明fcntl函数的三种命令：
[446]

 

360 第14章高级I/O
F一GETLK 判断由flockptr所描述的锁是否会被另外一把锁所排斥(p且塞)。如果存在 一把锁，它阻止创建由flockptr所描述的锁，则把该现存锁的信息写到 flockptr指向的结构中。如果不存在这种情况，则除了将l_type设置为 F_UNLCK之外，flockptr所指向结构中的其他信息保持不变。
F-SETLK 设置由flockptr所描述的锁。如果试图建立一把读锁(1 —type设为 F_RDLCK)或写锁(l_type设为F_WRLCK)，而按上述兼容性规则不能允 许，则fcntl立即出错返回，此时errno设置为EACCES或EAGAIN。
虽然POSIX允许实现返回这两种出错代码中的任何一种，但本书说明的四种实现在锁请求不能得
到满足时，都返回EAGAIN^
此命令也用来清除由flockptr说明的锁(l_typeSF_UNLCK)。
F—SETLKW这是F_SETLK的阻塞版本(命令名中的W表示等待(wait))。如果因为当前 在所请求区间的某个部分另一个进程已经有一把锁，因而按兼容性规则由 flockptr所请求的锁不能被创建，则使调用进程休眠。如果请求创建的锁 已经可用，或者休眠由信号中断，则该进程被唤醒。
应当了解，测试能否建立一把锁，然后用F_SETLI^PF_SETLKW企图建立一把 锁，这两者不是一个原子操作。因此不能保证在这两次fcntl调用之间不会有另一个进程插入 并建立一把相关的锁，从而使原来测试到的情况发生变化。如果不希望在建立锁时可能产生的 长期阻塞，则应使并对返回结果进行测试，以判别是否成功地建立了所要求的锁。
注意，POSIX.I并没有说明在下列情况下将发生什么：一个进程在某个文件的一个区间上设置了 一把读锁，第二个进程试图对同一文件区间加一把写锁时阻塞，然后第三个进程则试图在同一文件区 间上得到另一把读销，如果第三个进程只是因为读区间已有一把读销，而破允许在该区间放置另一把 读锁，那么这种实现就可能会使希望加写销的进程饿死。这意味着，当对同一区间加另一把读销的请 求到达时’提出加写销而阻塞的进程需等待的时间延长了。如果加读锁的请求来得很频繁，使得该文 件区间始终存在一把或几把读锁，那么欲加写锁的进程就将等待很长时间。
在设置或释放文件上的锁时，系统按要求组合或裂开相邻区。例如，若字节100~199是加 锁的区，需解锁第150字节，则内核将维持两把锁，一把用于字节100~149,另一把用于字节 151~199。图14-1说明了这种情况。
100	199
字节100~199加锁后的文件
•第-个;	】第—个：
*加锁1	*加锁1
:范围：	1范围1 -* 1 ^ 1
00 149 151	199
字节150解锁后的文件 图14-丨文件字节范围锁

 
14.3记录锁 361
假定我们又对第150字节设置锁，那么系统将会把三个相邻的加锁区合并成一个区(从字 节100至199)。其结果如图14-1中的第一图所示，于是我们又回到了出发点。
实例：请求和释放一把锁
为了避免每次分配flock结构，然后又填入各项信息，可以用程序清单14-2中的函数 lock_reg来处理所有这些细节。
	程序清单14-2加锁和解锁一个文件区域的函数	
#include "apue.h"
#include <fcntl.h>
int
lock_reg(int fd, int cmd, int type, off—t offset, int whence, off一t len) struct flock lock;
lock.1一type = type;	/* F一RDLCK, F—WRLCK, F—UNLCK */
lock.l_start = offset； /* byte offset, relative to 1一whence */ lock•1一whence = whence; /* SEEK一SET, SEEK一CUR, SEEK—END */ lock.1一len = len；	/* #bytes (0 means to EOF) */
return(fcntl(fd, cmd, &lock))；
因为大多数锁调用是加锁或解锁一个文件区域(命令f_getlk很少使用)，故通常使用下 列5个宏，它们都定义在apue.h中(见附录B)。
#define read一lock(fd, offset, whence, len) \
lock_reg((fd), F_SETLK, F一RDLCK, (offset), #define readw一lock(fd, offset, whence# len) \
lock一reg((fd), F_SETLKW# F 一RDLCK, (offset), #define write_lock(fd, offset, whence, len) \
lock 一reg((fd), F—SETLK, F_WRLCK, (offset), #define writew一lock(fd, offset, whence, len) \
lock_reg((fd), F—SETLKW, FWRLCK, (offset)( #define unblock(fd, offset, whence, len) \
lock_reg((fd), F_SETLK, F_UNLCK# (offset),
(whence), (len):
(whence)# (len))
(whence), (len)) (whence), (len))
(whence), (len))
我们有目的地用与lseek函数同样的顺序定义这些宏中的前三个参数。
□
实例：测试一把锁
程序清单14-3中定义了一个函数lock—test,可用其测试一把锁。
	程序清单14-3测试一个锁状态的函数
#include "apue.h"
#include <fcntl.h>
pid_t
:一test(int fd.	int type,	off_t offset.	int whence(	,off	t len)
struct	flock	lock ；				
lock-l_	type =	:type；	/* F 一RDLCK or	F—WRLCK */		
lock.1	start	-offset;	/* byte offset	,relative	to 1_	whence
[448]
|449]

 
362 第14章高级I/O
lock.1一whence = whence; /* SEEK 一SET, SEEK 一CUR, SEEK一END */
lock.l_len = len；	/* #bytes (0 means	to EOF) */
if (fcntl(fd, F_GETLK# &lock) < 0) err 一sys("fcntl error")；
if (lock.l_type == F 一 UNLCK)
return(0)；	/* false, region isn't	locked by another proc */
return(lock.l_pid)； /* true, return pid of	lock owner */
如果存在一把锁，它阻塞由参数说明的锁请求，则此函数返回持有这把现存锁的进程ID， 否则此函数返回0。通常用下面两个宏来调用此函数(它们也定义在apue.h中)。
#define is_read_lockable(fd, offset, whencef len) \
(lock 一test((fd), F—RDLCK, (offset), (whence), (len)) == 0)
#define is一write一lockable(fd, offset, whence, len) \
(lock 一test((fd), F—WRLCK, (offset)# (whence), (len)) == 0)
注意，进程不能使用lock_test函数测试它自己是否在文件的某一部分持有一把锁。 F一GETLK命令的定义说明，返回信息指示是否有现存的锁阻止调用进程设置它自己的锁。因为 F_SETLK和F一SETLKW命令总是替换调用进程现存的锁(若已存在)，所以调用进程决不会阻 塞在自己持有的锁上，于是，F_GETLK命令决不会报告调用进程自己持有的锁。
实例：死锁
如果两个进程相互等待对方持有并且锁定的资源时，则这两个进程就处于死锁状态。如果 一个进程已经控制了文件中的一个加锁区域，然后它又试图对另一个进程控制的区域加锁，则 它就会休眠，在这种情况下，有发生死锁的可能性。
程序清单14-4给出了一个死锁的例子。子进程锁字节0，父进程锁字节1。然后，它们又都 试图锁对方已经加锁的字节。在该程序中使用了8.9节中介绍的父、子进程同步例程 (TELL_xxx和WAIT一xxx),使得每个进程能够等待另一个进程获得它设置的第一把锁。运行 程序清单H4所示程序得到：
$ ./a.out
parent： got the lock, byte 1 child： got the lock, byte 0
child： writew 一lock error： Resource deadlock avoided parent： got the lock, byte 0
	程序清单14-4死锁检测实例	
#include "apue.h"
#include <fcntl.h>
static void
lockabyte(const char *name, int fd, off—t offset)
if (writew_lock(fd, offset, SEEK-SET, 1) < 0) err 一sys("%s: writew_lock error", name)；
^ printf("%s: got the lock, byte %ld\n", name, offset)；
int
main (void)

 
14.3记录镝 363
int	fd;
pid_t pid；
*	Create a file and write two bytes to it. */
if ((fd = creat("templock", FILE—MODE)) < 0) err一sys("creat error")； if (write (fd, "ab11, 2)丨=2) err_sys("write error");
TELL—WAIT()t
if ((pid s fork()) < 0) { err一sys("fork error");
} else if (pid == 0) {	/* child */
lockabyte("child", fd, 0);
TELL_PARENT(getppid());
WAIT_PARENT();
lockabyte ("child11, fd, 1);
} else {	/* parent */
lockabyte("parent", fd, 1)； TELL_CHILD(pid);
WAIT~CHILD();
lockabyte("parent", fd, 0);
}
exit(0)/
检测到死锁时，内核必须选择一个进程接收出错返回。在本实^^中选择了子进程，这是一 个实现细节。在某些系统上，总是子进程接到出错信息,在另一些系统上，总是父进程接到出 错信息。在某些系统上，当试图使用多把锁时，有时是子进程接到出错信息，有时则是父进程 接到出错信息。	口 _
3.锁的期I含继承和释放
关于记录锁的自动继承和释放有三条规则：
(1)	锁与进程和文件两方面有关。这有两重含义：第一重很明显，当一个进程终止时，它 所建立的锁全部释放，第二重意思就不很明显，任何时候关闭一个描述符时，则该进程通过这 一描述符可以引用的文件上的任何一把锁都被释放(这些锁都是该进程设置的)。这就意味着 如果执行下列四步：
fdl = open(pathname, •••); read—lock(fdl, ♦•.}; fd2 = dup(fdl); close(fd2);
则在close (fd2)后，在fdl上设置的锁被释放。如果将dup换为open,以打开另一描述符上 的同一文件，其效果也一样：
fdl ~ open{pathname,...); read—lock(fdl,...); fd2 = open(pathname, •••) close(fd2)；
(2)	由fork产生的子进程不继承父进程所设置的锁。这意昧着，若一个进程得到一把锁，
然后调用fork,那么对于父进程获得的锁而言，子进程被视为另一个进程，对于从父进程处

 
364 第14幸高级I/O
fdfc志文件指针
继承过来的任一描述符，子进程需要调用fcntl才能获得它自己的锁。这与锁的作用是相一致 的。锁的作用是阻止多个进程同时写同一个文件(或同一文件区域)》如果子进程继承父进程 的锁，则父、子进程就可以同时写同一个文件。
(3)在执行exec后，新程序可以继承原执行程序的锁。但是注意，如果对一个文件描述符 设置了close-on-exec标志，那么当作为exec的一部分关闭该文件描述符时，对相应文件的所有 锁都被释放了。
4.	FreeBSD的实现
先简要地观察FreeBSD实现中使用的数据结构。这会帮助我们进一步理解规则1:锁是与进 程、文件两者相关联的。
考虑一个进程，它执行下列语句(忽略出错返回)：
fdl = open(pathname,...);
write_lock(fdl# 0, SEEK一SET, 1)； /* parent write locks byte 0 */ if ((pid =： fork()) > 0)~{	/* parent */
fd2 - dup(fdl); fd3 - open(pathname, •••);
} else if (pid == 0) {
read一lock(fdl, 1, SEEK SET, 1)； /★ child read locks byte 1 */
} " — pause ()；
图14-2显示了父、子进程暂停后的数据结构情况。
父进程表项
文件表
 
图14-2关于记录锁的FreeBSD数据结构
图3-3和图8-1中已显示了open、fork以及dup后的数据结构。有了记录锁后，在原来的这 些图上新加了lockf结构，它们由i节点结构开始相互链接起来。注意，每个lockf结构说明了 一个给定进程的一个加锁区域(由偏移量和长度定义)。图中显示了两个lockf结构，一个是 由父进程调用write_lOCk形成的，另一个则是由子进程调用read_lOCk形成的。每一个结
f
fdl:
fd2:
fd3:	dfc志文件指电	
	,.,	
	
123
fdfdw

 
14.3记录镝 365
构都包含了相应进程ID。
在父进程中，关闭fdl、fd2和fd3中的任意一个都将释放由父进程设置的写锁。在关闭 这三个描述符中的任意一个时，内核会从该描述符所关联的i节点开始，逐个检査lockf链接表 中各项，并释放由调用进程持有的各把锁。内核并不清楚也不关心父进程是用哪一个描述符来 设置这把锁的。
 
在程序清单13-2中，我们了解到，守护进程可用一把文件锁以保证只有该守护进程的唯一副 本正在运行。程序清单14-5示出了lockfile函数的实现，守护进程可用该函数在文件上加锁。
	程序清单14-5在文件整体上加锁	
^include <unistd.h>
^include <fcntl.h>
int
lockfile(int fd)
{
struct flock f1 ;
fl.l一type = F_WRLCK; f1.1一start = 0； f1.1一whence = SEEK 一SET? f1.1一len 二 0;
return(fcntl(fd, F—SETLK, &f1));
另一种方法是，用呢1七6_10。1<：函数定义10。]<：：^；1^函数：
#define lockfile(fd) write_lock((fd)# 0, SEEK—SET, 0)	口
5.	在文件尾埔加锁
在接近文件尾端加锁或解锁时需要特别小心。大多数实现按照l_WhenCe的SEEK_CUR或 SEEK_END值，用l_Start以及文件当前位置或当前长度得到绝对文件偏移量。但是，常常需 要相对于文件的当前位置或当前长度指定一把锁。其原因是，我们在该文件上没有锁，所以不 能调用lseek以正确无误地获得加锁时的当前文件偏移量。(在lseek和加锁调用之间，另一 个进程可能改变该文件长度。)
考虑以下代码序列：
writew_lock(fd, 0, SEEK_END, 0)； write(fd, buf, 1)； un_lock(fd, 0, SEEK_END); write(fd, buf, 1)；
该代码序列所做的可能并不是你所期望的。它得到一把写锁，该写锁从当前文件尾端起，包括 以后可能添加到该文件的任何数据。假定在文件尾端时执行第一个write，它给文件添写了 1 个字节，而该字节将被加锁。跟随其后的解锁，其作用是对以后添写到文件上的数据不再加锁， 但在它之前刚添写的一个字节则保留加锁。当执行第二个写时，文件尾端又延伸了 1个字节， 但该字节并未加锁。由此代码序列造成的文件锁状态示于图14-3。
当对文件的一部分加锁时，内核将指定的偏移量变换成绝对文件偏移量。另外，除了指定 一个绝对偏移量(SEEK_SET)之外，fcntl还允许我们相对于文件中的某个点(当前偏移量
[4531
回

 
366 第14章高级I/O
(SEEK_CUR)或文件尾端(SEEK_END))指定该偏移量。当前偏移量和文件尾端是可能不断 变化的，而这种变化又不应影响现存锁的状态，所以内核必须独立于当前文件偏移量或文件尾 端而记住锁。
	卜臟	
第-次write后文件的状态 u _ 」	第一个字节 已写	
	锁住	
	r 觯	
; 第二次write后文件的状态 1
L _	第-个字节 已写	第二个字节 已写
图14-3文件范围锁
如果我们想解除第一次write所写1个字节上的锁，那么应指定长度为_1。负的长度值表 示在指定偏移量之前的字节数。
6.建议性锁和强制性锁
考虑数据库访问例程库。如果该库中所有函数都以一致的方法处理记录锁，则称使用这些 函数访问数据库的任何进程集为合作进程(cooperating process)。如果这些函数是仅有地用来 访问数据库的函数，那么它们使用建议性锁是可行的。但是建议性锁并不能阻止对数据库文件 有写权限的任何其他进程对数据库文件进行随意的写操作。没有使用被认可的方法(数据库函 数库)访问数据库的进程是一个非合作进程。
强制性锁使内核对每一个open、read和write系统调用都进行检查，检查调用进程对正 在访问的文件是否违背了某一把锁的作用。强制性锁有时也被称为强迫方式锁(enforcement- mode locking) 0
从表14-1看到，Linux 2.4.22和Solaris 9提供强制性记录镝，而FreeBSD 5.2.1和Mac OS X 10.3则不 提供。强制性记录镝不是Single UNIX Specification的组成部分。在Linux中，如果用户想要使用强制性 铺，则要在各个文件系统基础上，对mount命令用_omand选项打开该机制^
对一个特定文件打开其设置组ID位并关闭其组执行位，则对该文件开启了强制性锁机制 (回忆程序清单4-4)。因为当组执行位关闭时，设置组ID位不再有意义，所以SVR3的设计者借 用两者的这种组合来指定对一个文件的锁是强制性的而非建议性的。
如果一个进程试图读、写一个强制性锁起作用的文件，而欲读、写的部分又由其他进程力卩 上了读或写锁，此时会发生什么呢？对这一问题的回答取决于三方面的因素：操作类型 (read或write),其他进程保有的锁的类型(读锁或写锁)，以及有关描述符是阻塞还是非阻 塞的。表14-3列出了8种可能性。
除了表M-3中的read和write函数，其他进程持有的强制性锁也会对open函数产生影响。 通常，即使正在打开的文件具有强制性记录锁，该打开操作也会成功。后随的read或write 依从于表M-3中所示的规则。但是，如果欲打开的文件具有强制性记录锁(读锁或写锁)，而 且open调用中的flag指定为0_TRUNC或0_CREAT，则不论是否指定0_N0NBL0CK，open都

 
14.3记录锁 367
立即出错返回，errno设置为EAGAIN。
表14-3强制性锁对其他进程读.写的影响
其他进程在文件 区段中持有的	阻塞描述符，试图	非阻塞描述符，试图
现存锁的类型	read	write	read	write
读锁	允许	阻塞	允许	EAGAIN
写锁	阻塞	阻塞	EAGAIN	EAGAIN
只有Solaris对0_CREAT标志处理为出错。当打开一个具强制性锁的文件时，Linux允许指定 0_CREAT标志。对0_TRUNC标志产生open出错是有道理的，因为若其他进程对该文件持有读，写锁， 那么就不能将其截短为0。对0_CREAT标志在返回时也设置errno则无道理，因为该标志的意义是如果 该文件不存在则创建，由于其他进程对该文件持有记录锁，因而该文件肯定是存在的。
这种open的锁冲突处理方式可能导致令人惊异的结果。我们曾编写过一个测试程序，它 打开一个文件(其模式指定为强制性锁)，然后对该文件的整体设置一把读锁，然后进入休眠 一段时间。(回忆表14-3,读锁应当阻止其他进程写该文件。)在这段休眠时间内，用某些典型 的UNIX系统程序和操作符对该文件进行处理，发现下列情况：
•可用ed编辑程序对该文件进行编辑操作，而且编辑结果可以写回磁盘！强制性记录锁对 此毫无影响。用某些UNIX系统版本提供的系统调用跟踪特性，对ed操作进行跟踪分析发 现，ed将新内容写到一个临时文件中，然后删除原文件，最后将临时文件名改为原文件 名。强制性锁机制对unlink函数没有影响，于是这一切就发生了。
在Solans中，用truss(l)命令可以得到一个进程的系统调用跟踪信息，在FreeBSD和Mac OS X中， 则使ff] ktrace(l)和kduitp(l)命令。Linux提供strace(l)命令跟踪进程的系统调用。
•不能用vi编辑程序编辑该文件。vi可以读该文件，但是如果试图将新的数据写到该文件 中，则出错返回(EAGAIN)。如果试图将新数据添加到该文件中，贝Ijwrite阻塞。vi的 这种行为与所预料的一样。
•使用Komshel^：^》运算符重写或添写到该文件中，产生出错信息“cannot create”。 •在Bourne shell下使用>运算符出错，但是使用>>运算符则阻塞，在解除了强制性锁后再 继续进行处理。(这两种shell在执行添加操作时会产生这样的区别，是因为Korn shell以 0_CREAT和0_APPEND标志打开文件，上面已提及指定0_CREAT会产生出错返回，而 Bourne shell在该文件已存在时并不指定0_CREAT，所以open成功，而下一个write则 阻塞。)
产生的结果随所用操作系统版本的不同而变。从这样一个例子中可见，在使用强制性锁时还需 有所警〖易。从ed实例可以看到，强制性锁是可以设法避开的。
一个别有用心的用户可以对大家都可读的文件加一把读锁(强制性)，这样就能阻止任何 其他人写该文件(当然，该文件应当是强制性锁机制起作用的，这可能要求该用户能够更改该 文件的权限位)》考虑一个数据库文件，它是大家都可读的，并且是强制性锁机制起作用的。 如果一个别有用心的用户对该整个文件保有一把读锁，则其他进程不能再写该文件。
1456]

 
368 第14幸高级I/O
程序清单14-6用于确定一个系统是否支持强制性锁机制。
程序清单14-6确定是否支持强制性锁
#include
#include
#include
#include
int
main(int argc, char *argv[])
"apue.h" <ermo.h> <fcntl.h> <sys/wait.h>
int
pid_t
char
struct stat
if (argc != 2) {
fprintf(stderr
exit(1)；
fd； pid? buf [5]； statbuf；
"usage： %s filename\n", argv[0])；
OCREAT | 0一TRUNC, FILE一MODE))
if ((fd = open(argv[l], 0_RDWR
err—sys("open error")；
if (write(fd, "abcdef", 6) 1= 6)
err—sys("write error");
/* turn on set-group-ID and turn off group-execute */
if (fstat(fd, &statbuf) < 0)
err一sys("fstat error")；
if (fchmod(fd, (statbuf■st一mode & 一IXGRP) | S一ISGID) < 0)
err•一sys ("fchmod error")；
TELL_WAIT()；
if ((pid = fork()) < 0) {
err—sys("fork error")；
} else if (pid > 0) { /* parent */
/* write lock entire file */
if (write—lock(fd, 0, SEEK—SET, 0) < 0)
err_sys("write_lock; error");
TELL_CHILD(pid);
0)
if (waitpid(pid, NULL, 0) < 0)
err一sys ("waitpid error'1)；
else {	/* child */
WAIT_PARENT();	/* wait for
parent to set lock
set fl(fd,
NONBLOCK),
/* first let,s see what error we get if region is locked */ if (read一lock(fd, 0, SEEK一SET, 0) != -1) /* no wait */ err_sys("child： read_lock succeeded")； printf("read_lock of already-locked region returns %d\n", errno)；
/* now try to read the mandatory locked file */ if (lseek(fd, 0, SEEK_SET) == -1) err—sys("lseek error")； if (read(fd# buf, 2) < 0)

 
14.3记录销 369
err一ret("read failed (mandatory locking works)");
else
printf("read OK (no mandatory locking), buf = %2.2s\n", buf)；
exit(0);
}
此程序首先创建一个文件，并使强制性锁机制对其起作用。然后程序分裂为父进程和子进 程。父进程对整个文件设置一把写锁，子进程则将该文件的描述符设置为非阻塞的，然后企图 对该文件设置一把读锁，我们期望这会出错返回，并希望看到系统返回是EACCES或EAGAIN。 接着，子进程将文件读、写位置调整到文件起点，并试图读(read)该文件。如果系统提供 强制性锁机制，则read应返回EACCES或EAGAIN (因为该描述符是非阻塞的)，否则read返 回所读的数据。在Solaris 9运行此程序(该系统支持强制性锁机制)，得到：
$ ./a.out temp.lock
read一lock of already-locked region returns 11
read failed (mandatory locking works)： Resource temporarily unavailable 查看系统头文件或intro(2)手册页，可以看到errno 11对应于EAGAIN。若在FreeBSD 5.2.1 运行此程序，则得到：
$ ./a.out temp.lock
read—lock of already-locked region returns 35 read OK (no mandatory locking), buf = ab
其中，errno 35对应于EAGAIN。该系统不支持强制性锁。	口
mm
让我们回到本节的第一个问题：若两个人同时编辑同一个文件将会怎样呢？ 一般的UNIX 系统文本编辑器并不使用记录锁，所以对此问题的回答仍然是：该文件的最后结果取决于写该 文件的最后一个进程。
某些版本的vi编辑器使用建议性记录锁。即使我们正在使用这种版本的vi编辑器，但是 它并不能阻止其他用户使用另一个没有使用建议性记录锁的编辑器。
若系统提供强制性记录锁，那么我们可以修改自己常用的编辑器(如果有该编辑器的源 代码)。如没有该编辑器的源代码，那么可以试一试下述方法。编写一个vi的前端程序。该 程序立即调用fork,然后父进程等待子进程终止，子进程打开在命令行中指定的文件，使强 制性锁起作用，对整个文件设置一把写锁，然后执行vi。在vi运行时，该文件是加了写锁的， 所以其他用户不能修改它。当vi结束时，父进程从wait返回，此时自编的前端程序也就结 束了。
这种类型的前端程序是可以编写的，但却往往不能起作用。问题出在大多数编辑器通常在 读完输入文件后关闭它。只要引用被编辑文件的描述符关闭了，那么加在该文件上的锁就被释 放了。这意味着，编辑器读了该文件的内容后，随即关闭了该文件，那么锁也就不存在了。前 端程序中没有任何方法可以阻止这一点。	□
第20章的数据库函数库使用了记录锁以提供多个进程的并发访问。该章也提供了定时测量 数据，以观察记录锁对进程的影响。
回
[459]

 
370 第14章高级I/O
14.4	STREAMS
STREAMS (流)是系统V提供的构造内核设备驱动程序和网络协议包的一种通用方法，对 STREAMS进行讨论的目的是为了理解系统v的终端接口，I/O多路转接中poll (轮询)函数的 使用(见M.5.2节)，以及基于STREAMS的管道和命名管道的实现(见17.2节和17.2.1节)。
请江意不要将本幸说明的STREAMS (流)与标准I/O库(见5.2节)中使用的流(stream)相混淆。 流机制是由Dennis Ritchie开发的[Ritchie 1984],其目的是用通用、灵活的方法改写传统的字符I/O系统 (c-list)并与网络协议相适应，后来稍加增强，名称改用大写字母，成为STREAMS机制，被加入到 SVR3。SVR4则提供了对STREAMS的全面支持(亦即，一个基于STREAMS的终端I/O系统)。[AT&T 1990d]对SVR4实£1进行了说明。Rago[19931讨论了用户层的STREAMS编'i里和内核层的STREAMS编程。
在Single UNIX Specification中.STREAMS是一种可选择的特征(XSI STREAMS Option Group)。 在本书讨论的四种平台中，只有Solaris对STREAMS提供了很自然的支持。在Linux中-STREAMS子系 统是可用的，但是用户必须自行将该子系统安装到系统中，通常它默认为不包括在系统个_
流在用户进程和设备驱动程序之间提供了一条全双工通路。流无需和实际硬件设备直接会 话，流也可以用来构造伪设备驱动程序。图14~4不出了一个简单流(simple stream)的基本结构。
在流首(stream head)之下可以压入处理模块。这可以用ioctl命令实现。图14-5示出了 包含一个处理模块的流。各方框之间用两根带箭头的线连接，以突出流的全双工特征，并强调 两个方向的处理是相互独立进行的。
 
 
L	」	L	」	逆流
图14-4 一个简单流	图14-5具有处理模块的流
任意数量的处理模块可以压入流。我们使用术语压入，是因为每一新模块总是插到流首之 下’而将以前的模块下压。(这类似于后进先出的栈。)图14-5标出了流的两侧，分别称为顺流 (downstream)和逆流(upstream)。写到流首的数据将顺流而下传送，由设备驱动程序读到的 数据则逆流向上传送。
STREAMS模块是作为内核的一部分执行的’这类似于设备驱动程序。当构造内核时， STREAMS模块联编进人内核。如果系统支持动态可装人的内核模块(Linux和Solaris是这样做 的)，贝峨们可以试图将没有联编进内核的STREAMS模块压入一个流；但不保证STREAMS模 块和驱动程序的任意组合将能正常工作。
用第3章中说明的函数访问流，它们是：
open、close、read、write和ioctlc 另夕卜，

 
14.4 STREAMS 371
在SVR3内核中增加了3个支持流的新函数(getmsg、putmsg和poll),在SVR4中又加了两 个处理流内不同优先级波段消息的函数(getpmSg*putpmSg)。本节将说明这5个新函数。
打开(open)流时使用的路径名参数通常在/dev目录之下。仅仅用Is -1査看设备名，不 能判断该设备是不是STREAMS设备。所有STREAMS设备都是字符特殊文件。
虽然某些有关STREAMS的文献暗示我们可以编写处理模块，并且不加细究地就可将它们 压入流中，但是编写这些模块如同编写设备驱动程序一样，需要专门的技术。通常只有特殊的 应用程序或函数才压入和弹出STREAMS模块。
在STREAMS之前,终端是用现存的c-list机制处理的。(Bach[1986]的10.3.1节和McKusick等[1996]的 10.6节分别说明SVR2和4.4BSD中的c-list机制。)将基于字符的其他设备添加到内核中通常涉及编写设 备驱动程序，并将所有有关部分都安排在驱动程序中。对新设备的访问典型地通过原始设备进行，这 意味着每个用户的read, write最后都直通进入设备驱动程序。流机制使这种交互作用方式更加炙治 且条理清晰，使得数据可以用STREAMS消息方式在流首和驱动程序之间传送，并仗任意数的中间处理 模块可对數据进行操作。
1. STREAMS消息
STREAMS的所有输入和输出都基于消息。流首和用户进程使用read、write、ioctl、 getmsg、getpmsg、putmsg和putpmsg交换消息。在流首、各处理模块和设备驱动程序之 间，消息可以顺流而下，也可以逆流而上。
在用户进程和流首之间，消息由下列几部分组成：消息类型、可选择的控制信息以及可选 择的数据。表14-4列出了对应于write、putmsg和putpmsg的不同参数所产生的不同消息类 型。控制信息和数据由strbuf结构指定：
struct strbuf
int maxlen； /* size of buffer */
int len；	/* number of bytes currently in buffer */
char *buf； /* pointer to buffer */
}；
当用putmsg或putpmsg发送消息时，len指定缓冲区中数据的字节数。当用getmsg或 getpmsg接收消息时，maxlen指定缓冲区长度(使内核不会溢出缓冲区)，而len则由内核设 置为存放在缓冲区中的数据量。消息长度为0是允许的，len为-1说明没有控制信息或数据。
为什么需要传送控制信息和数据两者呢？提供这两者使我们可以实现用户进程和流之间的服 务接口。Olander, McGrath和lSrael[1986]说明了系统V服务接口的原先实现。AT&T[1990d]第5章详 细说明了服务接口，还使用了一个简单的实例。可能最为人了解的服务接口是系统V的传输层接 口(Transport Layer Interface, TLI),它提供了网络系统接口，Rago [1993]第4章对此进行了说明。
控制信息的另一个例子是发送一个无连接的网络消息(数据报>。为了发送该消息，需要 说明消息的内容(数据)和该消息的目的地址(控制信息)。如果不能将数据和控制一起发送， 那么就要某种专门设计的方案。例如，可以用ioctl说明地址，然后用write发送数据。另一 种技术可能要求地址占用数据的前^个字节，而数据是用write写的。将控制信息与数据分开， 并且提供处理两者的函数(putmsg和getmsg)是处理这种问题的较清晰的方法。
有约25种不同类型的消息，但是只有少数几种用于用户进程和流首之间，其余的只在内核 中顺流、逆流传送。(对于编写流处理模块的人员而言，这些消息是非常有用的，但是对编写 用户级代码的人员而言，它们可以忽略。)在我们所使用的函数(read、write、getmsg, getpmsg、putmsg和putpmsg)中，只涉及三种消息类型，它们是：

 
372 第14章高级I/O
•	M—DATA (I/O的用户数据)。
•	M_PROTO (协议控制信息)。
•M_PCPROTO (髙优先级协议控制信息)。
流中的消息都有一个排队优先级：
•髙优先级消息(最髙优先级)。
•.优先级波段消息。
•普通消息(最低优先级)。
普通消息是优先级波段为0的消息。优先级波段消息的波段可在1~255之间，波段愈髙，优先级 也愈髙。髙优先级消息的特殊性在于，在任何时刻流首只有一个髙优先级消息排队。在流首读 队列已有一个髙优先级消息时，另外的髙优先级消息会被丢弃。
表 14-4 write, putmsg和putpmsg产生的STREAMS消息类型
函数	控制？	数据？	波段	标 志	产生的消息类型
write	N/A	是	N/A	N/A	M—DATA (普通)
putmsg	否	否	N/A	0	不发送消息，返回0
putmsg	否	是	N/A	0	M一DATA (普通)
putmsg	是	是或否	N/A	0	M-PR0T0 (普通)
putmsg	是	是或否	N/A	RS-HIPRI	M一PCPR0T0 (高优先级)
putmsg	否	是或否	N/A	RS—HIPRI	出错，EINVAL
putpmsg	是或否	是或否	0-255	0	出错，EINVAL
putpmsg	否	否	0-255	MSG一BAND	不发送消息，返回0
putpmsg	否	是	0	MSG-BAND	M_DATA (普通)
putpmsg	否	是	1-255	MSG_BAND	M一DATA (优先级波段)
putpmsg	是	是或否	0	MSG-BAND	M-PR0T0 (普通)
putpmsg	是	是或否	1-255	MSG-BAND	M—PR0T0 (优先级波段)
putpmsg	是	是或否	0	MSG—HIPRI	M—PCPR0T0 (高优先级)
putpmsg	否	是或否	0	MSG一HIPRI	出错，EINVAL
putpmsg	是或否	是或否	非零	MSG一HIPRI	出错，EINVAL
每个STREAMS模块有两个输入队列。一个接收来自它上面模块的消息，这种消息从流首 向驱动程序顺流传送。另一个接收来自它下面模块的消息，这种消息从驱动程序向流首逆流传 送。在输入队列中的消息按优先级从高到低排列。表14-4列出了针对wr i te、putmsg和 putpmsg的不同参数，产生不同优先级的消息。
有一些消息我们未加考虑。例如，若流首从它下面接收到^310消息，则产生一信号。这 种方法用于终端行规程模块向具有控制终端的前台进程组发送终端产生的信号。
2. putmsg和putpmsg函数
putmsg和putpmsg函数用于将STREAMS消息(控制信息或数据，或两者)写至流中。 这两个函数的区别是后者允许对消息指定一个优先级波段。
#include otropts .h>
int putmsg (int filedes, const struct strbuf *ctlptr, const struct strbuf *dataptr, int flag)；
int putpmsg (int filedes, const struct strbuf *ctlptr,
const struct strbuf *dataptr, int band, int flag)；
		两个函数返回值：若成功则返回0,若出错则返回-1

 
14.4 STREAMS 373
对流也可以使用write函数，它等效于不带任何控制信息、//ag为0的putmsg。
这两个函数可以产生三种不同优先级的消息：普通、优先级波段和高优先级。表14-4详细 列出了这两个函数中几个参数的各种可能组合，以及所产生的不同类型的消息。
在表14-4中，N/A表示不适用。消息控制列中的“否”对应于空参数，歲ctlptr->len 为-1。该列中的“是”对应于非空，以及大于等于0。这些说明同样适用于消 息的数据部分(用dafapfr代替crt/jfr)。
3.	STREAMS ioctl操作
3.15节曾提到过ioctl函数，它能做其他I/O函数不处理的事情。STREAMS系统继承了这 种传统。
在Linux和Solaris中，使用ioctl可对流执行将近40种不同的操作。其中大多数操作的说明 请见streamio(7)手册页。头文件<stropts . h>应包括在使用这些操作的C代码中。ioctl 的第二个参数说明执行哪一个操作。所有都以1_开始。第三个参数的作用与 有关，有时它是一个整型值，有时它是指向一个整型或一个数据结构的指针。
实例：isastream函数
有时需要判断一个描述符是否引用一个流。这与调用isatty函数来判断一个描述符是否 引用-个终端设备相类似(见18.9节)。Linux和Solaris为此提供了isastream函数。
#include <stropts.h>	
int isastream (int filedes)；	
	返回值：若为STREAMS设备则返回1，否则返回0
与isatty类似，它通常是用一个只对STREAMS设备才有效的ioctl函数来进行测试的。 程序清单14-7是该函数的一种可能的实现。它使用I_CANPUT ioctl来测试由第三个参数说明 的优先级波段(本实例中为0)是否可写。如果该ioctl执行成功，则它对所涉及的流并未作 任何改变。
程序清单14-7检査描述符是否引用STREAMS设备
#include <stropts.h>
#include <unistd.h>
int
isastream(int fd)
{
return(ioctl(fd, I_CANPUT, 0) != -1)；
程序清单14-8可用于测试此函数。
程序清单14-8测试isastream函数
#include "apue.h"
#include <fcntl.h>
int
main {int argc, char *argv [])
画
[464]

 
374 第14章高级I/O
int	i, fd?
for (i = 1; i < argc； i++) {
if ((fd 二 open(argv[i], 0_RD0NLY)) < 0) { err_ret(n%s： can#t open"• argv[i])； continue；
if (isastream(fd) == o)
err 一ret("%s: not a stream", argv[i])；
else
)	err—msg("%s: streams device"f argv[i])；
exit(0)；
在Solaris 9下运行此程序，得到很多由ioctl函数返回的出错信息：
$ ./a.out /dev/tty /dev/fb /dev/null /etc/motd
/dev/tty： streams device
/dev/fb： not a stream； Invalid argument
/dev/null： not a stream： No such device or address
/etc/motd： not a stream： Inappropriate ioctl for device
/dev/tty在Solaris之下是个STREAMS设备，这与我们所期望的一致。/dev/fb不是一个 STREAMS设备，但它是支持其他ioctl请求的字符特殊文件。对于不知道这种ioctl请求的设 备，它返回EINVAL。/dev/null是一种不支持任何ioctl操作的字符特殊文件，所以ioctl返 回EN0DEV。最后，/etc/motd是一个普通文件，而不是字符特殊文件，所以返0ENOTTY (这 种情况下的经典返回值)。我们从未见到曾期望的出错信息ENOSTR (“Device is not a stream”)。
ENOTTY的原意是“Not a typewriter”，它是个历史产物.当ioctl企图对并不引用字符特殊设备的
描述符进行操作时’ UNIX系统内核都返回knotty。在Solaris中，该消息已被改为“Inappropriate ioctl for device.”。
□
实例
如果ioctl的参数是I_LIST,则系统返回已压入该流所有模块的名字，包括最顶 端的驱动程序。(指明最顶端的原因是，在多路转接驱动程序的情况下，有多个驱动程序。 Rago [1993]第12章讨论了多路转接驱动程序的细节。)其第三个参数应当是指向str_list‘ 构的指针。
struct strlist {
si—nmods; /* number of entries in array */ struct str_mlist *sl_modlist； /* ptr to first element of array */
/ r
应将s 1一modi i s t设置为指向s tr_ml i s t结构数组的第一个元素，将3 l_nmods设置为该数 组中的项数：
struct str_mlist {
char l_name[FMNAMESZ+l]； /* null terminated module name */
常量FMNAMESZ在头文件<sys/conf .h^定义，其值常常是8。l_namef

 
14.4 STREAMS 375
FMNAMESZ + 1,增加1个字节是为了存放null终止符。
如果ioctl的第三个参数是0,则该函数返回值是模块数，而不是模块名。我们将先用这 种ioctl调用确定模块数，然后再分配所要求的str_mlist结构数。
程序清单14>9例示了 I_LIST操作。由ioctl返回的名字列表并不对模块和驱动程序进行区分， 但是考虑到该列表的最后一项是处于流底部的驱动程序，所以在打印时将其标明为驱动程序。
	程序清单14-9列表流中的横块名	
#include "apue.h”
#include <fcntl.h>
#include <stropts.h>
#include <sys/conf.h>
int
main(int argc, char *argv[])
{
int	•	fd, i, nmods；
struct str_list list；
if (argc != 2)
err_quit("usage： %s <pathname>", argv[0]);
if ((fd = open(argv[1]# 0_RD0NLY)) < 0) err一sys (__canf t open %s”，argv [1]); if (isastream(fd) == 0)
err一quit (n%s is not a stream11 f argv [1]);
/*
*	Fetch number of modules.
*/
if 《(nmods : ioctl(fd, I一LIST, (void *) 0)) < 0) err—sys("I_L1ST error for nmods"〉； printf("#modules = %d\nH, nmods)；
/*
*	Allocate storage for all the module names.
*/
list.sl_modlist = calloc(nmods, sizeof(struct str_mlist}}; if (list.sl_modlist == NULL) err—sys("calloc error"); list.si—nmods * nmods;
/*
*	Fetch the module names.
*/
if (ioctl(fd, I_LIST, fidist) < 0)
err_sys (f,I_LIST error for list") ?
/*
*	Print the names.
*/
for (i = 1? i <= nmods； i++)
printf(" %s: %s\n", (i 二= nmods) ? Mdriver" : "module", list.sl_modlist++->l_name);
exit(0)?
为了弄清楚哪些STREAMS模块已压入控制终端，我们以网络登录和控制台登录两种方式

 
376 第14章高级I/O
运行程序清单14-9所示程序，得到下列结果：
console	May 1 18:27
pts/7	Jul 12 06:53
/dev/console
5
redirmod
ttcompat
ldterm
ptem
pts
/dav/pts/7
4
ttcompat
ldterm
ptem
pts
在这两种情形中，4个STREAMS模块都是一样的(ttcompat、ldterm、ptem和pts),唯一的区别 是控制台在其流的顶部多了一个模块，它的作用是帮助虚控制台重定向。运行此程序的计算机 在控制台上运行了一个窗口系统，所以/dev/console实际上引用的是伪终端而非硬连线设备。 第19章将说明伪终端。	□
4.	写(write)至STREAMS设备
在表14-4中可以看到写至STREAMS设备产生一个M_DATA消息。一般情况确实如此，但是 也还有一些细节需要考虑。首先，流中最顶部的一个处理模块规定了可顺流传送的最小、最大 数据包长度(无法查询该模块中规定的这些值)。如果写的数据长度超过最大值，则流首将这 一数据按最大长度分解成若干数据包。最后一个数据包的长度可能不到最大值。
接着要考虑的是：如果向流写0个字节，又将如何呢？除非流引用管道或FIFO,否则就顺 流发送0长度消息。对于管道和FIFO,为与以前版本兼容，系统的默认处理方式是忽略0长度 writec 可以用ioc 11设置管道和FIFO流的写模式，从而更改这种默认处理方式。
5.	写棋式
可以用两个ioctl命令取得和设置一个流的写模式。如果将regMeir设置为I_GWR0PT,第 三个参数设置为指向一个整型变量的指针，则该流的当前写模式在该整型量中返回。如果将 印押故设置为I—SWR0PT,第三个参数是一个整型值，则其值成为该流新的写模式。如同处理 文件描述符标志和文件状态标志(见3.14节)一样,总是应当先取当前写模式值，然后修改它，而 不只是将写模式设置为某个绝对值(很可能会关闭某些原来打开的位)。
目前，只定义了两个写模式值。
SNDZER0对管道和FIFO的0长度write会造成顺流传送一个0长度消息。按系统默认，0 长度写不发送消息。
SNDPIPE在流上已出错后，若调用write或putmsg，则向调用进程发送SIGPIPE 信号。
流也有读模式，我们先说明getmsg和getpmsg函数，然后再说明读模式。
6.	getmsg和getpmsg函数
使用read、getmsg或getpmsg函数从流首读STREAMS消息。
 
sar
sar
$ ./a.out
#modules = module： module: module： module： driver：
$ ./a.out #modules = module： module： module： driver：

 
14.4 STREAMS 377
#include <stropts.h>
int getmsg (int filedes, struct strbuf *restrict ctlptr,
struct strbuf .restrict dataptr, int .restrict flagptr)；
int getpmsg {int filedes, struct strbuf *restrict ctlptr,
struct strbuf * restrict dataptr, int * restrict bandptr, int * restrict flagptr);
两个函数返回值：若成功则返回非负值，若出错则返回-1
注意，flagptr和bandptr是指向整型的指针。在调用之前，这两个指针所指向的整型单元 中应设置成所希望的消息类型，在返回时，此整型量设置为所读到的消息的类型。
如果声指向的整型单元的值是0，则getmsg返回流首读队列中的下一个消息。如果下 一个消息是髙优先级消息，则在返回时，W所指向的整型单元设置为RS_HIPRI。如果希 望只接收髙优先级消息，则在调用getmsg之前必须将//叩所指向的整型单元设置为 RS—HIPRI。
getpmsg使用一个不同的常量集。为了只接收髙优先级消息，我们可将/指向的整型 单元设置为MSG_HIPRI。为了只接收某个优先级波段或以上波段(包括髙优先级消息)的消 息，我们可将该整型单元设置为MSG_BAND，然后将指向的整型单元设置为该波段的非 0优先级值。如果只希望接收第1个可用消息，则可将声指向的整型单元设置为MSG_ANY, 在返回时，该整型值将改写为MSG_HIPRI或MSG_BAND，这取决于接收到的消息的类型。如果 取到的消息并非髙优先级消息，那么如指向的整型将包括消息的优先级波段值。
如果c/pfr是null,或是-1,那么消息的控制部分仍保留在流首读队列中，我 们将不处理它。类似地，如果dafapfr是null,或者是-1，那么消息的数据部分仍 保留在流首读队列中，我们也不处理它。否则，将按照缓冲区的容量取到消息中尽可能多的控 制和数据部分，余下部分仍留在队首，等待下次取用。
如果ge/ffwg和gefpm咕调用取到一消息，那么返回值是0。如果消息控制部分中有一些余留 在流首读队列中，那么返回常量MORECTL。类似地，如果消息数据中有一些余留在流首读队列 中，那么返回常量MOREDATA。如果控制和数据都有一些余留在流首读队列中，那么返回常量 值是(MORECTL 丨 MOREDATA)。
7.读棋式
如果读(read) STREAMS设备会发生些什么呢？有两个潜在的问题：
(1)	如果读到流中消息的记录边界将会怎样？
(2)	如果调用read，而流中下一个消息有控制信息又将如何？
对第一种情况的默认处理模式称为字节流模式。read从流中取数据直至满足了所要求的字节 数，或者已经不再有数据。在这种模式中，忽略流中消息的边界。对第二种情况的默认处理是， 如果在队列的前端有控制消息，则read出错返回。可以改变这两种默认处理模式。
调用ioctl时，若将re孕MCif设置为I_GRD0PT, 第三个参数又是指向一个整型单元的指针, 则对该流的当前读模式在该整型单元中返回。如果将设置为I_SRDOPT,第三个参数是 整型值，则将该流的读模式设置为该值。读模式值可由下列三个常量指定：
RN0RM 普通，字节流模式，如上所述这是默认模式。
RMSGN 消息不丢弃模式。read从流中取数据直至读到所要求的字节数，或者到达消 息边界。如果某次read只用了消息的一部分，则其余下部分仍留在流中，以

 
378 第14章高级I/O
供下一次读。
RMSGD 消息丢弃模式。这与不丢弃模式的区别是，如果某次读只用了消息的一部分， 则余下部分就被丢弃，不再使用。
在读模式中还可指定另外三个常量，以便设置在读到流中包含协议控制信息的消息时 read的处理方法：
RPROTNORM协议-普通模式。read出错返回，errno设置为EBADMSG。这是默认模式。 RPROTDAT 协议-数据模式。read将控制部分作为数据返回给调用者^
RPROTDIS 协议-丢弃模式。read丢弃消息中的控制信息，但是返回消息中的数据。 任一时刻，只能设置一种消息读模式以及一种协议读模式。默认读模式是(RNORMI RPROTNORM)。
程序清单14-10是在程序清单3-3的基础上改写的，它用getmsg代替了read。 	程序清单14-10用getmag将标准输入复制到标准输出	
#include "apue.h"
#include <stropts.h>
#define BUFFSIZE 4096
int
main (void)
{
int	n, flag;
char	ctlbuf[BUFFSIZE], datbuf[BUFFSIZE]；
struct strbuf ctl, dat;
ctl.buf = ctlbuf； ctl.maxlen = BUFFSIZE； dat.buf = datbuf； dat.maxlen = BUFFSIZE； for 《；；} {
flag =0;	/* return any message */
if ( (n = getmsg (STDIN一 FI LENO, &ctl, Scdat, &f lag)) < 0) err 一sys{"getmsg error")； fprintf(stderr, "flag = %d, ctl.leu = %d, dat.leu - %d\n”， flag, ctl.len, dat.len)； if (dat.len == 0) exit(0); else if (dat.len > 0)
if (write(STDOUT—FILENO, dat.buf, dat.len) != dat.len) err_sys("write error")；
如果在Solaris (其管道和终端都是用STREAMS实现的)下运行此程序则得:
$ echo hello, world | ./a.out	要求基于STREAMS的管道 flag = 0, ctl.len = -1, dat.len = 13 hello, world
flag = 0, ctl. len = 0, dat .len = 0	表明 STREAMS 技断
$ •/••out	要求基于STREAMS的终端 this is line 1
flag = 0, ctl.len = -1, dat.len = 15

 
14.5 I/O多路转接 379
this is line 1 and line 2
flag = 0, ctl.len = -1, dat.len = 11 and line 2
-D	键入终端EOF字符
flag - 0, ctl .len = -1, dat.len « 0 tty文件结尾与挂断不相同 $ ./a.out < /etc/motd getmsg error： Not a stream device
当管道被关闭时(当echo终止时)，它对程序清单14-10表现为一个STREAMS挂断，控制长度 和数据长度都设置为0。(15.2节将讨论管道。)但是对于终端，键入文件结束字符只使返回的数 据长度为0。这与STREAMS挂断并不相同。如所预料的一样，将标准输入重新定向到一个非 STREAMS设备，getmsg出错返回。	口
14.5	I/O多路转接
当从一个描述符读，然后又写到另一个描述符时，可以在下列形式的循环中使用阻塞i/o:
while ((n = read(STDIN_FILENO, buf, BUFSIZ)) > 0) if (write(STD0UT_FILEN0, buf, n) != n) err_sys("write error");
这种形式的阻塞I/O到处可见。但是如果必须从两个描述符读，又将如何呢？如果仍旧使用阻塞 I/O,那么就可能长时间阻塞在一个描述符上，而另一个描述符虽有很多数据却不能得到及时处 理。所以为了处理这种情况显然需要另一种不同的技术。
让我们观察telnet(l)命令的结构。该程序读终端(标准输入)，将所得数据写到网络连接 上，同时读网络连接，将所得数据写到终端上(标准输出)。在网络连接的另一端，telnetd 守护进程读用户在终端上所键入的内容，并将其送给shell，这如同用户登录在远程机器上一样。 telnetd守护进程将执行用户键入命令，而产生的输出通过telnet命令送回给用户，并显示 在用户终端上。图14-6显示这种工作情景。
 
图14-6 telnet程序概观
telnet进程有两个输入、两个输出。对这两个输入中的任一个都不能使用阻塞read,因 为我们永远不知道哪一个输入有我们需要的数据。
处理这种特殊问题的一种方法是，用fork将一个进程变成两个进程，每个进程处理一条数 据通路。图14-7中显示了这种安排。(系统V uucp通信包提供了cu(l)命令，其结构与此相似。)
 
图14-7使用两个进程实现telnet程序

 
380 第14章高级I/O
如果使用两个进程，则可使每个进程都执行阻塞read。但是这也产生了问题：操作什么时候终 止？如果子进程接收到文件结束符telnetd守护进程使网络连接断开，那么该子进程终止，然后父 进程接收到SIGCHLD信号。但是，如若父进程终止(用户在终端上键入了文件结束符)，那么父 进程应通知子进程停止。约此可以使用一个信号(例如SIGUSR1),但这使程序变得更加复杂。
我们可以不使用两个进程，而是用一个进程中的两个线程。这避免了终止的复杂性，但却 要求处理线程之间的同步，在减少复杂性方面这可能会是得不偿失。
另一个方法是仍旧使用一个进程执行该程序，但使用非阻塞I/O读取数据。基本方法是将两 个输入描述符都设置为非阻塞的，对第一个描述符发一个read。如果该输入上有数据，则读 数据并处理它，如果无数据可读，则read立即返回。然后对第二个描述符作同样的处理。在 此之后，等待若干秒，然后再读第一个描述符。这种形式的循环称为轮询(polling)。这种方 法的不足之处是浪费CPU时间。因为大多数时间实际上是无数据可读的，但是仍花费时间不断 反复执行read系统调用。在每次循环后要等多长时间再执行下一轮循环也很难确定。虽然轮 询技术在支持非阻塞I/O的系统上都可使用，但是在多任务系统中应当避免使用这种方法。
还有一种技术称之为异步1/0 (asynchronous I/O)。其基本思想是进程告诉内核，当一个描 述符已准备好可以进行I/O时，用一个信号通知它。这种技术有两个问题。第一，并非所有系统 都支持这种机制(在Single UNIX Specification中这是一个可选择的设施)。系统V为此技术提供 了SIGPOLL信号，但是仅当描述符引用STREAMS设备时，此信号才能工作。BSD有一个类似 的信号SIGI0，但也有类似的限制，仅当描述符引用终端设备或网络时才能工作。其次，这种 信号对每个进程而言只有1个(SIGPOLL或SIGIO)。如果使该信号对两个描述符都起作用(在 我们正在讨论的实例中，从两个描述符读)，那么在接到此信号时进程无法判别是哪一个描述 符已准备好可以进行I/O。为了确定是哪一个，仍需将这两个描述符都设置为非阻塞的，并顺序 试执行I/O。14.6节将简要说明异步I/O。
一种比较好的技术是使用I/O多路转接(I/O multiplexing)。先构造一张有关描述符的列表， 然后调用.个函数，直到这些描述符中的一个已准备好进行I/O时，该函数才返回。在返回时， 它告诉进程哪些描述符已准备好可以进行1/0。
poll、pselect和select这三个函数使我们能够执行I/O多路转接。表14-5摘要列出了 哪些平台支持这些函数。注意基本POSIX.1标准定义了select函数，而poll则是对该基本部 分的XSI扩展。
表14-5多种UNIX系统支持的I/O多路转接
系统	poll	pselect	select	<sys/select .h>
SUS	XSI	•		•
FreeBSD 5.2.1	•	•		
Linux 2.4.22	•	.		•
Mac OS X 10.3	*	•		
Solaris 9	•			•
P0SIX指定，为了在程序中使用select,必须包“〈sys/select.li;^但是历史上，为了在程序 中使用select,还要包括另外三个头文件，而且某些实现至今还落在标准之后。为此，要查看select 手册页，弄清楚你所用的系统对它支持到何种程度r较老的系统要求在程序中包types.h>、 <sys/ time • h>#p<unistd. h> 0

 
14.5 I/O多路转接 381
1/0多路转接在4.2 BSD中^用select函教提供的。虽然该函數主要用于终端I/O和网络I/O,但它 对其他描述符同样是起作用的。SVR3在增加STREAMS机制时增加了poll函数，但一开始poll只对 STREAMS设备起作用。SVR4支持对任一描述符起作用的poll。
I~
14.5.1	select 和 pselect 函数
在所有依从POSIX的平台上，select函数使我们可以执行I/O多路转接。传向select的 参数告诉内核：
•我们所关心的描述符。
•对于每个描述符我们所关心的状态。(是否读一个给定的描述符？是否想写一个给定的描 述符？是否关心一个描述符的异常状态？)
•愿意等待多长时间(可以永远等待，等待一个固定量时间，或完全不等待)。
从select返回时，内核告诉我们：
•已准备好的描述符的数量。
•对于读、写或异常这三个状态中的每一个，哪些描述符已准备好。
使用这些返回信息，就可调用相应的1/0函数(一般是read或write),并且确知该函数不 会阻塞。
#include <sys/select.h>
int select (int maxfdpl, f d set *restrict readfds•
fd一set * restrict writefds, fd_set * restrict exceptfds • struct time val * re strict tvptr)；
返回值：准备就绪的描述符数，若超时则返回0,若出错则返回-1
先说明最后一个参数，它指定愿意等待的时间：
struct timeval {
long tv一sec; /* seconds */
long tv 一 usee; /* and microseconds */
}； —
有三种情况：
^v/?^r==NULL
永远等待。如果捕捉到一个信号则中断此无限期等待。当所指定的描述符中的一个已 准备好或捕捉到一个信号则返回。如果捕捉到一个信号，则select返回-1，errno 设置为EINTR。 tvptr- >tv_sec==0 && tvptr- >tv_usec= = 0
完全不等待。测试所有指定的描述符并立即返回。这是得到多个描述符的状态而不阻 塞select函数的轮询方法。 tvptr->tv_sec ! =0 I I tvptr->tv_usec! = 0
等待指定的秒数和微秒数。当指定的描述符之一已准备好，或当指定的时间值已经超 过时立即返回。如果在超时时还没有一个描述符准备好，则返回值是0 (如果系统不 提供微秒分辨率，则fv/^->rv—直取整到最近的支持值)。与第一种情况一样，这种 等待可被捕捉到的信号中断。

 
382 第14章高级I/O
P0SIX.1允许在实现中修改timeva丄结构中的值，所以在select返回后，你不能指望该结构仍旧 保持调用select之前它所包含的值。FreeBSD 5.2.1、Mac OS X 10.3和Solaris 9都保持该结构中的值不 变。但是Linux 2.4.22中，苦在该时间值尚未超过时select就返回，那么将用余留时间值更新该结构。
中间三个参数印《办办、wr/fe/ds和ejrc叩f/ds是指向描述符集的指针。这三个描述符集说明了 我们关心的可读、可写或处于异常条件的各个描述符。每个描述符集存放在一个fd_set数据 [475]类型中。这种数据类型为每一可能的描述符保持了一位，其实现可如图14-8中所示。
fd 0 fd 丨 fd 2
readfds 	►	0	0	0	…
	\-m-		每个可能的描述符占1位 	H
writefds 	►	0	0	0	
exceptfds	►
图 14-8
对fd_set数据类型可以进行的处理是：分配一个这种类型的变量•将这种类型的一个变 量值赋予同类型的另一个变量，或对于这种类型的变量使用下列四个函数中的一个。
#include <sys/select.h>
int FD_lssET(int fd, fd set *fdset)；
返回值：若辦在描述符集中则返回非0值，否则返回0
void FD_CLR (int fd, fd_set *fdset)； void FD_SET(int fd, fd_set *fdset)； void FD_ZERO (f d set *fdset)；
这些接口可实现为宏或函数。调用FD_ZER0将一个指定的fd—set变量的所有位设置为0。
调用FD_SET设置一个fd_set变量的指定位。调用FD_CLR则将一指定位清除。最后，调用
FD_ISSET测试一指定位是否设置。
声明了一个描述符集后，必须用FD_ZER0清除其所有位，然后在其中设置我们关心的各个
位。这种操作序列如下所示：
fd_set rset ； int	fd；
FD_ZERO(&rset)；
FD_SET(fd, &rset)；
FD_SET(STDIN_FILENO, &rset);
从select返回时，用FD_ISSET测试该集中的一个给定位是否仍旧设置： if (FD_ISSET(fd, &rset)) {
[476]	}
select的中间三个参数(指向描述符集的指针)中的任意一个或全部都可以是空指针，
fd-set数据类型
 
对select指定读、写和异常条件描述符

 

14.5 I/O多路转接 383
这表示对相应状态并不关心。如果所有三个指针都是空指针，则select提供了较sleep更精 确的计时器。(回忆10.19节，sleep等待整数秒，而对于select,其等待的时间可以小于Is, 其实际分辨率取决于系统时钟。)习题14.6给出了这样一个函数。
select的第一个参数wax/办•/的意思是“最大描述符加1”。在三个描述符集中找出最大描 述符编号值，然后加1,这就是第一个参数值。也可将第一个参数设置为FD_SETSIZE,这是 uys/select.h〉中的一个常量，它说明了最大的描述符数(经常是1 024)。但是对大多数应 用程序而言，此值太大了，多数应用程序只使用3~10个描述符。(某些应用程序使用更多的描 述符，但这种UNIX程序并不具代表性。)如果将第三个参数设置为我们所关注的最大描述符编 号值加1，内核就只需在此范围内寻找打开的位，而不必在三个描述符集中的数百位内捜索。 例如，若编写下列代码：
fd_set readsec, writeset ?
FD_ZERO(&readset)；
FD_ZERO(&writeset);
FD一SET(0, &readset);
FD_SET(3, &readset);
FD_SET(1, &writeset)；
FD_SET(2, &writeset);
select(4, &readset, &writeset, NULL, NULL)；
那么，图14-9显示了这两个描述符集的情况。
fdO fdl fd2 fd3
 
这些位均未考察
writeset：
maxfdpl = 4
图14-9 select的示例描述符集
因为描述符编号从0开始，所以要在最大描述符编号值上加1。第一个参数实际上是要检查 的描述符数(从描述符0开始)。 select有三个可能的返回值。
(1)	返回值-1表示出错。出错是有可能的，例如在所指定的描述符都没有准备好时捕捉到 一个信号。在此种情况下，将不修改其中任何描述符集。
(2)	返回值0表示没有描述符准备好。若指定的描述符都没有准备好，而且指定的时间已经 超过，则发生这种情况。此时，所有描述符集皆被清0。
(3)	正返回值表示已经准备好的描述符数，该值是三个描述符集中已准备好的描述符数之 和，所以如果同一描述符已准备好读和写，那么在返回值中将其计为2。在这种情况下，三个 描述符集中仍旧打开的位对应于已准备好的描述符。
对于“准备好”的意思要作一些更具体的说明：
•若对读集ireadfds)中的一个描述符的read操作将不会阻塞，则此描述符是准备好的。 •若对写集(writefds)中的一个描述符的write操作将不会阻塞，则此描述符是准备好的。 •若异常状态集iexceptfds)中的一个描述符有一个未决异常状态，则此描述符是准备好的。
DBBD

 
384 ,第14章高级I/O
现在，异常状态包括(a)在网络连接上到达的带外数据，或者(b)在处于数据包模式的伪终 端上发生了某些状态。(Stevens[1990]的15.10节中说明了后一种状态。)
•对于读、写和异常状态，普通文件描述符总是返回准备好。
应当理解，一个描述符阻塞与否并不影响select是否阻塞。也就是说，如果希望读一个非阻 塞描述符，并且以超时值为5s调用select,则select最多阻塞5s。相类似地，如果指定一个 无限的超时值，则在该描述符数据准备好或捕捉到一个信号之前， select— 直阻塞。
如果在一个描述符上碰到了文件结尾处，则select认为该描述符是可读的。然后调用 read,它返回0，这是UNIX系统指示到达文件结尾处的方法。(很多人错误地认为，当到达文 件结尾处时，select会指示一个异常状态。)
POSIX.1也定义了一个select的变体，它被称为pselect。
#include csys/select
int pselect (int maxfdpl, fd一set ^restrict readfds,
fd_set * restrict writ^ds, fd一set * re strict exceptfds, const struct timespec * restrict tsptr, const sigset_t * restrict sigmask)；
返回值：准备就绪的描述符数，若超时则返回0,若出错则返回-1
除下歹丨〗几点外，pselect与select相同：
•	select的超时值用timeval结构指定，但pselect使用timespec结构。(回忆11.6节 中timespec结构的定义。)timespec结构以秒和纳秒表示超时值，而非秒和微秒。如 果平台支持这样精细的粒度，那么timespec就提供了更精准的超时时间。
•	pselect的超时值被声明为const,这保证了调用pselect不会改变此值。
•对于pselect可使用一可选择的信号屏蔽字。若sigmask为空，那么在与信号有关的方面, pselect的运行状况和select相同。否则，■skmad指向一信号屏蔽字，在调用 pselect时，以原子操作的方式安装该信号屏蔽字。在返回时恢复以前的信号屏蔽字。
14.5.2	poll函数
poll函数类似于select,但是其程序员接口则有所不同。我们将会看到，虽然poll函 数可用于任何类型的文件描述符，但它起源于系统V,所以poll与STREAMS系统紧紧相关。
#include <poll.h>
int poll (struct pollfd fdarray[] , nfds_t nfds, int timeout)；
返回值：准备就绪的描述符数，若超时则返回0,若出错则返回-1
与select不同，poll不是为每个状态(可读性、可写性和异常状态)构造一个描述符集，而
是构造一个pollfd结构数组，每个数组元素指定一个描述符编号以及对其所关心的状态。
struct pollfd {
int fd；
short events；
short revents；
}；
/办7町数组中的元素数由《/办说明。
/* file descriptor to check, or <0 to ignore */ /* events of interest on fd */
/* events that occurred on fd */

 
14.5 I/O多路转接 385
由于历史原因，声明w/治参数有几种不同的方式。SVR3说明n/ds的类型为unsigned long,这似 乎是太大了。在SVR4手册[AT&T 1990d]中，poll原型的第二个参数的数据类型为size一t (见表2-16 中的基恭系统数据类型)E但在<poll.h>包含的实际原型中，第二个参数的数据类型仍说明为 unsigned long。Single UNIX Specification定义了新类型nfds_t，该类型允许实现选择对其合适的类 型并且隐藏了应用细节。注意，因为返回值表示数组中满足事件(events)的项数，所以这种类型必须 大得足以保持一个整型。
SVR4 的 SVID[AT&T1989]说明 poll 的第一个参数是 struct pollfd fdarrayl ],而 SVR4 手册页 [AT&T 1990 d]则说明该参数为struct pollfd	在C语言中，这两种说明是等价的《我们使
用系一种说明以重申指向一个结构数组，而不是指向单个结构的指针。
应将每个数组元素的events成员设置为表14_6中所示的值。通过这些值告诉内核我们对 该描述符关心的是什么。返回时，内核设置revents成员，以说明对于该描述符已经发生了什 么事件。(注意，poll没有更改events成员，这与select不同，select修改其参数以指不 哪一个描述符已准备好了。)
表 14-6 poll 的events和revents标志
标志名	输人至
events?	从revents 得到结果？	■ 说明
P0LLIN		•	不阻塞地可读除高优先级外的数据(等效干POLLRDNOKMI POLLRDBAND)
P0LLRDN0RM		•	不阻塞地可读普通数据(优先级波段为⑴
P0LLRDBAND		•	不阻塞地可读非0优先级波段数据
P0LLPRI		•	不阻塞地可读高优先级数据
P0LL0UT		•	不阻塞地吋写普通数据
P0LLWRN0RM		•	与POLLOUT相同
POLLWRBAND		•	不PR塞地可写非0优先级波段数据
P0LLERR		•	已出错
P0LLHUP		•	已挂断
P0LLNVAL		•	描述符不引用-打开文件
表14-6中头四行测试可读性，接着三行测试可写性，最后三行则是测试异常状态。最后三 行是由内核在返回时设置的。即使在events字段中没有指定这三个值，如果相应条件发生， 则在r event s中也返回它们。
当一个描述符被挂断(P0LLHUP)后，就不能再写向该描述符。但是仍可能从该描述符读 取到数据。
poll的最后一个参数说明我们愿意等待多少时间。如同select—样，有三种不同的情形： timeout == -1永远等待。(某些系统在<stropts.h>中定义了常量INFTIM，其值通常 是-1。)当所指定的描述符中的一个已准备好，或捕捉到一个信号时则返 回。如果捕捉到一个信号，则poll返回-1, errno设冒;为EINTR。 timeout == 0 不等待。测试所有描述符并立即返回。这是得到很多个描述符的状态而 不阻塞poll函数的轮询方法。 timeout > 0 等待f/weoM?毫秒。当指定的描述符之一已准备好，或指定的时间值已超 过时立即返回。如果已超时但是还没有一个描述符准备好，则返回值是0。 (如•统不提供毫秒分辨率，则值取整到最近的支持值。)
[4791


 
386 第14章高级I/O
■ 应当理解文件结束与挂断之间的区别。如果正从终端输入数据，并键入文件结束字符, POLLIN被打开，于是就可读文件结束指示(read返回0)。POLLHUP在revents中没有打开。 如果正在读调制解调器，并且电话线已挂断，则在revents中将接到POLLHUP通知。
与select—样，不论一个描述符是否阻塞，都不影响poll是否阻塞。 select和poll的可中断性
中断的系统调用的自动再启动是由《2BSD引进的(见10.5节)，但当时select函数是不再 启动的。这种特性在大多数系统中一直延续了下来，即使指定了SA—RESTART也是如此。但是， 在SVR4之下，如果指定了SA—RESTART，那么select和pol 1也是自动再启动的。为了在将 软件移植到SVR4派生的系统上时防止这一点，如果信号可能中断对seiect或pol_调用， 则总是使用signal_intr函数(见程序清单10-13)。
本书说明的各种实现在接到一信号时都不重启动poll和select，即便使用了 SAJRESTART标志也 是如此。
14.4	异步I/O
一使用上一节说明的select和poll可以实现异步形式的通知。关于描述符的状态，系统并不 主动告诉我们任何信息,我们需要进行查询(调用select或poll)。如在第10章中所述，信号 机构提供一种以异步形式通知某种事件已发生的方法。由BSD和系统V派生的所有系统提供了 使用一个信号(在系统V中是SIGPOLL,在BSD中是SIGIO)的异步I/O方法，该信号通知进程 某个描述符已经发生了所关心的某个事件。
我们已了解到select和poll对任意描述符都能工作。但是关于异步I/O却有限制。在系统V派生 的系统中，异步I/O只对STREAMS设备和STREAMS管道起作用。在BSD派生的系统中，异步I/O只对 终端和丹络起作用。
异步I/O的一个限制是每个进程只有一个信号。如果要对几个描述符进行异步i/o,那么在 进程接收到该信号时并不知道这一信号对应于哪一个描述符。
Single UNIX Specification包括一个可选择的通用异步i/o机制’这取自实时萆案标准。它与本节所 说明的机制无关。该机制解决了老的异步I/O机制存在的很多限制问题，但在此处不作进一步讨论。
14.6.1系统V异步I/O
在系统V中，异步I/O是STREAMS系统的一部分。它只对STREAMS设备和STREAMS管道 [4811起作用。系统V的异步I/O信号是SIGPOLL。
为了对一个STREAMS设备启动异步1/0’需要调用ioctl,它的第二个参数Request、 是I_SETSIG。第三个参数是由表14-7中的常量构成的整型值。这些常量在<stroPts.h;^ 定义。
表14-7中“已到达”的意思是“已到达流首的读队列”。
除了调用ioctl说明产生SIGPOLL信号的条件以外，还应为该信号建立信号处理程序。回 忆表10-1,对于SIGPOLL的默认动作是终止该进程，所以应当在调用ioctl之前建立信号处理 程序。

 
14.7 readv和writev函數 387
表14-7产生SIGPOLL倍号的条件
常量	说明
S_INPUT	非高优先级消息已到达
S一RDNORM	普通消息已到达
S_RDBAND	非0优先级波段消息已到达
S_BANDURG	若此常量和S—RDBAND—起指定，则当一非0优先级波段消息已到达时，产生SIGURG信号而非
	SIGPOLL
S_HIPRI	高优先级消息已到达
S一OUTPUT	写队列不再满
S_WRN0RM	与3_01^^1；11'相同
S_WRBAND	可发送非0优先级波段消息
S 一MSG	包含SIGPOLL信号的STREAMS信号消息已到达
S—ERROR	M_ERR0R消息已到达
S—HANGUP	M_HANGUP消息已到达
14.6.2 BSD异步 I/O
在BSD派生的系统中，异步I/O是SIGIO和SIGURG两个信号的组合。前者是通用异步I/O信 号，后者则只用来通知进程在网络连接上到达了带外的数据。
为了接收SIGIO信号，需执行下列三步：
(1)	调用signal或sigaction为SIGIO信号建立信号处理程序。
(2)	以命令F_SETOWN	(见3.14节)调用fcntl来设置进程ID和进程组ID,它们将接收对于 该描述符的信号。
(3)	以命令F_SETFL调用fcntl设置0_ASYNC文件状态标志，使在该描述符上可以进行异 步I/O (见表3-3)。
第(3)步仅能对指向终端或网络的描述符执行，这是BSD异步I/O设施的一个基本限制。
对于SIGURG信号，只需执行第(1)步和第(2)步。该信号仅对引用支持带外数据的网络连接 描述符而产生。
14.5	readv■和writev■函数
readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个 函数称为散布读(scatterread)和聚集写(gatherwrite)。
#include <sys/uio.h>
ssize_t readv (int filedes• const struct iovec *iov, int iavcnt)； ssize一t writev (int filedes, const struct iovec *iovt int iovcnt)；
两个函数返回值：若成功则返回已读、写的字节数，若出错则返回_1
这两个函数的第二个参数是指向iovec结构数组的一个指针：
struct iovec {
void *iov_base； /* starting address of buffer */ size一t iov—len; /* size of buffer */

 
388 第14章高级I/O
,_ov数组中的元素数由kvc/Jf说明。其最大值受限干IOV—MAX (参见表2-10)。图14-10显示了 readv和wr i t ev的参数和i ovec结构。
iov [0]	.iov	base
ioy [0]	• iov	_len
iw [1]	.iov_	•base
iov [1】	• iov	len
iov [iovcnt-1] • iov	base
iov [Kwcwf—2]	iov	len
 
間 14-】0 readv和writev的 iovec结构
writev以顺序,ov[0],丨'ov[7]至/ov[i'ovc/jf-7]从缓冲区中聚集输出数据。writev返回输出的 字节总数，通常，它应等干所有缓冲区长度之和。
readv则将读入的数据按上述同样顺序散布到缓冲区中。readv总是先填满一个缓冲区，然 后再填写下一个。readv返回读到的总字节数。如果遇到文件结尾，已无数据可读，则返回0。
这两个函数始于4.2BSD,后来SVR4也提供它们。在Single UNIX Specification的XSI扩展中包括了
这两个函数。
虽然Single UNIX Specification将缓冲区地址定义为void *类型，但在该标准前就已存在的很多实 现仍使用char *。
实例
在20.8节的_db_writeidx函数中，需将两个缓冲区内容连续地写到一个文件中。第二个 缓冲区是调用者传递过来的一个参数，第一个缓冲区是我们创建的，它包含了第二个缓冲区的 长度以及在文件中其他信息的偏移量。有三种方法可以实现这一要求：
(1)	调用write两次，一次-个缓冲区。
(2)	分配一个大到足以包含两个缓冲区的新缓冲区。将两个缓冲区的内容复制到新缓冲区 中。然后对该缓冲区调用write—次。
(3)	调用writev输出两个缓冲区。
20.8节中使用了writev，但是将它与另外两种方法进行比较，对我们是很有启发的。 表14-8显示了 _h面所述三种方法的结果。
表14-8比较writev和其他技术所得的时间结果
操作	Linux (Intel x86)	Mac OS X (PowerPC)
	用户	系统	时钟	用户	系统	时钟
-•-次 write	1.29	3.15	7.39	1.60	17.40	19.84
复制绥冲区，然后-次write	1.03	1.98	6.47	1.10	11.09	12.54
-次 writev	0.70	2.72	6.41	0.86	13.58	14.72
所用的测试程序输出100字节的头文件，接着又输出200字节的数据。这样做1 048 576次， 产生了一个300MB的文件。该程序按上面描述的3种方法分别编写了3个版本。使用times

 
14.8 readn和writen函数 389
(8.16节)测得它们在写操作前、后各使用的用户CPU时间、系统CPU时间和时钟时间。它们的 单位都是秒。
正如我们所预料的，调用write两次的系统时间较调用write或writev—次要长，这与 表3-2的结果类似。
接着要注意的是，在缓冲区复制后跟随一个write所用的CPU时间(用户加系统)要少干 调用writev—次所耗费的CPU时间。对于单一write情况，我们先将用户层次的两个缓冲区 复制至一个中间缓冲区，然后当调用write时内核将该中间缓冲区中的数据复制至其内部缓冲 区。对于writev的情况，因为内核只需将数据直接复制进其内部缓冲区，所以复制工作应当 少一些。但是，对干这种少量数据，使用writev的固定开销大干得益。随着需复制数据的增 加，程序中复制缓冲区的开销也会增多。此时，writev这种替代方法就会有更大的吸引力。
注意不要依据表148中的数字对Linux和MacOS X之间的相对性能作过多的推断。这两种计算机有 很大差别。它们有不同的处理器结构、不同量的RAM以及不同速度的磁盘。为了进行搮作系统之间的 比较，需要对每一种操作系统都使用相同的硬件。
□
总之，应当用尽量少的系统调用次数来完成任务。如果只写少量的数据，会发现自己夏制 数据然后使用一次write会比用writev更合算。但也可能发现，这样获得的性能提升并不值 得，因为管理中间缓冲区会增加程序的复杂度。
14.6	readn和writen函数
管道、FIFO以及某些设备,特别是终端、网络和STREAMS设备有下列两种性质：
(1)	- •次read操作所返回的数据可能少于所要求的数据，即使还没达到文件尾端也可能是 这样。这不是-个错误，应当继续读该设备。
(2)	—次write操作的返回值也可能少干指定输出的字节数。这可能是由若干因素造成的， 例如，下游模块的流量控制限制。这也不是错误，应当继续写余下的数据至该设备。(通常， 只有对非阻塞描述符，或捕捉到一个信号时，才发生这种write的中途返回。)
在读、写磁盘文件时从未见到过这种情况，除非文件系统用完了空间，或者我们接近了配 额限制，而不能将要求写的数据全部写出。
通常袅读、写一个管道、网络设备或终端时，我们需要考虑这些特性。下面两个函数 readn和writen的功能是读、写指定的W字节数据，并处理返回值小于要求值的情况。这两个 函数只是按需多次调用read和write直至读、写了N字节数据。
#include "apue.h"
ssize_t readn(int filedes, void *buf, size—t nbytes)；
ssize—t writen (int filedes• void *buf, Bize_t nbytes)；
两个函数返回值：已读、写字节数，若出错则返回-1
类似于本书很多实例所使用的出错处理例程，我们定义这两个函数的目的是便于在后面实例中使 用。readn和wri ten函数并非任何标准的组成部分。
在要将数据写到上面提到的文件类型上时，就可调用writen,但是只有当事先就知道要接 收数据的数量时，才调用readn (通常只调用read接收来自这些设备的数据)。程序清单14-11

 
390 第14章高级I/O
包含了writen和readn的一种实现，在后面的实例中，我们将使用它们。
程序清单14-11 readn和writen函数
#include 11 apue.h"
ssize_t	/* Read "n” bytes from a descriptor */
readn(int fd, void *ptr, size一t n)
s i ze_t ssize
nleft; nread;
nleft = n;
while (nleft > 0) {
if ((nread = read(fd, ptr, nleft)) < 0) { if (nleft == n)
return(-1); /* error, return -1 */
else
break；
} else if (nread break；
/*
0)
/*
error, return amount read so far */
EOF
Ptr
}
return (n
-=nread; nread；
nleft);
/* return >- 0 */
ssize一t writen(int fd, {
size__t ssize t
/* Write "n" bytes to a descriptor */ const void *ptrr size一t n)
nleft;
nwritten；
nleft = n;
while (nleft > 0) {
if ((nwritten = write(fd, ptr, nleft)
if (nleft == n)
return(-1);
else
break;
} else if (nwritten
break；
/* error, return
/* error, return ==0) {
)< 0) {
-1 */
amount written so far */
nleft
ptr
nwritten;
nwritten;
return(n - nleft);
/* return 0 */
485
i
486
注意，若在已经读、写了一些数据后出错，则这两个函数返回已传输的数据量，而非出错 返回。与此类似，在读时如达到文件尾，而且在此之前已成功地读了一些数据，但尚未满足所 要求的量，则readn返回已复制到调用者缓冲区中的字节数。
14.9存储映射I/O
存储映射I/O (Memory-mapped I/O)使一个磁盘文件与存储空间中的一个缓冲区相映射。 于是当从缓冲区中取数据，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区，则

 
14.9存储映射I/O 391
相应字节就自动地写入文件。这样就可以在不使用read和write的情况下执行I/O。
存储映射I/O伴随溫拟存储系统已经用了很多年。4.1BSD (1981)以其vread和vwrite函数提供 了一种不同形式的存储映射I/O。4.2BSD没有使用这两个函数，而是企图换成nrnap函数。但是由于 McKusick ei al. [1996] 2.5节中说明的理由，4.2BSD实际上并没有包含mmap函数。Gingell,Moran和 Shannon[1987]说明了mmap的一种实现。现在，Single UNIX Specification存储映斯文件选项中包括了 _p函数，在遵循XSI的系统中则应包含此函数。大多数UNIX系统都支持mmar■函数
为了使用这种功能，应首先告诉内核将一个给定的文件映射到一个存储区域中。这是由 iranap函数实现的。
ttinclude <sys/mman.h>
void *mmap(void *addrg size_t lent int prot, int flag, int filedes, off_t off)；
返回值：若成功则返回映射区的起始地址，若出错M返冋map_failed
参数用干指定映射存储区的起始地址。通常将其设置为0，这表示由系统选择该映射 区的起始地址。此函数的返回地址是该映射区的起始地址。
指定要被映射文件的描述符。在映射该文件到一个地址空间之前，先要打开该文件。 /en是映射的字节数。c#是要映射字节在文件中的起始偏移量(下面将说明对0#直有某些限制)。 pwf参数说明对映射存储区的保护要求，见表14-9。
表14-9映射存储区的保护要求
prot	说明
PR0T„READ PROT_WRITE PR0T_EXEC PROT 一 NONE	映射区可读 映射区可写 映射区可执行 映射区不可访问
可将prof参数指定为PROT_NONE,或者是PR0T_READ、PROT_WRITE、PR0T_EXEC任意组合 的按位或。对指定映射存储区的保护要求不能超过文件open模式访问权限。例如，若该文件 是只读打开的，那么对映射存储区就不能指定PROT_WRITE。
在说明/kg参数之前，先看一下存储映射文件的基本情况。图14-11显示了一个存储映射文 件。(见图7-3中进程存储空间的典型安排情况。)在此图中，“起始地址”是iranap的返回值。映 射存储区位于堆和找之间，这属于实现细节，各种实现之间可能不尽相同。
//叩参数影响映射存储区的多种属性：
MAP_FIXED 返回值必须等于addr。因为这不利于可移植性，所以不鼓励使用此标志。
如果来指定此标志，而且addr非0，则内核只把addr视为在何处设置映 射区的一种建议，但是不保证会使用所要求的地址。将addr指定为0可获 得最大可移植性。
在遵循POSIX的系统中，对MAP—FIXED的支持是可选择的，但遵循XSI的系统则要求支持
MAP—FIXED,
MAP_SHARED 这一标志说明了本进程对映射区所进行的存储操作的配置。此标志指定

 
392 第14章高级I/O
存储操作修改映射文件，也就是说，存储操作相当于对该文件的write。 必须指定本标志或下一个标志(MAP PRIVATE),但不能同时指定两者。 MAP_PRIVATE本标志说明，对映射区的存储操作导致创建该映射文件的.个私有副本。
所有后来对该映射区的引用都是引用该副本，而不是原始文件。(此标志 的一种用途是用于调试程序，它将一程序文件的正文部分映射至一存储 区，但允许用户修改其中的指令。任何修改只影响程序文件的副本，而 不影响原文件。)
每种实现都可能还有另外-些MAP_xxx标志值’它们是这种实现所特有的。详细情况请参见你 所使系统的mmap(2)手册页。
高地址
len
起始地址-
低地址
	
栈	
	
文件的映射 存储区部分	
	文件:
堆	
未初始化数据< bss)	
已初始化数据	
文本	
文件的映射 存储k部分
Off
图14-11存储映射文件的例子
的值(如果指定了MAP_FIXED)通常应当是系统虚存页长度的倍数。虚存页长 口J 用带参S_SC_PAGESIZE或—SC—PAGE—SIZE的sysconf 函数(见2.5.4节)得到。因为咐 和atWr常常指定为0,所以这种要求-•般并不重要。
因为映射文件的起始偏移量受系统虚存页长度的限制，那么如果映射区的长度不是页长的 整数倍时’将如何呢？假定文件长12字宵’系统页长为512字节’则系统通常提供512字节的映 射区，其中后500字节被设置为0。可以修改这500字节，但任何变动都不会在文件中反映出来。 于是’我们不能用mmap将数据添加到文件中。为了做到这一点，我们必须首先加长该文件， 这将示于程序清单14-12中。
与映射存储区相关的有SIGSEGV和SIGBUS两个信号。信号SIGSEGV通常j于指示进程试
图访问对它不可用的存储区。如果进程企图存数据到mmap指定为只读的映射存储区，那么也
产生此信号。如果访问映射区的某个部分，而在访问时这一部分实际上已不存在，则产生
SIGBUS信号。例如，用文件长度映射了--个文件，但在引用该映射区之前’另一个进程已将
该文件截短，此时’如果进程企图访问对应于该文件已截去部分的映射区，则会接收到 SIGBUS 信号。

 
14.9存储映射I/O 393
在调用fork之后，子进程继承存储映射区(因为子进程复制父进程地址空间，而存储映 射区是该地址空间中的一部分)，但是由于同样的理由，调用exec后的新程序则不继承此存储 映射区。
调用mprotect可以更改一个现存映射存储区的权限。
#include <sys/mman.h>
int mprotect (void *addr, size一t len, int prot)；
返回值：若成功则返回0，若出错则返回一丨
prof的许可值与mmap中prof参数一样(表14-9)。地址参数的值必须是系统页长的整 数倍。
在Single UNIX Specification中，mprotect函数是存储保护选项中的组成部分，遵循XSI的系统要 求支持它。
如果在共享存储映射区中的页已被修改，那么我们可以调用msync将该页冲洗到被映射的 文件中。msync函数类似于fsync (3.13节)，但作用于存储映射区。
#include <sys/mman.h>	
int msync (void *addr• size_t len, int flags) ?	
	返回值：若成功则返回0，若出错则返冋-1
如果映射是私有的，那么不修改被映射的文件。与其他存储映射函数一样，地址必须与页 边界对齐。
供参数使我们对如何冲洗存储区有某种程度的控制。我们可以指定MS_ASYNC标志以简 化被写页的调度。如果我们希望在返回之前奪待写操作完成，则可指定MS_SYNC标志。一定要 指定MS_ASYNC和MS—SYNC中的一个。
MS_INVALIDATE是一个可选标志，使用它们以通知操作系统丢弃与底层存储器没有同步 的任何页。若使用了此标志，某些实现将丢弃在指定范围中的所有页，但这并不是所期望的。 进程终止时，或调用了nrnmnap之后，存储映射区就被自动解除映射。关闭文件描述符 并不解除映射区。
#include <sys/mman.h>	
int munmap (caddr_t addr, size—t len)；	
	返冋值：若成功则返回0，若出错则返丨o|-1
munmap不会影响被映射的对象，也就是说，调用munmap不会使映射区的内容写到磁盘文 件上。对于MAP_SHARED区磁盘文件的更新，在写到存储映射区时按内核虚存算法自动进行。 在解除了映射后，对于map_private存储区的修改被丢弃。
实例
程序清单14-12用存储映射I/O复制一个文件(类似于cp(l)命令)。

 
394 第14章高级I/O
程序清单14-12用存储映射I/O复制文件
#include "apue.h"
#include <fcntl.h>
#include <sys/mman.h>
int
main(int argc, char *argv[])
{
int	fdin, fdout;
void	*src, *det；
struct stat statbuf；
if (argc != 3)
err一quit ("usage: %s <fromfile> <tofile>'*# argvtO])；
if ((fdin = open(argv[1]# 0_RD0NLY)) < 0)
err一sys("can,t open %b for reading", argv[l])；
if ((fdout = open(argv[2]f 0_RDWR | O—CREAT | O一TRUNC, FILE—MODE)) < 0)
err_syB(Mcan,t creat %s for writing", argv[2])；
if (fstat(fdin, &statbuf) c 0) /* need size of input file */ err一sys("fstat error")；
/* set size of output file */
if (lseek(fdout, statbuf.st_size 1, SEEK—SET) == -i) err_sys("lseek error")； if (write(fdout, "1) !« 1) err一sys("write error")；
if ((src = mmap(0f statbuf.st_size, PROT一READ, MAP一SHARED, fdin, 0)) == MAP一FAILED)
err—sys("mmap error for input"};
if ((dst = mmap(0, statbuf.Bt_size# PROT一READ f PROT WRITE, MAP—SHARED, fdout, 0)) == MAP一FAILED) err一sys("mmap error for output"};
memcpy{dst, src, statbuf.Bt一size); /* does the file copy */ exit(0)；
该程序首先打开两个文件，然后调用fstat得到输入文件的长度。在为输入文件调用 皿nap和设置输出文件长度时都需使用输入文件长度。调用iseek，然后写一个字节以设置输 出文件的长度。如果不设S输出文件的长度，则对输出文件调用mmap也可以，但是对相关存 储区的第一次引用会产生SIGBUS。也可使用ftruncate函数来设置输出文件的长度，但是并 非所有系统都支持该函数扩充文件长度(见4.13节)。
在本书讨论的四种平台上，都可用ftruncateif■展文件。
然后对每个文件调用iranap,将文件映射到存储区，最后调用memcpy将输入缓冲区的内容 复制到输出缓冲区。在从输入缓冲区(src)取数据字节时，内核自动读输入文件，在将数据 存入输出缓冲区(dst)时，内核自动将数据写到输出文件中。
数据被写入文件的确切时间依赖于系统的页管理算法。某些系统设置了守护进程，在系统运行期

 
14.10 小 结 395
间.它“慢条斯理”地将脏页写到磁盘上。如果想要确保数据安全地写到文件中，则需在进程终止前
以MS一SYNC标志调用msync。
将存储区映射复制与用read, write进行的复制(缓冲区长度为8 192)相比较，得到表 14-10中所示的结果。其中，时间单位是秒，被复制文件的长度是300MB。
表14-10 read/write与mmap/memcpy比较的时间结果
橾作	Linux 2.4.22 (Imel x86)	Solans 9 (SPARC)
	用户	系统	时钟	用户	系统	时钟
read/write	0.04	1.02	39.76	0.18	9.70	41.66
mmap/memcpy	0.64	1.31	24.26	1.68	7.94	28.53
对于Solaris 9，两种复制方式的CPU时间(用户+系统)几乎相同：9.88s对9.62s。对于 Linux 2.4.22，iranap/memcpy方式的CPU时间大约是read/write方式的两倍。这种差别可能 是由两种系统实现在处理时间计算方面所使用的方法不同而造成的。
如果考虑到时钟时间，那么皿nap和memcpy方式较read和write方式要快。这是合情合 理的。使用mmap和memcpy时做的工作要少。用read和write时，要先将数据从内核缓冲区 复制到应用程序缓冲区(read),然后又将应用程序缓冲区中的数据复制至内核缓冲区 (write)。用mmap和memcpy时，则直接将映射到应用程序地址空间的一个内核缓冲区中的数 据复制到另一个同样映射到应用程序地址空间中的内核缓冲区中。
将一个普通文件复制到另一个普通文件中时，存储映射i/o比较快。但是有一些限制，例 如，不能用其在某些设备(例如网络设备或终端设备)之间进行复制，并且在对被复制的文 件进行映射后，也要注意该文件的长度是否改变。尽管如此，某些应用程序会从存储映射i/o 得到好处，因为它处理的是存储空间而不是读、写一个文件，所以常常可以简化算法。从存 储映射I/O中得益的一个例子是对帧缓冲区设备的操作，该设备引用一个位图式显示(bit- mapped display)。
Krieger,Stumm和Unraup[ 1992]第5章说明了一个使用存储映射1/◦的标准I/O库。
15.9节将回过头来讨论存储映射I/O,用-个例子说明如何使用存储映射I/O在有关进程间 提供共享存储区。
14.10小结
本章说明了很多高级i/o功能，其中大多数将在后面章节的例子中使用：
•非阻塞I/o——发一个I/O操作，不使其阻塞。
•记录锁(在第20章数据库函数库中有一个实例，将对此作更详细的讨论)。
•系统V流机制(在第17章中，我们将需要使用这部分内容以理解基于STREAMS的管道、 传送文件描述符以及系统V的客户/服务器连接)。
•I/O多路转接——select和poll函数(后面的很多实例将用到这两个函数)。
•	readv和writev函数(后面的很多实例也将用到这两个函数)。
•存储映射I/O (iranap)。
回
回

 
396 第14章高级I/O
习题
14.1编写一个测试程序以说明你所用系统在下列情况下的运行情况：一个进程在试图对一个 文件的某个范围加写锁的时候阻塞’之后其他进程又提出了一些相关的加读锁请求。试 图加写锁的进程会不会因其他进程的行为而饿死？
14.2查看你所用系统的头文件，并研究select和四个FD_宏的实现。
14.3	系统头文件通常对fd_set数据类型可以处理的最大描述符数有一个内置的限制，假设需 要将描述符数限制增加到2 048,该如何实现？
14-4比较处理信号集的函数(见10.11节)和处理fd_set描述符集的函数，并比较在你的系 统上实现它们的方法。
14.5 getmsg可以返回多少种不同的信息？
14.6	用select或poll实现一个与sleep类似的函数sieep_us，不同之处是要等待指定的 若干微秒。比较这个函数和BSD中的usleep函数。
14.7是否可以利用建议性记录锁来实现程序清单10-17中的函数TELL_WAIT、 TELL_PARENT, TELL一CHILD、WAIT_PARENT以及WAIT_CHILD?如果可以’编写这些函数并测试其功能。
14.8用非阻塞写测试管道的容量。将其值与第2章的PIPE_BUF的值比较。
14.9回忆表14-8,在你的系统上找到一个转折点，从此点开始，使用writev将快于你自己复 制数据并使用单个write。
14.10运行程序清单14-12所列程序复制一个文件’检查输入文件的上一次访问时间是否改 变了？
14.11在程序清单14-12中，在调用_ap后调用close关闭输入文件，以验证关闭描述符不会 使内存映射I/O失效。

 

