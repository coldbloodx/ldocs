第3章 文件I/O 
3.1 引言 
	本章开始讨论UNIX系统，先说明可用的文件I/O函数——打开文件、读文件、写文件等。UNIX系统中的大多数文件I/O只需用到5个函数：open、read、write、lseek以及close。然后说明不同缓冲区长度对read和write函数的影响。 
	本章所说明的函数经常被称为不带缓冲的I/O (unbuffered I/O,与将在第5章中说明的标准I/O例程相对照）。术语不带缓冲指的是每个read和write都调用内核中的一个系统调用。这些不带缓冲的I/O函数不是ISO C的组成部分，但是，它们是POSIX.1和Single UNIX Specification 的组成部分。
	只要涉及在多个进程间共享资源，原子操作的概念就变得非常重要。我们将通过文件I/O和open函数的参数来讨论此概念。然后，本章将进一步讨论在多个进程间如何共享文件，以及所涉及的内核数据结构。在讨论了这些特征后，将说明dup、fcntl、sync、fsync和ioctl 函数。 

3-2文件描述符
	对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读或写一个文件时，使用open或creat返回的文件描述符标识该文件，将其作为参数传送给read或write。
	按照惯例，UNIX系统shell使用文件描述符0与进程的标准输入相关联，文件描述符1与标准输出相关联，文件描述符2与标准出错输出相关联。这是各种shell以及很多应用程序使用的惯例，而与UNIX内核无关。尽管如此，如果不遵照这种惯例，那么很多UNIX系统应用程序就 不能正常工作。
	在依从POSIX的应用程序中，幻数0、1、2应当替换成符号常量STDIN_FILENO、STD0UT_FILEN0和STDERR_FILENO。这些常量都定义在头文件<unistd. h>中。 文件描述符的变化范围是0~OPEN_MAX(见表2-10)。早期的UNIX系统实现采用的上限值 是19 (允许每个进程最多打开20个文件），但现在很多系统则将其增至63。 对于FreeBSD5.2.1、Mac OS X10.3以及Solaris 9，文件描述符的变化范围实际上是无限的，它只受到系统配置的存储器总量、整型的字长以及系统管理员所R置的软限制和硬限制的约束。Linux 2.4.22对于每个进程的文件描述符数的硬限制是1048576。
 
3.3	open函数
	调用open函数可以打开或创建一个文件。
#include <fcntl.h>
int open (const char *pathname, int oflag, ... /* mode_t mode */ )；
	返回值：若成功则返回文件描述符，若出错则返回-1
	我们将第三个参数写为...，ISO c用这种方法表明余下参数的数量及其类型根据具体的调用会有所不同。对于open函数而言，仅当创建新文件时才使用第三个参数（稍后将对此进行说明）。在函数原型中将此参数放置在注释中。
	pathname是要打开或创建文件的名字。研即参数可用来说明此函数的多个选项。用下列一个或多个常量进行或运算构成oflag参数（这些常量定义在<fcntl .11>头文件中）：
	
O_RDONLY 只读打开。
O_WRONLY 只写打开。
O_RDWR 读、写打开。

	大多数实现将O_RDONLY定义为0, O_WRONLY定义为1, O_RDWR定义为2，以与早期的程序兼容。
	在这三个常量中必须指定一个且只能指定一个。下列常量则是可选择的：
O_APPEND 每次写时都追加到文件的尾端。3.11节将详细说明此选项。
O_CREAT 若此文件不存在，则创建它。使用此选项时，需要第三个参数/no办，用其指定该新文件的访问权限位（4.5节将说明文件的访问权限位，那时就能了解如何指定mode,以及如何用进程的umask值修改它)。
O_EXEL 如果同时指定了O一CREAT，而文件已经存在，则会出错。用此可以测试一个文件是否存在，如果不存在，则创建此文件，这使测试和创建两者成为一个原子操作。3.11节将更详细地说明原子操作。
O_TRUNC 如果此文件存在，而且为只写或读写成功打开，则将其长度截短为0。
O_NOCTTY 如果指的是终端设备，则不将该设备分配作为此进程的控制终端。9.6节将说明控制终端。
O_NOBLOCK 如果指的是一个HFO、一个块特殊文件或一个字符特殊文件则此选项为文件的本次打开操作和后续的I/O操作设置非阻塞模式。14.2节将说明此工作模式。
	较早的系统V版本引入了O_NDELAY (不延迟）标志，它与O_NONBLOCK (不阻塞）选项类似，但它的读操作返回值具有二义性。如果不能从管道、FIFO或设备读取数据，则不延迟选项使read返回0， 这与表示已读到文件尾端的返回值0相冲突。基于SVR4的系统仍支持这种语义的不延迟选项，但是新的座用埕序应当使用不阻塞选项代替之。
	下面三个标志也是可选的。它们是Single UNIX Specification (以及POSIX.1)中同步输入 和输出选项的一部分。

O_DSYNC 使每次write等待物理I/O操作完成，但是如果写操作并不影响读取刚写入 的数据，则不等待文件属性被更新。
O_RSYNC 使每一个以文件描述符作为参数的read操作等待，直至任何对文件同一部 分进行的未决写操作都完成。
O_SYNC 使每次write都等到物理1/O操作完成，包括由write操作引起的文件属性 更新所需的I/O。3.14节将使用此选项。

	O_DSYNC和O_SYNC标志有微妙的区别。仅当文件属性需要更新以反映文件数据变化（例如更新文件大小以反映文件中包含了更多的数据）时，O_DSYNC标志才影响文件属性。而设置O—SYNC标志后，数据和属性总是同步更新t当文件用O_DSYN标志打开，在重写其现有的部分内容时，文件时间属性不 会同步更新。与此相反，如果文件是用O_SYNC标志打开，那么对该文件的每一次write操作都将在 write返回前更新文件时间，这与是否改写现有字节或增写文件无关。
	Solaris 9支持所有这三个标志。FreeBSD 5.2.1和Mac OS X 10.3设置了另外一个标志（O—FSYNC),它与标志O_SYNC的作用相同。因为这两个标志是等效的，所以FreeBSD 5.2.1定义它们为同一值（但奇怪的是，Mac OS X 10.3没有定义O_SYNC)„ FreeBSD 5.2.1 和Mac OS X 10.3不支持O—DSYNC或O_RSYNC 标志。Linux 2.4.22将它们处理成与O_SYNC相同。

	由open返回的文件描述符一定是最小的未用描述符数值。这一点被某些应用程序用来在标准输入、标准输出或标准出错输出上打开新的文件。例如，一个应用程序可以先关闭标准输出（通常是文件描述符1),然后打开另一个文件，执行打开操作前就能了解到该文件一定会在文件描述符1上打开。在3.12节说明dup2函数时，可以了解到有更好的方法来保证在一个给定的描述符上打开-个文件。

文件名和路径名截短
	如果NAME_MAX是14，而我们却试图在当前目录中创建一个其文件名包含15个字符的新文件，此时会发生什么呢？按照传统，早期的系统V版本（例如SVR2)允许这种使用方法，但总是将文件名截短为14个字符，而且不给出任何信息，而BSD类的系统则返回出错状态，并将errno设置为ENAMETOOLONG。无声无息地截短文件名会引起问题，而且它不仅仅影响到创建并且存在一个其文件名恰好就是14个字符的文件，那么以pathname作为其参数的任一函数（open、stat等）都无法确定该文件的原始名是什么？其原因是这些函数无法判断该文件名是否被截短过。
在POSIX.1中，常量_£>0315(_1^0」11«：1«：决定了是要截短过长的文件名或路径名，还是返回一个出错。正如我们在第2章中已见过的，根据文件系统的类型，此值可以变化。
是否返回一个出错值在很大程度上是历史形成的。例如，基于SVR4的系统对传统的系统V文件系统（S5)并不产生出错返回，但是它对BSD风格的文件系统（UFS)则产生出错返回。
作为另一个例子，参见表2-15。Solaris对UFS返回出错，对与DOS兼容的文件系统PCFS则不返回出错，其原因是DOS会无声无息地截短不适配8.3格式的文件名。BSD类系统和Linux总是会返回 出错。
g_POSIX_NO_TRUNC有效，则在整个路径名超过PATH_MAX，或路径名中的任一文件名超过NAME_MAX时，返回出错状态，并将errno设置为ENAMETOOLONG。

3.4	creat 函数
也可调用creat函数创建一个新文件。

#include <fcntl.h>
int creat (const char * pathname, mode_t mode)；
返回值：若成功则返回为0，只写打开的文件描述符，若出错则返回 -1
[62]注意，此函数等效于：
open (pathname, O_WRONLY | O_CREAT | O_TRUNC, mode)；
    在早期的UNIX系统版本中，open的第二个参数只能是0、1或2。没有办法打开一个尚未存在的文件，因此需要另一个系统调用creat以创建新文件。现在，open函数提供了选项O_CREAT和O—TRUNC，于是也就不再需要creat函数。
    在4.5节中，我们将详细说明文件访问权限（file’s access permission),并说明如何指定㈣办。creat的一个不足之处是它以只写方式打开所创建的文件。在提供open的新版本之前，如果要创建一个临时文件，并要先写该文件，然后又读该文件，则必须先调用creat、close,然后再调用open。现在则可用下列方式调用open:
open (pathname, O_RDWR | O_CREAT | O_TRUNCf mode)；

3.5	close函数
    可调用close函数关闭一个打开的文件:
#include <unistd.h>	
int close (int filedes)；	
	返回值：若成功则返回0，若出错则返回-1
    关闭一个文件时还会释放该进程加在该文件上的所有记录锁。14.3节将讨论这一点。
    当一个进程终止时，内核自动关闭它所有打开的文件。很多程序都利用了这一功能而不显式地用dose关闭打开文件。实例见程序清单1-2中的程序。
3.6	lseek 函数
    每个打开的文件都有一个与其相关联的“当前文件偏移量”（current file offset)。它通常是一个非负整数，用以度量从文件开始处计算的字节数（本节稍后将对“非负”这一修饰词的某些例外进行说明）。通常，读、写操作都从当前文件偏移量处开始，并使偏移量增加所读写的字节数。按系统默认的情况，当打开一个文件时，除非指定O_APPEND选项，否则该偏移量被设置为0。
    可以调用lseek显式地为一个打开的文件设置其偏移量。
#include <unistd.h>
off_t lseek (int filedes, off_t offset, int whence)；
返回值：若成功则返回新的文件偏移量，若出错则返回-1
	对参数的解释与参数的值有关。
若是SEEK_SET，则将该文件的偏移量设置为距文件开始处个字节。
若whence是SEEK_CUR,则将该文件的偏移量设置为其当前值加offset,offset可为正或负。 
若whence是SEEK_END,则将该文件的偏移量设置为文件长度加offset,offset可为正或负。若lseek成功执行，则返回新的文件偏移量，为此可以用下列方式确定打开文件的当前偏移量：
off_t currpos;
currpos = lseek(fd, 0, SEEK_CUR);
    这种方法也可用来确定所涉及的文件是否可以设置偏移量。如果文件描述符引用的是一个管道、FIFO或网络套接字，则lseek返回-1,并将errno设置为ESPIPE。
    三个符号常量SEEK_SET、SEEK_CUR和SEEK_END是由系统V引入的。在系统V之前，w/ience祓指定为0(绝对偏移量）、1(相对于当前位置的偏移量）或2(相对文件尾端的偏移量）。现有的很多软件仍然把这些数字直接写在代码里。
    lseek中的字符丨表示长整型。在引入off_t数据类型之前，oj办ef参数和返回值是长整型。lseek是由V7引入的，当时C语言中增加了长整型（在V6中，用函数seek和tell提供类似功能）。
实例
程序清单3-1中的程序用于测试能否对其标准输入设置偏移量。
	程序清单3-1测试能否对标准输入设置偏移量	
#include "apue.h" int
main(void)
{
if (lseek(STDIN 一FILENO, 0, SEEK 一CUR) == -1) printf("cannot seek\n")；
else
printf("seek OK\n")； exit(0)；
如果用交互方式调用此程序，则可得：
$ ./a.out < /etc/motd
seek OK
$ cat < /etc/motd | ./a.out
cannot seek
$ ./a.out < /var/spool/cron/FIFO
cannot seek	□
通常，文件的当前偏移量应当是一个非负整数，但是，某些设备也可能允许负的偏移量。 但对于普通文件，则其偏移量必须是非负值。因为偏移量可能是负值，所以在比较lseek的返 回值时应当谨慎，不要测试它是否小于0，而要测试它是否等于-1。
在Intel x86处理器上运行的FreeBSD上的/dev/kmem设备支持负的偏移量。
因为偏移量（off_t)是带符号数据类型（见表2-16),所以文件最大长度会减少一半。例如，若 0££_1:是32位整型，则文件最大长度是2”-1个字节。
lseek仅将当前的文件偏移量记录在内核中，它并不引起任何I/O操作。然后，该偏移量用于下一个读或写操作。
文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写将加长该文件， 并在文件中构成一个空洞，这一点是允许的。位于文件中但没有写过的字节都被读为0。
文件中的空洞并不要求在磁盘上占用存储区。具体处理方式与文件系统的实现有关，当定位到超出文件尾端之后写时，对于新写的数据需要分配磁盘块，但是对于原文件尾端和新开始写位置之间的部分则不需要分配磁盘块。

程序清单3-2中的程序用于创建一个具有空洞的文件。
	程序清单3-2创建一个具有空洞的文件	
#include "apue.h"
#include <fcntl.h>
char buf1[] = ”abcdefghij"; char buf2[] = "ABCDEFGHIJ";
int
main(void)
{
int fd;
if
if
/*
if
/*
if
((fd = creat("file.hole", FXLE_M0DE)) < 0)
err_sys("creat error")；
(write(fd, bufl, 10) != 10)
err_sys("bufl write error”};
offset now = 10 */
(lseek(fd, 16384, SEEK一SET}==
err—sys ("lseek error”；
offset now = 16384 */
(write(fd, buf2# 10) != 10)
err—sys("buf2 write error");
offset now = 16394 */
-1)
回
/*
exit(0)；
运行该程序得到：
$ ./a.out $ Is -1 file.hole 检查其大小
-rw-r--r-- 1 sar 16394 Nov 25 01:01 file.hole

$ od -c file.hole  观察实际内容

0000000 a b c
f g h i j \0 \0 \0 \0 \0 \0
0000020 \o \o \o \o \o \o \o \o \o \o \o \o \0 \0 \0 \0 
0040000 ABCDEFGHIJ 0040012

    使用Od(l)命令观察该文件的实际内容。命令行中的-C标志表示以字符方式打印文件内容。从中可以看到，文件中间的30个未写字节都被读成为0。毎一行开始的一个7位数是以八进制形 式表示的字节偏移量。
    为了证明在该文件中确实有一个空洞，将刚创建的文件与具有同样长度但无空洞的文件进 行比较：

$ ls -ls file.hole file.nohole 比较长度
8 -rw-r--r-- 1 sar	16394 Nov 25 01:01 file.hole
20 -rw-r--r-- 1 sar	16394 Nov 25 01:03 file.nohole

    虽然两个文件的长度相同，但无空洞的文件占用了20个磁盘块，而具有空洞的文件只占用8个磁盘块。
    在此实例中调用了将在3.8节中说明的write函数。4.12节将对具有空洞的文件进行更多说明。口        
    因为lseek使用的偏移量是用off_t类型表示的，所以允许具体实现根据各自特定的平台自行选择大小合适的数据类型。现今大多数平台提供两组接口以处理文件偏移量：一组使用32位文件偏移量，另一组则使用64位文件偏移量。 
    Single UNIX  Specification向应用程序提供了一种方法，使其通过sysconf函数确定何种环境受到支持（见2.5.4节)。表3-1总结了定义的sysconf常量。
表3-1 sysconf的数据大小选项和/ifl/ne参数
选项名字	说 明	name参數
_POSIX_V6_ILP32_OFF32
_POSIX_V6_ILP32_OFFBIG
_POSIX_V6_LP64_OFF64
_POSIX_V6_LP64_OFFBIG	int、long、pointer和off_t类型是32位 int、long和pointer类型是32位i off—t类型至少是64位 int类型是32位，long, pointerfPof 土加类型是]?^^ long, pointerfPoff_t类型至少是64位	一SC一V6一ILP32 一OFF32 _SC_V6_ILP3 2 一OFFBIG 一SC一V6一LP64—OFF64 _SC_V6_LP64_OFFBIG


    c99编译器要求使用getconf(1)命令，将所希望的数据大小模型映射为编译和连接程序所需的标志。根据每个平台支持环境的不同，可能需要不同的标志和库。
    不幸的是，在这一方面，实现没有跟上标准的步伐。使人更迷惑不解的是Single UNIX Specification第2版和第3版之间更改了若干个名字。
    为了避开这一点，应用程序可将符号常f_FILE_OFFSET_BITS设置为64，以支持64位偏移量。 这样处理后就将off_t定义更改为64位带符号整型。将_?11^_0??3£1'_8；0'3符号常量设置为32，就支持32位文件偏移量。但是，应,当知道的是：虽然本书讨论的四种平台都支持32位和64位文件偏移量，其方法是将—FILE_OFFSET_BITS符号常量设置为所希望的值，俚并不保这是可移植的。
    注意：尽管可以支持64位文件偏移量，但是否能创建一个大于2 TB (2^31-1个字节）的文件则依赖干底层文件系统的类型。
    
3.7	read 函数
    调用read函数从打开文件中读数据。
#include <unistd.h>
ssize_t read{int filedesr void *buf, size—t nbytes)；
返回值：若成功则返回读到的字节数.若已到文件结尾则返回0.若出错则返回-1
如read成功，则返回读到的字节数。如已到达文件结尾，则返回0。
    有多种情况可使实际读到的字节数少干要求读的字节数： •读普通文件时，在读到要求字节数之前已到达了文件尾端。例如，若在到达文件尾端之前还有30个字节，而要求读100个字节，则read返回30，下一次再调用read时，它将返回0 (文件尾端)。
    •当从终端设备读时，通常一次最多读一行（第18章将介绍如何改变这一点)。
    •当从网络读时，网络中的缓冲机构可能造成返回值小于所要求读的字节数。
    •当从管道或FIFO读时，如若管道包含的字节少于所需的数量，那么read将只返回实际可用的字节数。
    •当从某些面向记录的设备（例如磁带）读时，一次最多返回一个记录。
    •当某一信号造成中断，而已经读了部分数据量时。我们将在10.5节进一步讨论此种情况。读操作从文件的当前偏移量处开始，在成功返回之前，该偏移量将增加实际读到的字节数。
    
POSIX.1从几个方面对read函数的原型作了更改。其经典定义是：
int read (int filedes, char *buf, unsigned nbyies)；
    •首先，为了与ISO C保持一致，将第二个参数由Char *改为void *。在ISO C中，类型void*用于表示通用指针。
    •其次，其返回值必须是一个带符号整数（ssize_t)，以返回正字节数、0(表示文件尾端）或-1(出错)。
    •最后，第三个参数在历史上是一个不带符号整数，这允许一个16位的实现一次读或写的数据可以多达65534个字节。在1990 POSIX.1标准中，引入了基本系统数据类型ssize_t以提供带符号的返回值，不带符号的size_t则用于第三个参数（见2.5.2节中的 SSIZE_MAX常量)。
    
3.8	write函数
    调用write函数向打开的文件写数据。
#include <unistd.h>
ssize_t write (int filedes, const void *buf, size—t nbytes);
返回值：若成功则返回已写的字节数，若出错则返回-1
    其返回值通常与参数nbytes的值相同，否则表示出错。write出错的一个常见原因是：磁盘已写满，或者超过了一个给定进程的文件长度限制（见7.11节及习题10.11)。
    对于普通文件，写操作从文件的当前偏移量处开始。如果在打开该文件时，指定了O_APPEND选项，则在每次写操作之前，将文件偏移量设置在文件的当前结尾处。在一次成功写之后，该文件偏移量增加实际写的字节数。
    
3.9	I/O的效率
    程序清单3-3中的程序使用read和write函数复制一个文件。关于该程序应注意下列各点： •它从标准输入读，写至标准输出，这就假定在执行本程序之前，这些标准输入、输出已由shell安排好。确实，所有常用的UNIX系统sheU都提供一种方法，它在标准输入上打开一个文件用于读，在标准输出上创建（或重写）一个文件。这使得程序不必自行打开输入和输出文件。
    •很多应用程序假定标准输入是文件描述符0，标准输出是文件描述符1。本示例中则使用在<unistd.h> 中定义的两个名字STDIN_FILEN0和STDOUT_FILEN0。
    •考虑到进程终止时，UNIX系统内核会关闭该进程的所有打开的文件描述符，所以此示例并不会关闭输入和输出文件。
    •对UNIX系统内核而言，文本文件和二进制代码文件并无区别，所以本示例对这两种文件都能工作。
    程序清单3-3将标准输入复制到标准输出	
#include "apue.h"
#define BUFFSIZE 4096 int
main (void)
{
int n；
char buf[BUFFSIZE];
while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0) if (write(STDOUT_FiLENO, buf, n) != n) err_sys("write error");
if (n < 0)
err_sys("read error")；
exit(0)；
我们没有回答的一个问题是如何选取BUFFSIZE值。在回答此问题之前，让我们先用各种 不同的BUFFSIZE值来运行此程序。表3-2显示了用20种不同的缓冲区长度，读103 316 352字节 的文件所得到的结果。

表3-2用不同缓冲区长度进行读操作的计时结果
BUFFSIZE	用户CPU (秒）	系统CPU (秒）	时钟时间（秒）	循环次数
1	124.89	161.65	288.64	103 316 352
2	63.10	80.96	145.81	51 658 176
4	31.84	40.00	72.75	25 829 088
8	15.17	21.01	36.85	12 914 544
16	7.86	10.27	18.76	6457 272
32	4.13	5.01	9.76	3 228 636
64	2.11	2.48	6.76	1 614 318
128	1.01	1.27	6.82	807 159
256	0.56	0.62	6.80	403 579
512	0.27	0.41	7.03	201 789
1 024	0.17	0.23	7.84	100 894
2 048	0.05	0.19	6.82	50 447
4 096	0.03	0.16	6.86	25 223
8 192	0.01	0.18	6.67	12 611
16 384	0.02	0.18	6.87	6 305
32 768	0.00	0.16	6.70	3 152
65 536	0.02	0.19	6.92	1 576
131 072	0.00	0,16	6.84	788
262 144	0.01	0.25	7.30	394
524 288	0.00	0.22	7.35	198

    用程序清单3-3中的程序读文件，其标准输出被重新定向到/dev/null上。此测试所用的文件系统是Linux ext2文件系统，其块长为4096字节（块长由st_blksize表示，在4.12节中说明其值为4096)。系统CPU时间的最小值出现在BUFFSIZE为4096处，继续增加缓冲区长度 对此时间几乎没有影响。
    大多数文件系统为改善其性能都采用某种预读（read ahead)技术。当检测到正进行顺序读取时，系统就试图读入比应用程序所要求的更多数据，并假想应用程序很快就会读这些数据。从表3-2中最后几个记录项可以观察到，在ext2中，当BUFFSIZE为128 KB后，预读停止了，这对读操作的性能产生了影响。
    我们以后还将回到这一实例上。3.14节将用此说明同步写的效果，5.8节将比较不带缓冲的间I/O时间与标准I/O库所用的时间。
    应当了解，在什么时间对实施文件读、写操作的程序进行性能度量。操作系统试图用缓存技术将相关文件放S在主存中，所以如若重k度量程序性能，那么后续运行该程序所得到的计时很可能好于第一次。其原因是，第一次运行使文件进入系统缓存，后续各次运行一般从系统缓存访问文件，而无需读、写磁盘。
    在表3-2所示的測试数据中.每次运行使用不同的缓冲区大小和不同的文件副衣，所以前一次运行在缓存中留下的数据是后一次运行所不需要的，换言之，后一次运行不会在缓存中找到它所需要的数据。这些文件都足够大，不可能全部保留在缓存中（测试系统配置了512MB RAM)。
    
3.10文件共享
    UNIX系统支持在不同进程间共享打开的文件。在介绍dup函数之前，先要说明这种共享。为此先介绍内核用于所有I/O的数据结构。
    下面的说明是概念性的，与特定实现可能匹配，也可能不匹配。参阅Bach[1986]对系统V中相关数据结构的讨论。McKusiek等人[1996]说明T4.4BSD中的相关数据结构。McKusick和Neville-Neil[2005]对FreeBSD 5.2进行了介绍。对Solaris的类似讨论参见Mamo和McDougall[2001]。
    内核使用三种数据结构表示打开的文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响。
    (1)	毎个进程在进程表中都有1个记录项，记录项中包含有一张打开文件描述符表，可将其视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是：
        (a)	文件描述符标志（close_on_exec，参见图3-1和3.14节）。
        (b)	指向一个文件表项的指针。
    (2)	内核为所有打开文件维持一张文件表。每个文件表项包含：
        (a)	文件状态标志（读、写、添写、同步和非阻塞等，关于这些标志的更多信息参见3.14节)。
        (b)	当前文件偏移量。
        (c)	指向该文件v节点表项的指针。
    (3)	每个打开文件（或设备）都有一个v节点（v-node)结构。v节点包含了文件类型和对此文件进行各种操作的函数的指针。对于大多数文件，v节点还包含了该文件的i节点（i-node，索引节点）。这些信息是在打开文件时从磁盘上读入内存的，所以所有关于文件的信息都是快速可供使用的。例如，i节点包含了文件的所有者、文件长度、文件所在的设备、指向文件实际数据块在磁盘上所在位置的指针等等（4.14节较详细地说明了典型UNIX系统文件系统，并将更 多地介绍i节点)。
    Linux没有使用v节点，而是使用了通用1节点结构。虽然两种实现有所不同，但在概念上，v节点与i节点是一样的。两者都指向文件系统特有的i节点结构。
    我们忽略了某些实现细节，但这并不影响孝们的讨论。例如，打开文件描述符表可存放在用户空间，而非进程表中。这些表也可以用多种方式实现，不必一定是数组，例如，可将它们实现为结构的链接表。这些细节并不影响我们在文件共享方面的讨论。
图3-1显示了一个进程的三张表之间的关系。该进程有两个不同的打开文件：一个文件打开为标准输入（文件描述符0),另一个打开为标准输出（文件描述符为1)。从UNIX系统的早期版 本[Thompson 1978]以来，这三张表之间的基本关系一直保持至今。这种安排对于在不同进程之间共享文件的方式非常重要。在以后的章节中涉及其他文件共享方式时还会回到这张图上来。
---
进程表项
V节点表
i节点信息
fd标志文件指针
当前文件长度
当前文件长度
图3-1打开文件的内核数据结构
---
    创建v节点结构的目的是对在一个计算机系统上的多文件系统类型提供支持这一工作是由peter Weinberger (贝尔实验室）和Bill Joy(Sun公司）分别独立完成的。Sun称此种文件手、统为虚拟文件系 统（Virtual File System),称与文件系统类型无关的i节点部分为v节点[Kleiman   1986]。当各个制造商的实现增加了对Sun的网络文件系统(NFS)的支持时，它们都广泛采用了v节点结构。在BSD系列中首 先提供v节点的是4.3BSD Reno版本，其中加入了NFS。
    在SVR4中，v节点代换了SVR3中与文忤系统类型无关的i节点结构。Solaris是从SVR4发展而来的，它也使用v节点。
    Linux没有将相关数接结构分为i节fe和v节点，而是采用了一个独立于文件系统的i节点和一个依赖于文件系统的i节点。
    如果两个独立进程各自打开了同一个文件，则有图3-2中所示的安排。我们假定第一个进程在文件描述符3上打开该文件，而另一个进程则在文件描述符4上打开该文件。打开该文件的每个进程都得到一个文件表项，但对一个给定的文件只有一个v节点表项。每个进程都有自己的文件表项的一个理由是：这种安排使每个进程都有它自己的对该文件的当前偏移量。
    给出了这些数据结构后，现在对前面所述的操作作进一步说明。
    •在完成每个write后，在文件表项中的当前文件偏移量即增加所写的字节数。如果这使当前文件偏移量超过了当前文件长度，则在i节点表项中的当前文件长度被设置为当前文件偏移量（也就是该文件加长了）。
    •如果用O_APPEND标志打开了一个文件，则相应标志也被设置到文件表项的文件状态标志中。毎次对这种具有添写标志的文件执行写操作时，在文件表项中的当前文件偏移量 首先被设置为i节点表项中的文件长度。这就使得毎次写的数据都添加到文件的当前尾端处。
    •若一个文件用lseek定位到文件当前的尾端，则文件表项中的当前文件偏移量被设置为i节点表项中的当前文件长度。（注意，这与用O_APPEND标志打开文件是不同的，详见3.11 节。)
    • lseek函数只修改文件表项中的当前文件偏移量，没有进行任何I/O操作。
---
进程表项
图3-2两个独立进程各自打开同一个文件
---
    可能有多个文件描述符项指向同一文件表项。在3.12节中讨论dup函数时，我们就能看到这一点。在fork后也会发生同样的情况，此时父、子进程对于毎一个打开文件描述符共享同一个文件表项（见8_3节)。
    注意，文件描述符标志和文件状态标志在作用域方面的区别，前者只用于一个进程的一个描述符，而后者则适用于指向该给定文件表项的任何进程中的所有描述符。在3.14节说明fcntl函数时，我们将会了解如何获取和修改文件描述符标志和文件状态标志。
    本节上面所述的一切对于多个进程读同一文件都能正确工作。毎个进程都有它自己的文件表项，其中也有它自己的当前文件偏移量。但是，当多个进程写同一个文件时，则可能产生预UB期不到的结果。为了说明如何避免这种情况，需要理解原子操作的概念。
 


3.11原子操作
1.添写至一个文件
    考虑一个进程，它要将数据添加到一个文件尾端。早期的UNIX系统版本并不支持open的O_APPEND选项，所以程序被编写成下列形式：
if (lseek(fd, OL, 2) < 0)	/* position to EOF */
    err_sys("lseek error")；
if (write(fd, buf, 100) != 100) /* and write */ 
    err_sys("write error")；
    对单个进程而言，这段程序能正常工作，但若有多个进程同时使用这种方法将数据添加到同一文件，则会产生问题。（例如，若此程序由多个进程同时执行，各自将消息添加到一个日志文件中，就会产生这种情况。)
    假定有两个独立的进程A和B都对同一文件进行添加操作。毎个进程都已打开了该文件，但未使用O_APPEND标志。此时，各数据结构之间的关系如图3-2中所示。毎个进程都有它自己的文件表项，但是共享一个V节点表项。假定进程A调用了lseek,它将进程A的该文件当前偏移量设置为1500字节（当前文件尾端处)。然后内核切换进程使进程B运行。进程B执行lseek，也将其对该文件的当前偏移量设置为1500字节（当前文件尾端处)。然后B调用write,它将B的该文件当前文件偏移量增至1600。因为该文件的长度已经增加了，所以内核对v节点中的当前文件长度更新为1600。然后，内核又进行进程切换使进程A恢复运行。当A调用write时，就从其当前文件偏移量（1500字节）处将数据写到文件中去。这样也就代换了进程B刚写到该文件中的数据。
    问题出在逻辑操作“定位到文件尾端处，然后写”上，它使用了两个分开的函数调用。解决问题的方法是使这两个操作对于其他进程而言成为一个原子操作。任何一个需要多个函数调用的操作都不可能是原子操作，因为在两个函数调用之间，内核有可能会临时挂起该进程（正如我们前面所假定的)。
    UNIX系统提供了一种方法使这种操作成为原子操作，该方法是在打开文件时设置O_APPEND标志。正如前一节中所述，这就使内核毎次对这种文件进行写之前，都将进程的当前偏移量设置到该文件的尾端处，于是在每次写之前就不再需要调用lseek。
    
2.pread和pwrite函数
    Single UNIX Specification包括了XSI扩展，该扩展允许原子性地定位搜索（seek)和执行I/O。pread和pwrite就是这种扩展。
#include <unistd.h>
ssize_t pread (int filedes, void *buf, size_t nbytes, off_t offset)；
返回值：读到的字节数，若已到文件结尾则返回0,若出错则返回-1 ssize t pwrite (int filedes, const void *buf, size_t nbytes, off_t ojfset)；
返回值：若成功则返回已写的字节数，若出错则返回-1
    调用pread相当于顺序调用lseek和read,但是pread又与这种顺序调用有下列重要区别: •调用pread时，无法中断其定位和读操作。
    •不更新文件指针。
    调用pwrite相当于顺序调用lseek和write，但也与它们有类似的区别。
3.创建一个文件
    在对open函数的O_CREAT和O_EXCL选项进行说明时，我们已见到另一个有关原子操作的例子。当同时指定这两个选项，而该文件又已经存在时，open将失敗。我们曾提及检査该文件是否存在以及创建该文件这两个操作是作为一个原子操作执行的。如果没有这样一个原子操作，那么可能会编写下列程序段：
if ( (fd = open(pathname, O—WRONLY)) < 0) { if (errno == ENOENT) {
if ((fd = creat(pathname, mode)) < 0) err_sys ("creat error1')；
} else {
err_sys("open error")}；
    如果在open和creat之间，另一个进程创建了该文件，那么就会引起问题。例如，若在这两个函数调用之间，另一个进程创建了该文件，并且写进了一些数据，然后，原先的进程执行这段程序中的creat,这时，刚由另一个进程写上去的数据就会被擦去。如若将这两者合并在一个原子操作中，这种问题也就不会产生。
    
    一般而言，原子操作（atomic operation)指的是由多步组成的操作。如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。在4.15节论述link函数以及在14.3节中说明记录锁时，还将讨论原子操作。

3.12 dup和dup2 函数
下面两个函数都可用来复制一个现存的文件描述符:
#include <unistd.h>	
int dup (int filedes)；	
int dup2 (int filedesr i	nt filedes2)；
两函数的返回值：若成功则返回新的文件描述符，若出错则返回-1
由dup返回的新文件描述符一定是当前可用文件描述符中的最小数值。用dup2则可以用参数指定新描述符的数值。如果已经打开，则先将其关闭。如若filedes等于filedes2,则dup2返回filedes2,而不关闭它。
    这些函数返回的新文件描述符与参数所共享同一个文件表项。图3-3显示了这种情况。 在此图中，我们假定进程执行了 ：
    newfd = dup(1)；
当此函数开始执行时，假定下一个可用的描述符是3(这是非常可能的，因为0、1和2由shell打开)。因为两个描述符指向同一文件表项，所以它们共享同一文件状态标志（读、写、添写等)以及同一当前文件偏移量。
    毎个文件描述符都有它自己的一套文件描述符标志T正如我们将在下一节中说明的那样，新描述符的执行时关闭（close-on-exec)标志总是由dup函数清除。
---
迸程表项
 
文件表
文件状态标志
当前文件偏移量
v节点指针
V节点表 V节点信息
i节点信息
图3-3执行dup(l)后的内核数据结构
---
    复制一个描述符的另一种方法是使用fcntl函数，3.14节将对该函数进行说明。实际上，调用
dup(filedes)
等效于
fcntl(filedes, F_DUPFD, 0);
而调用
dup2(filedes, filedes2)；
等效于
close(filedes2)；
fcntl(filedes, F_DUPFD, filedes2);
在后一种情况下，dup2并不完全等同于close加上fcntl。它们之间的区别是：
    (1)dup2是一个原子操作，而close及fcntl则包括两个函数调用。有可能在close和fcntl之间插入执行信号捕获函数，它可能修改文件描述符（第10章将说明信号)。
    (2)dup2和fcntl有某些不同的errno。
    dup2系统调用起源于V7,然后传播至所有BSD版本。而复制文件描述符的fcntl方法则首先由系统III使用，然后由系统V继续采用。SVR3.2选用了 dup2函数，4.2BSD則选用了 fcntl函数及F_DUPFD功能。POS丨X. 1要求兼有dup2及fcntl的F_DUPFD功能
    
3.13 sync、fsync和fdatasync函数
    传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。当将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中，如果该缓冲区尚未写满，则并不将其排入输出队列，而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时，再将该缓冲排入输出队列，然后待其到达队首时，才进行实际的I/O操作。这种输出方式被称为延迟写（delayed write) (Bach [1986]第3章详细讨论了缓冲区高速缓存)。
    延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度，使得欲写到文件中的数据在一段时间内并没有写到磁盘上。当系统发生故障时，这种延迟可能造成文件更新内容的丢失。为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX系统提供了sync、 fsync和fdatasync三个函数。

#include <unistd.h>	
int f sync (int filedes)；
int fdatasync (int filedes)；
返回值：若成功则返回0，若出错则返回-1
void sync(void)；

    sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。
    通常称为update的系统守护进程会周期性地（一般每隔30秒）调用sync函数。这就保证回了定期冲洗内核的块缓冲区。命令sync (1)也调用sync函数。
    fsync函数只对由文件描述符指定的单一文件起作用，并且等待写磁盘操作结束，然后返回。fsync可用于数据库这样的应用程序，这种应用程序需要确保将修改过的块立即写到磁盘上。
    fdatasync函数类似干fsync,但它只影响文件的数据部分。而除数据外，fsync还会同步更新文件的属性。
    本书说明的所有四种平台都支持sync和fsync函致。但是，FreeBSD 5.2.1和Mac OS X 1O.3并不支持fdatasync。
    
3.14 fcntl 函数
fcntl函数可以改变已打开的文件的性质。
#include <fcntl.h>
int fcntl (int filedes, int cmd, ... /* int arg */ );
返回值：若成功则依赖cmd(剑侠)，若出错则返回-1
    在本节的各实例中，第三个参数总是一个整数，与上面所示函数原型中的注释部分相对应。但是在14.3节说明记录锁时，第三个参数则是指向一个结构的指针。fcntl函数有5种功能：
    (1)复制一个现有的描述符（c»k/=F_DUPFD)。
    (2)获得/设置文件描述符标记（cmJ = F—GETF'DiF—SETFD)。
    (3)获得/设置文件状态标志(cmd = F_GETFI^F_SETFL)。
    (4)获得/设置异步I/O所有权(cmd = F—GETOWN或F—SETOWN)。
    (5)获得/设置记录锁（c»k/= F_GETLK、F—SETLK或F—SETLKW)。
    我们先说明这10种c皿/值中的前7种（14.3节说明后3种，它们都与记录锁有关）。我们将涉及与进程表项中各文件描述符相关联的文件描述符标志，以及每个文件表项中的文件状态标志(见图3-1)。
    F_DUPFD 复制文件描述符新文件描述符作为函数值返回。它是尚未打开的各描述符中大于或等于第三个参数值（取为整型值）中各值的最小值。新描述符与共享同一文件表项（见图3-3)。但是，新描述符有它自己的一套文件描述符标志，其fd_cloexec文件描述符标志被清除（这表示该描述符在通过一个exec时仍保持有效，我们将在第8章对此进行讨论)。
    F_GETFD 对应于的文件描述符标志作为函数值返回。当前只定义了一个文件描述符标志FD_CLOEXEC。
    F_SETFD 对于设置文件描述符标志。新标志值按第三个参数（取为整型值）设置。
    应当了解很多现有的涉及文件描述符标志的程序并不使用常量FD_CLOEXEC,而是将此标志设置为0(系统默认，在exec时不关闭）或1(在exec时关闭）。
    F_GETFL 对应于的文件状态标志作为函数值返回。在说明open函数时，已说明了文件状态标志。它们列于表3-3中。
    ---
    表3-3 fcntl的文件状态标志
    文件状态标志	说明
    O_RD0NLY	只读打开
    O_WR0NLY	只写打开
    O_RDWR	为读、写打开
    O_APPEND	每次写时追加
    O_N0NBL0CK	非阻塞模式
    O 一SYNC	等待写完成（数据和属性）
    O_DSYNC	等待写完成（仅数据）
    O_RSYNC	同步读、写
    O_FSYNC	等待写完成（仅FreeBSD和Mac OS X)
    O_ASYNC	异歩丨/O (仅FreeBSD和 Mac OS X)
    ---
    不幸的是，三个访问方式标志（O_RD0NLY、0一WRONLY以及OJRDWR)并不各占1位（正如前述，这三种标志的值分别是0、1和2，由于历史原因。这三种值互斥——一个文件只能有这三种值之一)。因此首先必须用屏蔽字0—ACCM0DE取得访问模式位，然后将结果与这三种值中的任一种作比较。
    F_SETFL 将文件状态标志设置为第三个参数的值（取为整型值)。可以更改的几个标志是：O_APPEND、O_N0NBLOCK、O_SYNC、O_DSYNC、O_RSYNC、O_FSYNC和O_ASYNC。
    F_GETOWN取当前接收SIGIO和SIGURG信号的进程ID或进程组ID。14.6.2节将论述这两种异步I/O信号。
    F_SETOWN 设置接收SIGIO和SIGURG信号的进程ID或进程组ID。正的指定一个进程ID，负的表示等于绝对值的一个进程组ID。
    fcntl的返回值与命令有关。如果出错，所有命令都返回-1,如果成功则返回某个其他值。下列四个命令有特定返回值：F_DUPFD、F_GETFD、F_GETFL以及F_GETOWN。第一个返回新的文件描述符，接下来的两个返回相应标志，最后一个返回一个正的进程ID或负的进程组ID。
    
实例
程序清单3-4中的程序的第一个参数指定文件描述符，并对于该描述符打印其所选择的文件

标志说明。
程序清单3-4对于指定的描述符打印文件标志
---
#include "apue.h"
#include <fcntl.h>
int
main(int argc, char *argv[3)
{
int val；
if (argc !* 2)
err一quit("usage: a.out <descriptor#>");
if ((val = fcntl(atoi(argv[l3),
err一sys("fcntl error for fd
switch (val & 。一 ACCMODE) {
case O—RDONLY:
printf (nread only”；
break；
case O—WRONLY:
printf("write only”）；
break；
case O—RDWR:
printf("read write");
break；
default：
err_dump("unknown access mode");
} 一
if (val & O一APPEND)
printf(tt, append”)；
if (val & O_N0NBL0CK)
printf(M, nonblocking”)；
#if defined(0 一SYNC)
if (val & 0-SYNC)
printf(", synchronous
#endif
#if !defined(_P0SIX_C 一SOURCE)
if (val &~O_FSYNcT
printf("• synchronous
#endif
putchar(,\n,);
exit (0) ,■
}
F一GETFL, 0)) < 0)
%d", atoi(argv[1]))；
writes")；
&& defined(O 一FSYNC) writes")；
---
注意，我们使用了功能测试宏_POSIX_C_SOURCE，并且条件编译了POSIX.1中没有定义的文件访问标志。下面显示了从bash (Boume-again shell)调用该程序时的几种情况。当使用不同shell时，结果会发生变化。
---
$ ./a.out 0	< /dev/tty read only
$ "a.out 1	> tes^>.£oo $ cat tesop. foo
write only
$ ./a.out 2	2»temp.foo
write only,	append
$ ./a.out 5 5<>tdn^>.£oo 
read write
---
子句5<>temp . foo表示在文件描述符5上打开文件temp. f oo以供读和写。

在修改文件描述符标志或文件状态标志时必须谨慎，先要取得现有的标志值，然后根据需要修改它，最后设置新标志值。不能只是执行F_SETFD*F_SETFL命令，这样会关闭以前设置的标志位。
    程序清单3-5显示了一个对一个文件描述符设置一个或多个文件状态标志的函数。
程序清单3-5对一个文件描述符打开一个或多个文件状态标志
---
#include "apue.h"
#include <fcntl.h>
void
set_f1(int fd, int flags) /★ flags are file status flags to turn on ★/
{ _
int val；
if ((val = fcntl(fd, F_GETFL/ 0)) < 0) err_sys("fcntl F—GETFL error")；
val |= flags;	/★ turn on flags ★/
if (fcntl(fd, F—SETFL, val) < 0)
err_sys("fcntl F_SETFL error");
---
    如果将中间的一条语句改为：
val &.= ~flags;	/* turn flags off */
就构成另一个函数，我们称其为clr_fl，并将在后面某个例子中用到它。此语句使当前文件状态标志值val与flags的补码进行逻辑“与”运算。
    如果在程序清单3-5的开始处，加上下面一行以调用set_fl，则打开了同步写标志。
    set_fl(STD0UT_FILEN0, 0一SYNC);
这就使每次write都要等待，直至数据已写到磁盘上再返回。在UNIX系统中，通常write只是将数据排入队列，而实际的写磁盘操作则可能在以后的某个时刻进行。数据库系统很可能需要使用O_SYNC,这样一来，它从write返回时就知道数据已确实写到了磁盘上，以免在系 统崩溃时产生数据丢失。
    程序运行时，设置O_SYNC标志会增加时钟时间。为了测试这一点，运行程序清单3-3，它从一个磁盘文件中将98.5MB字节的数据复制到另一个文件。然后，在此程序中设置O_SYNC标志，使其完成上述同样的工作，以便将两者的结果进行比较。在使用ext2文件系统的Linux系统上执行上述操作，得到的结果见表3-4。
    表3-4中的6行都是在BUFFSIZE为4096的情况下测量得到的。表3-2中的结果所测量的情况是读一个磁盘文件，然后写到/dev/null,所以没有磁盘输出。表3-4中的第2行对应于读一个磁盘文件，然后写到另一个磁盘文件中。这就是为什么表3-4中第1、2行有差别的原因。在写磁盘文件时，系统时间增加了，其原因是内核需要从进程中复制数据，并将数据排入队列以便由磁盘驱动器将其写到磁盘上。当写至磁盘文件时，我们期望时钟时间也会增加，但在本测试中，它并未显著增加，这表明写操作将数据写到了系统髙速缓存中，我们并没有测量将数据写到磁盘上的开销。
表3-4用各种同步机制在Linux ext2环塊中取得的计时结果
---
操 作	用户CPU (秒)	系统CPU (秒）	时钟时间（秒）
取自表3-2中BUFFSIZE = 4 096的读时间	0.03	0.16	6.86
正常写到磁盘文件	0.02	0.30	6.87
设置O_SYNC后写到磁盘文件	0.03	0.30	6.83
写到磁盘后接着调用fdatasync	0.03	0.42	18.28
写到磁盘后接着调用fsync	0.03	0.37	17.95
在设置O_SYNC的条件下写到磁盘，接着调用fsync	0.05	0.44	17.95
---
    当支持同步写时，系统时间和时钟时间应当会显著增加。从第3行可见，同步写所用的时间与延迟写所用的时间几乎相同。这意味着Linux ext2文件系统并未真正实现O_SYNC标志功能。第6行的时间值支持了我们的这种怀疑，其中显示，实施同步写，然后跟随fsync调用，这一操作序列所用的时间与写文件（未设置同步标志），然后接着执行fsync调用这一序列所用的时间（第5行）几乎相同。在同步写一个文件后，我们期望fsync调用不会产生影响。
    表3-5显示了在Mac OS X 10.3上运行同样的测试所得到的计时结果。注意该计时结果与我们的期望相符：同步写较延迟写所消耗的时间增加了很多，而且在同步写后再调用函数fsync并不会产生测量上的显著差别。还要引起注意的是，在延迟写后增加一个fsync函数调用也不产生可测量的差别。其原因很可能是，当写新数据到某个文件中时，操作系统将以前写的数据冲洗到了磁盘上，所以在调用函数fsync时几乎就没有什么工作要做了。
    ---
    表3-5用各种同步机制在Mac,OS X环塊中取得的计时结果
    操作	用户CPU (秒)	系统CPU (秒）	时钟时间（秒）
    写至/dev/null	0.06	0.79	4.33
    正常写到磁盘文件	0.05	3.56	14.40
    设置O_FSYNC后写到磁盘文件	0.13	9.53	22.48
    写到磁盘后接着调用fsync	0.11	3.31	14.12
    在设置O_FSYNC的条件下写到磁盘，接着调用fsync	0.17	9.14	22.12
    ---
    比较fsync和fdatasync与O_SYNC标志，fsync和fdatasync在我们需要时更新文件内容，O_SYNC标志则在我们每次写至文件时更新文件内容。
    在本例中，我们看到了fcntl的必要性。我们的程序在一个描述符（标准输出）上进行操作，但是根本不知道由shell打开的相应文件的文件名。因为这是shell打开的，于是不能在打开时，按我们的要求设置O_SYNC标志。fcntl则允许仅知道打开文件描述符时可以修改其性质。 在说明非阻塞管道时（15.2节），我们还将了解到，由于我们对管道所具有的知识只是其描述符,所以也需要使用fcntl的功能。
3.15 ioctl 函数
    ioctl函数是I/O操作的杂物箱。不能用本章中其他函数表示的I/O操作通常都能用ioctl表示。终端I/O是ioctl的最大使用方面（第18章将介绍POSIX.1已经用一些新函数代替ioctl进行终端I/O操作)。
#include	<unistd.h>	/*	System V */
#include	<ByB/ioctl .h>	/*	BSD and Linux */
#include	<stropts -h：>	/*	XSI STREAMS */
int ioctl (int filedes• int	request • ..)；
返回值：若出错则返回-1，若成功则返回其他值
    ioctl函数只是Single UNIX Specification标准的一个扩展，以便处理STREAMS设备[Rago  1993]。但是，UNIX系统实现用它进行很多杂项设备操作。有些实现甚至将它扩展到用于普通文件。
    我们所示的原型对应于POSIX.1, FreeBSD 5.2.1和Mac OS X 10.3将第二个参数声明为unsigned long。因为第二个参数总是一个头文件中的defined名字，所以这种细节并没有什么影响。
    对于ISO   C原型，它用省略号表示其余参数。但是，通常只有另外一个参数，它常常是指向一个变量或结构的指针。
    在此原型中，我们表示的只是ioctl函数本身所要求的头文件。通常，还要求另外的设备专用头文件。例如，除POSIX.1所说明的基本操作之外，终端I/O的ioctl命令都需要头文件<termios .li>。
    每个设备驱动程序都可以定义它自己寺用的一组ioctl命令。系统则为不同种类的设备提供通用的ioctl命令。表3-6总结了FreeBSD所支持的通用ioctl命令的一些类别。
    ---
    表3-6通用FreeBSD ioctl操作
    类别	常量名	头文件	ioctl数
    盘标号	DIOxxx	<sys/disklabel.h>	6
    文件i/o	FIOxxx	<sys/filio.h>	9
    磁带I/O	MTIOxxx	<sys/mtio.h>	U
    套接字I/O	SIOxxx	<sys/sockio.h>	60
    终端i/o	TIOxxx	<sys/ttycom.h>	44
    ---
    磁带操作使我们可以在磁带上写一个文件结束标志、反绕磁带、越过指定个数的文件或记录等等，用本章中的其他函数（read、write、lseek等）都难以表示这些操作，所以，用ioctl是对这些设备进行操作的最容易方法。
    在14.4节中说明STREAMS系统、18.12节中获取和设置终端窗口大小以及19.7节中论及伪终端的高级功能时，都将使用ioctl函数。
    
3.16 /dev/fd
    较新的系统都提供名为/dev/fd的目录，其目录项是名为0、1、2等的文件。打开文件/dev/fd/n等效干复制描述符n (假定描述符n是打开的）。
    /dev/fd这种特征是由Tom Duff开发的，它首先出现在Research UNIX System的第8版中，本书说明的所有四种系统都支持这种特征。它不是POSIX. 1的纽成部分。
    在下列函数调用中：
    fd = open("/dev/fd/0", mode)；
    大多数系统忽略它所指定的mode,而另外一些则要求mode必须是所涉及的文件（在这里则是标准输入）原先打开时所使用mode的子集。因为上面的打开等效于：
    fd = dup(0);
所以描述符0和fd共享同一文件表项（见图3-3)。例如，若描述符0先前被打开为只读，那么我们也只能对fd进行读操作。即使系统忽略打开模式，并且下列调用成功：
    fd = open("/dev/fd/0", O_RDWR);
我们仍然不能对fd进行写操作。
    我们也可以用/dev/fd作为路径名参数调用creat,这与调用open时，用O_CREAT作为第2个参数作用相同。例如，若程序调用creat,并且路径名参数是/dev/fd/1等，那么该程序仍能工作。
    某些系统提供路径名/dev/stdin、/dev/stdout和/dev/stderr。这些等效于 /dev/fd/0、/dev/fd/1和/dev/fd/2。
    /dev/fd文件主要由shell使用，它允许使用路径名作为调用参数的程序，能用处理其他路径名的相同方式处理标准输入和输出。例如，cat(l)程序对其命令行参数采取了一种特殊处理，它将单独的一个字符解释为标准输入。例如：
    filter file2 | cat filel - file3 | lpr
    首先cat读filel,接着读其标准输入（也就是filter file2命令的输出），然后读file3,如若支持/dev/fd,则可以删除cat对的特殊处理，于是我们就可键入下列命令行：
    filter file2 | cat filel /dev/fd/0 file3 | lpr
    在命令行中用作为一个参数，特指标准输入或标准输出，这已由很多程序采用。但是这会带来一些问题，例如若用指定第一个文件名，那么它看来就像指定了命令行中的一个选项。/dev/fd则提髙了文件名参数的一致性，也更加清晰。
3.17小结
    本章说明了UNIX系统提供的基本I/O函数。因为read和write都在内核执行，所以称这些函数为不带缓冲的I/O函数。在只使用read和write情况下，我们观察了不同的I/O长度对读文件所需时间的影响。我们也观察了许多将写入的数据冲洗到磁盘上的方法，说明了它们对应用程序性能的影响。
    在说明多个进程对同一文件进行添写操作以及多个进程创建同一文件时，本章介绍了原子操作。也介绍了内核用来共享打开文件信息的数据结构。在本书的稍后部分还将涉及这些数据结构。
    我们还介绍了ioctl和fcntl函数。第I4章还将使用这两个函数，将ioctl用于STREAMS I/O系统，将fcntl用于记录锁。

    习题
3.1当读/写磁盘文件时，本章中描述的函数是否有缓冲机制？请说明原因。
3.2编写一个与3.12节中dup2功能相同的函数，要求不调用fcntl函数，并且要有正确的出错 处理。
3.3假设一个进程执行下面的3个函数调用：
fdl = open(pathname, oflags);
fd2 = dup(fd1);
fd3 = open(pathname, oflags);
画出类似于图3-3的结果图。对fcntl作用于fdl来说，F_SETFD命令会影响哪一个 文件描述符？F_SETFL呢？
3.4在许多程序中都包含下面一段代码：
dup2(fd, 0); 
dup2(fd, 1);
dup2(fd, 2);
if (fd > 2) 
    close(fd);
为了说明if语句的必要性，假设fd是1,画出每次调用dup2时3个描述符项及相应的文件表项的变化情况。然后再画出fd为3的情况。
3.5	在Bourne shell、Boume-again shell和Korn shell中，沿g/fl > &沿押2表示要将描述符^%!71 重定向至描述符^如>2的同一文件。请说明下面两条命令的区别。
./a.out > outfile 2>&1 
./a.out 2>&1 > outfile
(提示：shell从左到右处理命令行。)
3.6如果使用添加标志打开一个文件以便读、写，能否仍用lseek在任一位置开始读？能否用lseek更新文件中任一部分的数据？请编写一段程序以验证之。

